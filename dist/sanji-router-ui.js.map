{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///sanji-router-ui.js","webpack:///webpack/bootstrap 30f683dace4f15d1e411","webpack:///../~/@uirouter/core/lib/common/common.js","webpack:///../~/@uirouter/core/lib/common/predicates.js","webpack:///../~/@uirouter/core/lib/common/hof.js","webpack:///../~/@uirouter/core/lib/common/coreservices.js","webpack:///../~/@uirouter/core/lib/index.js","webpack:///../~/@uirouter/core/lib/common/strings.js","webpack:///../~/@uirouter/core/lib/common/trace.js","webpack:///../~/@uirouter/core/lib/state/targetState.js","webpack:///../~/@uirouter/angularjs/lib/angular.js","webpack:///../~/@uirouter/core/lib/params/param.js","webpack:///../~/@uirouter/core/lib/transition/interface.js","webpack:///../~/@uirouter/core/lib/resolve/resolvable.js","webpack:///../~/@uirouter/core/lib/transition/rejectFactory.js","webpack:///../~/@uirouter/core/lib/transition/transitionHook.js","webpack:///../~/@uirouter/core/lib/vanilla/utils.js","webpack:///../~/@uirouter/core/lib/common/glob.js","webpack:///../~/@uirouter/core/lib/common/index.js","webpack:///../~/@uirouter/core/lib/path/pathFactory.js","webpack:///../~/@uirouter/core/lib/resolve/resolveContext.js","webpack:///../~/@uirouter/core/lib/transition/transition.js","webpack:///../~/@uirouter/core/lib/url/urlMatcher.js","webpack:///../~/@uirouter/core/lib/vanilla/baseLocationService.js","webpack:///external {\"root\":\"angular\",\"commonjs2\":\"angular\",\"commonjs\":\"angular\",\"amd\":\"angular\"}","webpack:///../~/@uirouter/angularjs/lib/services.js","webpack:///../~/@uirouter/angularjs/lib/statebuilders/views.js","webpack:///../~/@uirouter/core/lib/common/queue.js","webpack:///../~/@uirouter/core/lib/params/paramType.js","webpack:///../~/@uirouter/core/lib/path/pathNode.js","webpack:///../~/@uirouter/core/lib/state/stateObject.js","webpack:///../~/@uirouter/core/lib/transition/hookRegistry.js","webpack:///../~/@uirouter/core/lib/transition/transitionService.js","webpack:///../~/@uirouter/angularjs/lib/stateProvider.js","webpack:///../~/@uirouter/angularjs/lib/urlRouterProvider.js","webpack:///../~/@uirouter/core/lib/globals.js","webpack:///../~/@uirouter/core/lib/hooks/lazyLoad.js","webpack:///../~/@uirouter/core/lib/params/paramTypes.js","webpack:///../~/@uirouter/core/lib/params/stateParams.js","webpack:///../~/@uirouter/core/lib/resolve/interface.js","webpack:///../~/@uirouter/core/lib/router.js","webpack:///../~/@uirouter/core/lib/state/stateBuilder.js","webpack:///../~/@uirouter/core/lib/state/stateMatcher.js","webpack:///../~/@uirouter/core/lib/state/stateQueueManager.js","webpack:///../~/@uirouter/core/lib/state/stateRegistry.js","webpack:///../~/@uirouter/core/lib/state/stateService.js","webpack:///../~/@uirouter/core/lib/transition/hookBuilder.js","webpack:///../~/@uirouter/core/lib/transition/transitionEventType.js","webpack:///../~/@uirouter/core/lib/url/urlMatcherFactory.js","webpack:///../~/@uirouter/core/lib/url/urlRouter.js","webpack:///../~/@uirouter/core/lib/url/urlRule.js","webpack:///../~/@uirouter/core/lib/url/urlService.js","webpack:///../~/@uirouter/core/lib/vanilla/browserLocationConfig.js","webpack:///../~/@uirouter/core/lib/vanilla/hashLocationService.js","webpack:///../~/@uirouter/core/lib/vanilla/injector.js","webpack:///../~/@uirouter/core/lib/vanilla/memoryLocationConfig.js","webpack:///../~/@uirouter/core/lib/vanilla/memoryLocationService.js","webpack:///../~/@uirouter/core/lib/vanilla/pushStateLocationService.js","webpack:///../~/@uirouter/core/lib/vanilla/q.js","webpack:///../~/@uirouter/core/lib/view/view.js","webpack:///../~/@uirouter/angularjs/lib/index.js","webpack:///./component/router-helper.js","webpack:///external {\"root\":\"sjLogger\",\"commonjs2\":\"sanji-logger-ui\",\"commonjs\":\"sanji-logger-ui\",\"amd\":\"sanji-logger-ui\"}","webpack:///../~/@uirouter/angularjs/lib/directives/stateDirectives.js","webpack:///../~/@uirouter/angularjs/lib/directives/viewDirective.js","webpack:///../~/@uirouter/angularjs/lib/injectables.js","webpack:///../~/@uirouter/angularjs/lib/locationServices.js","webpack:///../~/@uirouter/angularjs/lib/stateFilters.js","webpack:///../~/@uirouter/angularjs/lib/statebuilders/onEnterExitRetain.js","webpack:///../~/@uirouter/angularjs/lib/templateFactory.js","webpack:///../~/@uirouter/angularjs/lib/viewScroll.js","webpack:///../~/@uirouter/core/lib/hooks/coreResolvables.js","webpack:///../~/@uirouter/core/lib/hooks/ignoredTransition.js","webpack:///../~/@uirouter/core/lib/hooks/invalidTransition.js","webpack:///../~/@uirouter/core/lib/hooks/onEnterExitRetain.js","webpack:///../~/@uirouter/core/lib/hooks/redirectTo.js","webpack:///../~/@uirouter/core/lib/hooks/resolve.js","webpack:///../~/@uirouter/core/lib/hooks/updateGlobals.js","webpack:///../~/@uirouter/core/lib/hooks/url.js","webpack:///../~/@uirouter/core/lib/hooks/views.js","webpack:///../~/@uirouter/core/lib/interface.js","webpack:///../~/@uirouter/core/lib/params/index.js","webpack:///../~/@uirouter/core/lib/path/index.js","webpack:///../~/@uirouter/core/lib/resolve/index.js","webpack:///../~/@uirouter/core/lib/state/index.js","webpack:///../~/@uirouter/core/lib/transition/index.js","webpack:///../~/@uirouter/core/lib/url/index.js","webpack:///../~/@uirouter/core/lib/vanilla.js","webpack:///../~/@uirouter/core/lib/vanilla/index.js","webpack:///../~/@uirouter/core/lib/vanilla/plugins.js","webpack:///../~/@uirouter/core/lib/view/index.js","webpack:///./component/index.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_22__","__WEBPACK_EXTERNAL_MODULE_60__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","identity","x","noop","createProxyFunctions","source","target","bind","fnNames","latebind","bindFunction","fnName","makeLateRebindFn","apply","arguments","keys","reduce","acc","_inArray","array","obj","indexOf","_removeFrom","idx","splice","_pushTo","arr","val","push","defaults","opts","defaultsList","_i","length","_defaultsList","concat","reverse","defaultVals","extend","pick","ancestors","first","second","path","propNames","objCopy","prop_1","omit","filter","hof_1","not","inArray","key","pluck","collection","propName","map","prop","callback","predicates_1","isArray","result","accept","forEach","item","find","pushR","assertFn","predicateOrMap","errMsg","Error","isFunction","arrayTuples","args","maxArrayLen","min","Math","applyPairs","memo","keyValTuple","isString","tail","undefined","_copy","src","dest","_forEach","cb","_this","_extend","toObj","j","_equals","o1","o2","t1","tup","all","_arraysEq","isDate","getTime","isRegExp","toString","any","b","fn","a1","a2","t","coreservices_1","w","window","angular","fromJson","JSON","parse","toJson","stringify","copy","assign","equals","inherit","parent","extra","create","curry","removeFrom","pushTo","deregAll","functions","slice","mergeR","mapObj","values","allTrueR","elem","anyTrueR","unnestR","flattenR","uniqR","token","unnest","flatten","assertPredicate","assertMap","pairs","sortBy","propFn","checkFn","a","composeSort","sortFns","prev","silenceUncaughtInPromise","promise","catch","e","silentRejection","error","services","$q","reject","isInjectable","head","stateObject_1","toStr","tis","isUndefined","isDefined","isNull","isNullOrUndefined","or","isNumber","isObject","Array","isState","StateObject","isPromise","and","pipe","curried","func_args_length","initial_args","compose","start","funcs","fn1","fn2","invoke","pattern","struct","propEq","split","is","ctor","constructor","eq","other","v","notImplemented","fnname","$injector","__export","maxLength","max","str","substr","padString","kebobString","camelCase","replace","$1","toLowerCase","functionToString","fnStr","fnToString","namedFunctionMatch","match","_fn","format","seen","stringifyPattern","splitOnDelim","delim","re","RegExp","common_1","joinNeighborsR","rejectFactory_1","transition_1","resolvable_1","stringifyPatternFn","isRejection","Rejection","isRejectionPromise","_transitionRejection","Transition","Resolvable","beforeAfterSubstr","char","uiViewString","viewData","id","creationContext","fqn","normalizedCat","input","Category","strings_1","viewConfigString","viewConfig","$id","viewDecl","$context","$uiViewName","$uiViewContextAnchor","_tid","_rid","transLbl","trans","Trace","_enabled","approximateDigests","_set","enabled","categories","k","parseInt","isNaN","category","enable","disable","traceTransitionStart","TRANSITION","console","log","traceTransitionIgnored","traceHookInvocation","step","options","HOOK","event","context","registeredHook","traceHookResult","hookResult","transitionOptions","traceResolvePath","when","RESOLVE","traceResolvableResolved","resolvable","data","traceError","reason","traceSuccess","finalState","traceUIViewEvent","UIVIEW","traceUIViewConfigUpdated","traceUIViewFill","html","traceViewServiceEvent","VIEWCONFIG","traceViewServiceUIViewEvent","trace","TargetState","_identifier","_definition","_params","_options","identifier","params","$state","state","self","exists","valid","base","relative","stateName","isDef","ng_from_import","ng_from_global","ng","unwrapShorthand","cfg","getStaticDefaultValue","isShorthand","$$fn","getType","urlType","location","paramTypes","type","DefType","CONFIG","PATH","SEARCH","paramType_1","ParamType","getSquashPolicy","config","isOptional","defaultPolicy","squash","getReplace","arrayMode","configuredKeys","from","to","hasOwn","Param","urlMatcherFactory","arrayDefaults","arrayParamNomenclature","$asArray","dynamic","raw","defaultSquashPolicy","isDefaultValue","_a","tuple","_defaultValueCache","defaultValue","$normalize","isSearch","validates","normalized","encoded","encode","exec","paramValues","params_1","param","changed","values1","values2","TransitionHookPhase","TransitionHookScope","trace_1","defaultResolvePolicy","async","arg1","resolveFn","deps","policy","resolved","literal","getPolicy","thisPolicy","statePolicy","resolvePolicy","resolve","resolveContext","getResolvableDependencies","getDependencies","invokeResolveFn","resolvedDeps","waitForRx","observable$","cached","cache","take","toPromise","then","node","findNode","maybeWaitForRx","applyResolvedValue","resolvedValue","clone","fromData","RejectType","message","detail","superseded","rejection","SUPERSEDED","redirected","invalid","INVALID","ignored","IGNORED","aborted","ABORTED","errored","ERROR","normalize","interface_1","targetState_1","defaultOptions","current","transition","traceData","TransitionHook","stateContext","isSuperseded","hookPhase","RUN","isActive","eventType","logError","err","router","stateService","defaultErrorHandler","invokeHook","hook","_deregistered","notCurrent","getNotCurrentRejection","normalizeErr","handleError","getErrorHandler","handleResult","getResultHandler","synchronous","handleHookResult","_disposed","_aborted","chain","hooks","waitFor","createHookChainR","nextHook","invokeHooks","doneCallback","remainingHooks","runAllHooks","HANDLE_RESULT","LOG_REJECTED_RESULT","LOG_ERROR","REJECT_ERROR","THROW_ERROR","parseUrl","url","orEmptyString","splitHash","beforehash","hash","_b","splitQuery","search","locationPluginFactory","isHtml5","serviceClass","configurationClass","dispose","service","configuration","locationService","locationConfig","index_1","splitEqual","trimHashVal","keyValsToObjectR","accum","getParams","queryString","buildUrl","loc","searchObject","join","Glob","text","glob","regexpString","seg","regexp","matches","test","fromString","pathNode_1","PathUtils","makeTargetState","buildPath","targetState","toParams","PathNode","applyRawParams","buildToPath","fromPath","toPath","inheritParams","applyViewConfigs","$view","states","viewDecls","views","subPath","viewConfigs","view","createViewConfig","toKeys","nodeParamVals","makeInheritedParamsNode","toNode","toParamVals","incomingParamVals","fromParamVals","noInherit","ownParamVals","paramSchema","treeChanges","reloadState","applyToParams","retainedNode","cloned","keep","node1","node2","nonDynamicParams","retained","exiting","entering","retainedWithToParams","matching","pathA","pathB","paramsFn","done","nodeA","nodeB","predicate","elementIdx","parameters","pathFactory_1","resolvePolicies","ALL_WHENS","EAGER","LAZY","EAGER_WHENS","NATIVE_INJECTOR_TOKEN","ResolveContext","_path","getTokens","resolvables","r","getResolvable","subContext","addResolvables","newResolvables","resolvePath","whenOption","matchedWhens","matchesPolicy","acceptedVals","whenOrAsync","promises","nodeResolvables","nowait","wait","getResult","injector","_injector","UIInjectorImpl","availableResolvables","res","getDependency","fromInjector","getNative","native","getAsync","transitionHook_1","hookRegistry_1","hookBuilder_1","param_1","resolveContext_1","stateSelf","_deferred","defer","_registeredHooks","_hookBuilder","HookBuilder","globals","_targetState","transitionService","_transitionCount","_treeChanges","createTransitionHookRegFns","onCreateHooks","buildHooksForPhase","CREATE","onBefore","criteria","onStart","onExit","onRetain","onEnter","onFinish","onSuccess","onError","_pluginapi","_getEvents","makeEvent","getHooks","hookName","enteringStates","$from","$to","compare","matchState","pathname","freeze","pathName","getResolveTokens","addResolvable","topath","targetNode","redirectedFrom","originalTransition","rf","redirect","redirects","redirectOpts","newOptions","newTransition","originalEnteringNodes","redirectEnteringNodes","includes","_changedParams","tc","reload","nodeSchemas","toValues","fromValues","schema","toVals","fromVals","changes","_ignoredReason","pending","same","newTC","pendTC","run","getHooksFor","phase","transitionSuccess","success","SUCCESS","transitionError","_error","runTransition","allRunHooks","startTransition","lastStartedTransitionId","transitionHistory","enqueue","allBeforeHooks","BEFORE","abort","abstract","fromStateOrName","toStateOrName","avoidEmptyHash","diToken","quoteRegExp","string","surroundPattern","memoizeTo","splitOnSlash","UrlMatcher","paramFactory","_cache","_children","_segments","_compiled","strict","caseInsensitive","paramMap","segment","placeholder","searchPlaceholder","last","patterns","checkParamErrors","nameValidator","matchDetails","substring","index","lastIndex","fromSearch","append","isRoot","allParams","pathParams","searchParams","nPathSegments","urlm","reverseString","unquoteDashes","allReversed","decode","matcher","parameter","validParamVal","paramDef","getDetails","isValid","urlMatchers","pathSegmentsAndParams","queryParams","isInvalid","pathString","encodeDashes","encodeURIComponent","paramDetails","charCodeAt","toUpperCase","staticSegments","cmp","segments","weights","utils_1","BaseLocationServices","fireAfterUpdate","_listener","evt","_listeners","_get","_location","_history","history","evt_1","Event","onChange","$uiRouter","$locationProvider","$get","$location","$browser","$sniffer","$rootScope","$http","$templateCache","ng1LocationService","_runtimeServices","core_1","UIRouter","stateProvider","stateProvider_1","StateProvider","stateRegistry","decorator","views_1","ng1ViewsBuilder","onEnterExitRetain_1","getStateHookBuilder","viewService","_viewConfigFactory","getNg1ViewConfigFactory","locationServices_1","Ng1LocationServices","monkeyPatchPathParameterType","$inject","runBlock","$$state","annotate","watchDigests","$watch","angular_1","templateFactory_1","urlRouterProvider_1","mod_init","mod_util","mod_rtr","mod_state","mod_main","getProviderFor","serviceName","$urp","getUrlRouterProvider","uiRouter","urlRouterProvider","UrlRouterProvider","getStateProvider","provider","TemplateFactory","$urlMatcherFactory","$urlRouter","getLocals","ctx","templateFactory","Ng1ViewConfig","tplKeys","ctrlKeys","compKeys","nonCompKeys","allViewKeys","hasAnyKey","viewsObject","$default","component","resolveAs","$type","$name","ViewService","normalizeUIViewTarget","uiViewName","uiViewContextAnchor","loaded","getTemplate","uiView","makeComponentTemplate","bindings","template","load","fromConfig","controller","getController","results","controllerProvider","providerFn","Queue","_items","_limit","items","shift","dequeue","size","clear","remove","peekTail","peekHead","ArrayType","mode","arrayWrap","arrayUnwrap","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","left","right","paramTypeFn","wrapperFn","$arrayMode","def","$subPattern","sub","stateOrNode","getParamVal","pDef","diff","glob_1","stateDecl","isStateClass","__stateObjectCache","nameGlob","ref","matchingKeys","criterion","matchGlobs","_state","globStrings","toMatch","registry","hookRegistrationFn","matchObject","RegisteredHook","tranSvc","matchCriteria","priority","_matchingNodes","nodes","_getDefaultMatchCriteria","_getPathTypes","_getMatchingNodes","mn","pathtype","isStateHook","scope","STATE","every","coreResolvables_1","redirectTo_1","resolve_1","updateGlobals_1","url_1","lazyLoad_1","transitionEventType_1","ignoredTransition_1","invalidTransition_1","defaultTransOpts","notify","custom","TransitionService","_router","_eventTypes","_criteriaPaths","_deregisterHookFns","_defineCorePaths","_defineCoreEvents","_registerCoreTransitionHooks","onCreate","hooksArray","Phase","TH","paths","_defineEvent","_definePathType","hookOrder","criteriaMatchPath","reverseSort","TransitionEventType","sort","cmpByPhase","hookScope","fns","addCoreResolves","registerAddCoreResolvables","registerIgnoredTransitionHook","registerInvalidTransitionHook","redirectTo","registerRedirectToHook","registerOnExitHook","registerOnRetainHook","registerOnEnterHook","eagerResolve","registerEagerResolvePath","lazyResolve","registerLazyResolveState","loadViews","registerLoadEnteringViews","activateViews","registerActivateViews","updateGlobals","registerUpdateGlobalState","updateUrl","registerUpdateUrl","lazyLoad","registerLazyLoadHook","func","definition","register","onInvalid","core_2","_urlRouter","urlRouter","update","interceptDeferred","listen","rule","ruleFn","BaseUrlRule","otherwise","what","handler","injectableHandler","$match","$stateParams","deferIntercept","stateParams_1","queue_1","UIRouterGlobals","StateParams","successfulTransitions","lazyLoadState","updateStateRegistry","lazyLoadFn","lazyLoadHook","retryTransition","orig","$url","urlService","parts","sync","ParamTypes","typeQueue","defaultTypes","makeType","types","definitionFn","_flushTypeQueue","makeDefaultType","valToString","defaultTypeBase","String","query","int","bool","Boolean","date","getFullYear","getMonth","getDate","capture","Date","valueOf","json","$inherit","newParams","$current","parentParams","parents","inherited","inheritList","WAIT","NOWAIT","RXWAIT","urlMatcherFactory_1","urlRouter_1","transitionService_1","view_1","stateRegistry_1","stateService_1","globals_1","urlService_1","_routerInstance","UrlService","locationServiceStub","locationConfigStub","_disposables","UrlMatcherFactory","UrlRouter","StateRegistry","StateService","_plugins","_rootViewContext","disposable","plugin","pluginInstance","getPlugin","pluginName","nameBuilder","selfBuilder","dataBuilder","pathBuilder","includesBuilder","resolvablesBuilder","strictDi","isResolveLiteral","isLikeNg2Provider","provide","useValue","useFactory","useExisting","useClass","isTupleFromObj","literal2Resolvable","dependencies","tuple2Resolvable","item2Resolvable","decl","resolveObj","charAt","getUrlBuilder","$urlMatcherFactoryProvider","stateDec","parsed","compile","paramConfig","reloadOnSearch","isMatcher","navigable","getNavigableBuilder","getParamsBuilder","makeConfigParam","urlParams","nonUrlParams","StateBuilder","parentBuilder","parentName","builders","builder","build","parentFn","pop","StateMatcher","_states","isRelative","stateOrName","matchGlob","isStr","baseState","splitName","pathLength","relName","StateQueueManager","$registry","listeners","queue","flush","registered","orphans","previousQueueLength","getState","name_1","orphanIdx","existingState","existingFutureState","deregister","attachRoute","listener","urlRuleFactory","stateMatcher_1","stateBuilder_1","stateQueueManager_1","stateQueue","_registerRoot","rootStateDef","#","_root","onStatesChanged","stateDefinition","_deregisterTree","getChildren","children","deregistered","$ur","rules","removeRule","deregisteredStates","found","invalidCallbacks","_defaultErrorHandler","$error$","stack","getters","boundFns","_handleInvalidTargetState","toState","invokeNextCallback","nextCallback","callbackQueue","fromState","checkForRedirect","latestThing","latest","transitionTo","go","defautGoOpts","transOpts","reg","getCurrentPath","latestSuccess","getCurrent","currentPath","rejectedTransitionHandler","isLatest","transitionToPromise","include","href","defaultHrefOpts","lossy","absolute","nav","tupleSort","reverseDepthSort","factor","depthDelta","buildHooks","hookType","matchingHooks","getMatchingHooks","baseHookOptions","makeTransitionHooks","transitionHook","isCreate","$transitions","urlMatcher_1","paramTypes_1","_isCaseInsensitive","_isStrictMode","_defaultSquashPolicy","_getConfig","strictMode","appendBasePath","baseHref","getHandlerFn","defaultRuleSortFn","urlRule_1","getMatcher","URLMATCHER","REGEXP","RAW","OTHER","_sortFn","_rules","_id","_sorted","UrlRuleFactory","_otherwiseFn","compareFn","ensureSorted","best","weight","matchPriority","defaultPrevented","newurl","_stopFn","read","urlMatcher","html5Mode","hashPrefix","slash","port","protocol","host","isUrlRule","handlerFn","initial","matchFn","urlParts","makeRule","_what","fromUrlMatcher","fromRegExp","optional","_handler","details","global","sticky","redirectUrlTo","Number","makeStub","locationServicesFns","locationConfigFns","umfFns","rulesFns","syncFns","lateBind","locationServices","umf","BrowserLocationConfig","_isHtml5","_baseHref","_hashPrefix","newprefix","applyDocumentBaseHref","baseTags","document","getElementsByTagName","origin","__extends","extendStatics","setPrototypeOf","__proto__","__","baseLocationService_1","HashLocationService","_super","addEventListener","title","removeEventListener","STRIP_COMMENTS","ARGUMENT_NAMES","has","locals","ensureExist","MemoryLocationConfig","_port","_protocol","_host","newval","MemoryLocationService","_url","PushStateLocationService","_config","fullUrl","replaceState","pushState","Promise","deferred","_uiViews","_viewConfigs","_viewConfigFactories","_registeredUIViews","_activeViewConfigs","_rootContext","viewType","cfgFactory","cfgs","deactivateViewConfig","activateViewConfig","uiViewDepth","stateDepth","viewConfigDepth","count","uiViewsByFqn","uiv","depthCompare","depthFn","posNeg","matchingConfigPair","matchingConfigs","configureUIView","configUpdated","registerUIView","uiViews","fqnMatches","available","active","rawViewName","viewAtContext","relativeViewNameSugar","anchor","vc","vcSegments","uivSegments","negOffset","fqnToFirstSegment","uiViewContext","default","core","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","props","descriptor","writable","protoProps","staticProps","RouterHelperProvider","_len","injects","_key","defaultRoute","docTitle","resolveAlways","configure","logger","_handleRoutingErrors","$on","fromParams","handlingStateChangeError","stateCounts","errors","destination","loadedTemplateUrl","msg","_updateDocTitle","configureStates","otherwisePath","$stateProvider","hasOtherwise","$urlRouterProvider","getStates","parseStateRef","paramsOnly","paramExpr","el","$uiView","inheritedData","processedDef","$element","uiState","uiStateOpts","defaultOpts","uiStateParams","getTypeInfo","isSvg","isForm","nodeName","attr","isAnchor","clickable","clickHook","$timeout","getDef","button","which","ctrlKey","metaKey","shiftKey","preventDefault","ignorePreventDefaultCount","cancel","bindEvents","element","hookFn","events","on","events_1","event_1","off","events_2","event_2","uiSref","restrict","link","attrs","uiSrefActive","unlinkInfoFn","$$addStateInfo","$set","rawDef","uiSrefOpts","$eval","inputAttrs","watchDeregFns","field","$observe","expr","$interpolate","$scope","$attrs","updateAfterTransition","addState","stateParams","activeClass","stateInfo","splitClasses","getClasses","stateList","allClasses","activeEqClass","fuzzyClasses","exactlyMatchesAny","exactClasses","addClasses","removeClasses","cls","$evalAsync","className","addClass","removeClass","uiSrefActiveEq","newState","directive","$ViewDirectiveFill","$compile","$controller","getControllerAs","getResolveAs","tElement","empty","contents","$cfg","angular_2","resolveCtx","controllerAs","services_1","controllerInstance","registerControllerCallbacks","cmp_1","kebobName","tagRegexp_1","getComponentController","directiveEl","tagName","deregisterWatch_1","ctrlInstance","$onInit","hasComponentImpl","viewState","hookOptions","uiOnParamsChanged","viewCreationTrans_1","paramsUpdated","$transition$","toSchema","fromSchema","changedToParams","changedKeys_1","newValues","uiCanExit","id_1","_uiCanExitId","prevTruthyAnswer_1","wrappedHook","ids","$animate","$uiViewScroll","getRenderer","enter","version","minor","leave","configsEqual","config1","config2","rootData","terminal","transclude","tAttrs","$transclude","configUpdatedCallback","activeUIView","updateView","cleanupLastView","previousEl","currentScope","$destroy","currentEl","_viewData_1","renderer","$$animLeave","newScope","$new","animEnter","animLeave","$uiViewData","$uiViewAnim","$animEnter","$animLeave","$emit","autoScrollExp","onloadExp","unregister","fromParentTagConfig","fromParentTag","_urlListeners","_lp","newUrl","_loc","_browser","pathType","~","/","~~","~2F","$IsStateFilter","isFilter","$stateful","$IncludedByStateFilter","includesFilter","decoratedNg1Hook","$state$","getComponentBindings","cmpDefs","getBindings","_useHttp","$templateRequest","useHttpService","asTemplate","asComponent","templateUrl","fromUrl","templateProvider","fromProvider","componentProvider","fromComponentProvider","headers","Accept","response","prefix","kebob","kebobed","attributeTpl","attrName","resolveName","scopeBindings","bindToController","bindingsObj","$ViewScrollProvider","useAnchorScroll","$anchorScroll","scrollIntoView","addCoreResolvables","router_1","ignoredHook","ignoredReason","invalidTransitionHook","makeEnterExitRetainHook","onExitHook","onRetainHook","onEnterHook","redirectToHook","eagerResolvePath","lazyResolveState","updateGlobalState","transitionSuccessful","clearCurrentTransition","urlOptions","loadEnteringViews","enteringViews","exitingViews","UIRouterPluginBase","servicesPlugin","injector_1","q_1","browserLocationConfig_1","hashLocationService_1","pushStateLocationService_1","memoryLocationService_1","memoryLocationConfig_1","hashLocationPlugin","pushStateLocationPlugin","memoryLocationPlugin","_interopRequireDefault","sjRouter","_angular","_angular2","_angularjs","_angularjs2","_sanjiLoggerUi","_routerHelper","_routerHelper2","sjLogger"],"mappings":"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","file":"sanji-router-ui.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"sanji-logger-ui\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"sanji-logger-ui\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sjRouter\"] = factory(require(\"angular\"), require(\"sanji-logger-ui\"));\n\telse\n\t\troot[\"sjRouter\"] = factory(root[\"angular\"], root[\"sjLogger\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_22__, __WEBPACK_EXTERNAL_MODULE_60__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"sanji-logger-ui\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"sanji-logger-ui\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sjRouter\"] = factory(require(\"angular\"), require(\"sanji-logger-ui\"));\n\telse\n\t\troot[\"sjRouter\"] = factory(root[\"angular\"], root[\"sjLogger\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_22__, __WEBPACK_EXTERNAL_MODULE_60__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 89);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Random utility functions used in the UI-Router code\n *\n * These functions are exported, but are subject to change without notice.\n *\n * @preferred\n * @module common\n */\n/** for typedoc */\nvar predicates_1 = __webpack_require__(1);\nvar hof_1 = __webpack_require__(2);\nvar coreservices_1 = __webpack_require__(3);\nvar w = typeof window === 'undefined' ? {} : window;\nvar angular = w.angular || {};\nexports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\nexports.toJson = angular.toJson || JSON.stringify.bind(JSON);\nexports.copy = angular.copy || _copy;\nexports.forEach = angular.forEach || _forEach;\nexports.extend = Object.assign || _extend;\nexports.equals = angular.equals || _equals;\nfunction identity(x) { return x; }\nexports.identity = identity;\nfunction noop() { }\nexports.noop = noop;\n/**\n * Builds proxy functions on the `to` object which pass through to the `from` object.\n *\n * For each key in `fnNames`, creates a proxy function on the `to` object.\n * The proxy function calls the real function on the `from` object.\n *\n *\n * #### Example:\n * This example creates an new class instance whose functions are prebound to the new'd object.\n * ```js\n * class Foo {\n *   constructor(data) {\n *     // Binds all functions from Foo.prototype to 'this',\n *     // then copies them to 'this'\n *     bindFunctions(Foo.prototype, this, this);\n *     this.data = data;\n *   }\n *\n *   log() {\n *     console.log(this.data);\n *   }\n * }\n *\n * let myFoo = new Foo([1,2,3]);\n * var logit = myFoo.log;\n * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n * ```\n *\n * #### Example:\n * This example creates a bound version of a service function, and copies it to another object\n * ```\n *\n * var SomeService = {\n *   this.data = [3, 4, 5];\n *   this.log = function() {\n *     console.log(this.data);\n *   }\n * }\n *\n * // Constructor fn\n * function OtherThing() {\n *   // Binds all functions from SomeService to SomeService,\n *   // then copies them to 'this'\n *   bindFunctions(SomeService, this, SomeService);\n * }\n *\n * let myOtherThing = new OtherThing();\n * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n * ```\n *\n * @param source A function that returns the source object which contains the original functions to be bound\n * @param target A function that returns the target object which will receive the bound functions\n * @param bind A function that returns the object which the functions will be bound to\n * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n */\nfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n    if (latebind === void 0) { latebind = false; }\n    var bindFunction = function (fnName) {\n        return source()[fnName].bind(bind());\n    };\n    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n        target[fnName] = bindFunction(fnName);\n        return target[fnName].apply(null, arguments);\n    }; };\n    fnNames = fnNames || Object.keys(source());\n    return fnNames.reduce(function (acc, name) {\n        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n        return acc;\n    }, target);\n}\nexports.createProxyFunctions = createProxyFunctions;\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n */\nexports.inherit = function (parent, extra) {\n    return exports.extend(Object.create(parent), extra);\n};\n/**\n * Given an arguments object, converts the arguments at index idx and above to an array.\n * This is similar to es6 rest parameters.\n *\n * Optionally, the argument at index idx may itself already be an array.\n *\n * For example,\n * given either:\n *        arguments = [ obj, \"foo\", \"bar\" ]\n * or:\n *        arguments = [ obj, [\"foo\", \"bar\"] ]\n * then:\n *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n *\n * This allows functions like pick() to be implemented such that it allows either a bunch\n * of string arguments (like es6 rest parameters), or a single array of strings:\n *\n * given:\n *        var obj = { foo: 1, bar: 2, baz: 3 };\n * then:\n *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n */\nvar restArgs = function (args, idx) {\n    if (idx === void 0) { idx = 0; }\n    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n};\n/** Given an array, returns true if the object is found in the array, (using indexOf) */\nexports.inArray = hof_1.curry(_inArray);\nfunction _inArray(array, obj) {\n    return array.indexOf(obj) !== -1;\n}\nexports._inArray = _inArray;\n/**\n * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n * The same array is returned\n */\nexports.removeFrom = hof_1.curry(_removeFrom);\nfunction _removeFrom(array, obj) {\n    var idx = array.indexOf(obj);\n    if (idx >= 0)\n        array.splice(idx, 1);\n    return array;\n}\nexports._removeFrom = _removeFrom;\n/** pushes a values to an array and returns the value */\nexports.pushTo = hof_1.curry(_pushTo);\nfunction _pushTo(arr, val) {\n    return (arr.push(val), val);\n}\nexports._pushTo = _pushTo;\n/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\nexports.deregAll = function (functions) {\n    return functions.slice().forEach(function (fn) {\n        typeof fn === 'function' && fn();\n        exports.removeFrom(functions, fn);\n    });\n};\n/**\n * Applies a set of defaults to an options object.  The options object is filtered\n * to only those properties of the objects in the defaultsList.\n * Earlier objects in the defaultsList take precedence when applying defaults.\n */\nfunction defaults(opts) {\n    var defaultsList = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defaultsList[_i - 1] = arguments[_i];\n    }\n    var _defaultsList = defaultsList.concat({}).reverse();\n    var defaultVals = exports.extend.apply(null, _defaultsList);\n    return exports.extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));\n}\nexports.defaults = defaults;\n/** Reduce function that merges each element of the list into a single object, using extend */\nexports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n    var path = [];\n    for (var n in first.path) {\n        if (first.path[n] !== second.path[n])\n            break;\n        path.push(first.path[n]);\n    }\n    return path;\n}\nexports.ancestors = ancestors;\n/**\n * Return a copy of the object only containing the whitelisted properties.\n *\n * #### Example:\n * ```\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the whitelisted property names\n */\nfunction pick(obj, propNames) {\n    var objCopy = {};\n    for (var prop_1 in obj) {\n        if (propNames.indexOf(prop_1) !== -1) {\n            objCopy[prop_1] = obj[prop_1];\n        }\n    }\n    return objCopy;\n}\nexports.pick = pick;\n/**\n * Return a copy of the object omitting the blacklisted properties.\n *\n * @example\n * ```\n *\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = omit(foo, ['a', 'b']); // { c: 3 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the blacklisted property names\n */\nfunction omit(obj, propNames) {\n    return Object.keys(obj)\n        .filter(hof_1.not(exports.inArray(propNames)))\n        .reduce(function (acc, key) { return (acc[key] = obj[key], acc); }, {});\n}\nexports.omit = omit;\n/**\n * Maps an array, or object to a property (by name)\n */\nfunction pluck(collection, propName) {\n    return map(collection, hof_1.prop(propName));\n}\nexports.pluck = pluck;\n/** Filters an Array or an Object's properties based on a predicate */\nfunction filter(collection, callback) {\n    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n    exports.forEach(collection, function (item, i) {\n        if (callback(item, i))\n            accept(item, i);\n    });\n    return result;\n}\nexports.filter = filter;\n/** Finds an object from an array, or a property of an object, that matches a predicate */\nfunction find(collection, callback) {\n    var result;\n    exports.forEach(collection, function (item, i) {\n        if (result)\n            return;\n        if (callback(item, i))\n            result = item;\n    });\n    return result;\n}\nexports.find = find;\n/** Given an object, returns a new object, where each property is transformed by the callback function */\nexports.mapObj = map;\n/** Maps an array or object properties using a callback function */\nfunction map(collection, callback) {\n    var result = predicates_1.isArray(collection) ? [] : {};\n    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n    return result;\n}\nexports.map = map;\n/**\n * Given an object, return its enumerable property values\n *\n * @example\n * ```\n *\n * let foo = { a: 1, b: 2, c: 3 }\n * let vals = values(foo); // [ 1, 2, 3 ]\n * ```\n */\nexports.values = function (obj) {\n    return Object.keys(obj).map(function (key) { return obj[key]; });\n};\n/**\n * Reduce function that returns true if all of the values are truthy.\n *\n * @example\n * ```\n *\n * let vals = [ 1, true, {}, \"hello world\"];\n * vals.reduce(allTrueR, true); // true\n *\n * vals.push(0);\n * vals.reduce(allTrueR, true); // false\n * ```\n */\nexports.allTrueR = function (memo, elem) { return memo && elem; };\n/**\n * Reduce function that returns true if any of the values are truthy.\n *\n *  * @example\n * ```\n *\n * let vals = [ 0, null, undefined ];\n * vals.reduce(anyTrueR, true); // false\n *\n * vals.push(\"hello world\");\n * vals.reduce(anyTrueR, true); // true\n * ```\n */\nexports.anyTrueR = function (memo, elem) { return memo || elem; };\n/**\n * Reduce function which un-nests a single level of arrays\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnestR = function (memo, elem) { return memo.concat(elem); };\n/**\n * Reduce function which recursively un-nests all arrays\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flattenR = function (memo, elem) {\n    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n};\n/**\n * Reduce function that pushes an object to an array, then returns the array.\n * Mostly just for [[flattenR]] and [[uniqR]]\n */\nfunction pushR(arr, obj) {\n    arr.push(obj);\n    return arr;\n}\nexports.pushR = pushR;\n/** Reduce function that filters out duplicates */\nexports.uniqR = function (acc, token) {\n    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n};\n/**\n * Return a new array with a single level of arrays unnested.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n/**\n * Return a completely flattened version of an array.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n/**\n * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n * @example\n * ```\n *\n * let isNumber = (obj) => typeof(obj) === 'number';\n * let allNumbers = [ 1, 2, 3, 4, 5 ];\n * allNumbers.filter(assertPredicate(isNumber)); //OK\n *\n * let oneString = [ 1, 2, 3, 4, \"5\" ];\n * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n * ```\n */\nexports.assertPredicate = assertFn;\n/**\n * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n * @example\n * ```\n *\n * var data = { foo: 1, bar: 2 };\n *\n * let keys = [ 'foo', 'bar' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // values is [1, 2]\n *\n * let keys = [ 'foo', 'bar', 'baz' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // throws Error(\"Key not found\")\n * ```\n */\nexports.assertMap = assertFn;\nfunction assertFn(predicateOrMap, errMsg) {\n    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n    return function (obj) {\n        var result = predicateOrMap(obj);\n        if (!result) {\n            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n        }\n        return result;\n    };\n}\nexports.assertFn = assertFn;\n/**\n * Like _.pairs: Given an object, returns an array of key/value pairs\n *\n * @example\n * ```\n *\n * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n * ```\n */\nexports.pairs = function (obj) {\n    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n};\n/**\n * Given two or more parallel arrays, returns an array of tuples where\n * each tuple is composed of [ a[i], b[i], ... z[i] ]\n *\n * @example\n * ```\n *\n * let foo = [ 0, 2, 4, 6 ];\n * let bar = [ 1, 3, 5, 7 ];\n * let baz = [ 10, 30, 50, 70 ];\n * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n * ```\n */\nfunction arrayTuples() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 0)\n        return [];\n    var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53 − 1 aka Number.MAX_SAFE_INTEGER\n    var i, result = [];\n    for (i = 0; i < maxArrayLen; i++) {\n        // This is a hot function\n        // Unroll when there are 1-4 arguments\n        switch (args.length) {\n            case 1:\n                result.push([args[0][i]]);\n                break;\n            case 2:\n                result.push([args[0][i], args[1][i]]);\n                break;\n            case 3:\n                result.push([args[0][i], args[1][i], args[2][i]]);\n                break;\n            case 4:\n                result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);\n                break;\n            default:\n                result.push(args.map(function (array) { return array[i]; }));\n                break;\n        }\n    }\n    return result;\n}\nexports.arrayTuples = arrayTuples;\n/**\n * Reduce function which builds an object from an array of [key, value] pairs.\n *\n * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n *\n * Each keyValueTuple should be an array with values [ key: string, value: any ]\n *\n * @example\n * ```\n *\n * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n *\n * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n *\n * // Or, more simply:\n * var pairsToObj = pairs.reduce(applyPairs, {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n * ```\n */\nfunction applyPairs(memo, keyValTuple) {\n    var key, value;\n    if (predicates_1.isArray(keyValTuple))\n        key = keyValTuple[0], value = keyValTuple[1];\n    if (!predicates_1.isString(key))\n        throw new Error(\"invalid parameters to applyPairs\");\n    memo[key] = value;\n    return memo;\n}\nexports.applyPairs = applyPairs;\n/** Get the last element of an array */\nfunction tail(arr) {\n    return arr.length && arr[arr.length - 1] || undefined;\n}\nexports.tail = tail;\n/**\n * shallow copy from src to dest\n *\n * note: This is a shallow copy, while angular.copy is a deep copy.\n * ui-router uses `copy` only to make copies of state parameters.\n */\nfunction _copy(src, dest) {\n    if (dest)\n        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n    if (!dest)\n        dest = {};\n    return exports.extend(dest, src);\n}\n/** Naive forEach implementation works with Objects or Arrays */\nfunction _forEach(obj, cb, _this) {\n    if (predicates_1.isArray(obj))\n        return obj.forEach(cb, _this);\n    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n}\nfunction _extend(toObj) {\n    for (var i = 1; i < arguments.length; i++) {\n        var obj = arguments[i];\n        if (!obj)\n            continue;\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; j++) {\n            toObj[keys[j]] = obj[keys[j]];\n        }\n    }\n    return toObj;\n}\nexports._extend = _extend;\nfunction _equals(o1, o2) {\n    if (o1 === o2)\n        return true;\n    if (o1 === null || o2 === null)\n        return false;\n    if (o1 !== o1 && o2 !== o2)\n        return true; // NaN === NaN\n    var t1 = typeof o1, t2 = typeof o2;\n    if (t1 !== t2 || t1 !== 'object')\n        return false;\n    var tup = [o1, o2];\n    if (hof_1.all(predicates_1.isArray)(tup))\n        return _arraysEq(o1, o2);\n    if (hof_1.all(predicates_1.isDate)(tup))\n        return o1.getTime() === o2.getTime();\n    if (hof_1.all(predicates_1.isRegExp)(tup))\n        return o1.toString() === o2.toString();\n    if (hof_1.all(predicates_1.isFunction)(tup))\n        return true; // meh\n    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n        return false;\n    var key, keys = {};\n    for (key in o1) {\n        if (!_equals(o1[key], o2[key]))\n            return false;\n        keys[key] = true;\n    }\n    for (key in o2) {\n        if (!keys[key])\n            return false;\n    }\n    return true;\n}\nfunction _arraysEq(a1, a2) {\n    if (a1.length !== a2.length)\n        return false;\n    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n}\n/**\n * Create a sort function\n *\n * Creates a sort function which sorts by a numeric property.\n *\n * The `propFn` should return the property as a number which can be sorted.\n *\n * #### Example:\n * This example returns the `priority` prop.\n * ```js\n * var sortfn = sortBy(obj => obj.priority)\n * // equivalent to:\n * var longhandSortFn = (a, b) => a.priority - b.priority;\n * ```\n *\n * #### Example:\n * This example uses [[prop]]\n * ```js\n * var sortfn = sortBy(prop('priority'))\n * ```\n *\n * The `checkFn` can be used to exclude objects from sorting.\n *\n * #### Example:\n * This example only sorts objects with type === 'FOO'\n * ```js\n * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))\n * ```\n *\n * @param propFn a function that returns the property (as a number)\n * @param checkFn a predicate\n *\n * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`\n */\nexports.sortBy = function (propFn, checkFn) {\n    if (checkFn === void 0) { checkFn = hof_1.val(true); }\n    return function (a, b) {\n        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;\n    };\n};\n/**\n * Composes a list of sort functions\n *\n * Creates a sort function composed of multiple sort functions.\n * Each sort function is invoked in series.\n * The first sort function to return non-zero \"wins\".\n *\n * @param sortFns list of sort functions\n */\nexports.composeSort = function () {\n    var sortFns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sortFns[_i] = arguments[_i];\n    }\n    return function composedSort(a, b) {\n        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);\n    };\n};\n// issue #2676\nexports.silenceUncaughtInPromise = function (promise) {\n    return promise.catch(function (e) { return 0; }) && promise;\n};\nexports.silentRejection = function (error) {\n    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n};\n//# sourceMappingURL=common.js.map\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_predicates\n */\n/** */\nvar hof_1 = __webpack_require__(2);\nvar stateObject_1 = __webpack_require__(28);\nvar toStr = Object.prototype.toString;\nvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\nexports.isUndefined = tis('undefined');\nexports.isDefined = hof_1.not(exports.isUndefined);\nexports.isNull = function (o) { return o === null; };\nexports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\nexports.isFunction = tis('function');\nexports.isNumber = tis('number');\nexports.isString = tis('string');\nexports.isObject = function (x) { return x !== null && typeof x === 'object'; };\nexports.isArray = Array.isArray;\nexports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\nexports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\nexports.isState = stateObject_1.StateObject.isState;\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\nfunction isInjectable(val) {\n    if (exports.isArray(val) && val.length) {\n        var head = val.slice(0, -1), tail = val.slice(-1);\n        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n    }\n    return exports.isFunction(val);\n}\nexports.isInjectable = isInjectable;\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\nexports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n//# sourceMappingURL=predicates.js.map\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Higher order functions\n *\n * These utility functions are exported, but are subject to change without notice.\n *\n * @module common_hof\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n *\n * Given a function with N parameters, returns a new function that supports partial application.\n * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n * accept more parameters until all N parameters have been supplied.\n *\n *\n * This contrived example uses a partially applied function as an predicate, which returns true\n * if an object is found in both arrays.\n * @example\n * ```\n * // returns true if an object is in both of the two arrays\n * function inBoth(array1, array2, object) {\n *   return array1.indexOf(object) !== -1 &&\n *          array2.indexOf(object) !== 1;\n * }\n * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n * let foos = [obj1, obj3]\n * let bars = [obj3, obj4, obj5]\n *\n * // A curried \"copy\" of inBoth\n * let curriedInBoth = curry(inBoth);\n * // Partially apply both the array1 and array2\n * let inFoosAndBars = curriedInBoth(foos, bars);\n *\n * // Supply the final argument; since all arguments are\n * // supplied, the original inBoth function is then called.\n * let obj1InBoth = inFoosAndBars(obj1); // false\n *\n * // Use the inFoosAndBars as a predicate.\n * // Filter, on each iteration, supplies the final argument\n * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n *\n * ```\n *\n * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n *\n * @param fn\n * @returns {*|function(): (*|any)}\n */\nfunction curry(fn) {\n    var initial_args = [].slice.apply(arguments, [1]);\n    var func_args_length = fn.length;\n    function curried(args) {\n        if (args.length >= func_args_length)\n            return fn.apply(null, args);\n        return function () {\n            return curried(args.concat([].slice.apply(arguments)));\n        };\n    }\n    return curried(initial_args);\n}\nexports.curry = curry;\n/**\n * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n * given: f(x), g(x), h(x)\n * let composed = compose(f,g,h)\n * then, composed is: f(g(h(x)))\n */\nfunction compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n        var i = start, result = args[start].apply(this, arguments);\n        while (i--)\n            result = args[i].call(this, result);\n        return result;\n    };\n}\nexports.compose = compose;\n/**\n * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n * given: f(x), g(x), h(x)\n * let piped = pipe(f,g,h);\n * then, piped is: h(g(f(x)))\n */\nfunction pipe() {\n    var funcs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        funcs[_i] = arguments[_i];\n    }\n    return compose.apply(null, [].slice.call(arguments).reverse());\n}\nexports.pipe = pipe;\n/**\n * Given a property name, returns a function that returns that property from an object\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = prop(\"name\");\n * getName(obj) === \"blarg\"\n */\nexports.prop = function (name) {\n    return function (obj) { return obj && obj[name]; };\n};\n/**\n * Given a property name and a value, returns a function that returns a boolean based on whether\n * the passed object has a property that matches the value\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = propEq(\"name\", \"blarg\");\n * getName(obj) === true\n */\nexports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n/**\n * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n * let getName = prop(\"nestedObj.name\");\n * getName(obj) === \"blarg\"\n * let propNotFound = prop(\"this.property.doesnt.exist\");\n * propNotFound(obj) === undefined\n */\nexports.parse = function (name) {\n    return pipe.apply(null, name.split(\".\").map(exports.prop));\n};\n/**\n * Given a function that returns a truthy or falsey value, returns a\n * function that returns the opposite (falsey or truthy) value given the same inputs\n */\nexports.not = function (fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return !fn.apply(null, args);\n    };\n};\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if both functions return truthy for the given arguments\n */\nfunction and(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) && fn2.apply(null, args);\n    };\n}\nexports.and = and;\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if at least one of the functions returns truthy for the given arguments\n */\nfunction or(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) || fn2.apply(null, args);\n    };\n}\nexports.or = or;\n/**\n * Check if all the elements of an array match a predicate function\n *\n * @param fn1 a predicate function `fn1`\n * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n */\nexports.all = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n};\nexports.any = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n};\n/** Given a class, returns a Predicate function that returns true if the object is of that class */\nexports.is = function (ctor) {\n    return function (obj) {\n        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n    };\n};\n/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\nexports.eq = function (val) { return function (other) {\n    return val === other;\n}; };\n/** Given a value, returns a function which returns the value */\nexports.val = function (v) { return function () { return v; }; };\nfunction invoke(fnName, args) {\n    return function (obj) {\n        return obj[fnName].apply(obj, args);\n    };\n}\nexports.invoke = invoke;\n/**\n * Sorta like Pattern Matching (a functional programming conditional construct)\n *\n * See http://c2.com/cgi/wiki?PatternMatching\n *\n * This is a conditional construct which allows a series of predicates and output functions\n * to be checked and then applied.  Each predicate receives the input.  If the predicate\n * returns truthy, then its matching output function (mapping function) is provided with\n * the input and, then the result is returned.\n *\n * Each combination (2-tuple) of predicate + output function should be placed in an array\n * of size 2: [ predicate, mapFn ]\n *\n * These 2-tuples should be put in an outer array.\n *\n * @example\n * ```\n *\n * // Here's a 2-tuple where the first element is the isString predicate\n * // and the second element is a function that returns a description of the input\n * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n *\n * // Second tuple: predicate \"isNumber\", mapfn returns a description\n * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n *\n * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n *\n * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n *\n * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n *\n * console.log(descriptionOf(undefined)); // 'notdefined'\n * console.log(descriptionOf(55)); // '(55) That's a number!'\n * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n * ```\n *\n * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n * with a Predicate and a mapping/output function\n * @returns {function(any): *}\n */\nfunction pattern(struct) {\n    return function (x) {\n        for (var i = 0; i < struct.length; i++) {\n            if (struct[i][0](x))\n                return struct[i][1](x);\n        }\n    };\n}\nexports.pattern = pattern;\n//# sourceMappingURL=hof.js.map\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.notImplemented = function (fnname) { return function () {\n    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n}; };\nvar services = {\n    $q: undefined,\n    $injector: undefined,\n};\nexports.services = services;\n//# sourceMappingURL=coreservices.js.map\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @coreapi\n * @module common\n */ /** */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(16));\n__export(__webpack_require__(79));\n__export(__webpack_require__(80));\n__export(__webpack_require__(81));\n__export(__webpack_require__(82));\n__export(__webpack_require__(83));\n__export(__webpack_require__(84));\n__export(__webpack_require__(88));\n__export(__webpack_require__(33));\n__export(__webpack_require__(38));\n__export(__webpack_require__(85));\n__export(__webpack_require__(78));\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Functions that manipulate strings\n *\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_strings\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar predicates_1 = __webpack_require__(1);\nvar rejectFactory_1 = __webpack_require__(12);\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar transition_1 = __webpack_require__(19);\nvar resolvable_1 = __webpack_require__(11);\n/**\n * Returns a string shortened to a maximum length\n *\n * If the string is already less than the `max` length, return the string.\n * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n *\n * @param max the maximum length of the string to return\n * @param str the input string\n */\nfunction maxLength(max, str) {\n    if (str.length <= max)\n        return str;\n    return str.substr(0, max - 3) + \"...\";\n}\nexports.maxLength = maxLength;\n/**\n * Returns a string, with spaces added to the end, up to a desired str length\n *\n * If the string is already longer than the desired length, return the string.\n * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n *\n * @param length the desired length of the string to return\n * @param str the input string\n */\nfunction padString(length, str) {\n    while (str.length < length)\n        str += \" \";\n    return str;\n}\nexports.padString = padString;\nfunction kebobString(camelCase) {\n    return camelCase\n        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n}\nexports.kebobString = kebobString;\nfunction _toJson(obj) {\n    return JSON.stringify(obj);\n}\nfunction _fromJson(json) {\n    return predicates_1.isString(json) ? JSON.parse(json) : json;\n}\nfunction promiseToString(p) {\n    return \"Promise(\" + JSON.stringify(p) + \")\";\n}\nfunction functionToString(fn) {\n    var fnStr = fnToString(fn);\n    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n    var fnName = fn['name'] || \"\";\n    if (fnName && toStr.match(/function \\(/)) {\n        return 'function ' + fnName + toStr.substr(9);\n    }\n    return toStr;\n}\nexports.functionToString = functionToString;\nfunction fnToString(fn) {\n    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n    return _fn && _fn.toString() || \"undefined\";\n}\nexports.fnToString = fnToString;\nvar stringifyPatternFn = null;\nvar stringifyPattern = function (value) {\n    var isRejection = rejectFactory_1.Rejection.isRejectionPromise;\n    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n        [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n        [predicates_1.isNull, hof_1.val(\"null\")],\n        [predicates_1.isPromise, hof_1.val(\"[Promise]\")],\n        [isRejection, function (x) { return x._transitionRejection.toString(); }],\n        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n        [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n        [predicates_1.isInjectable, functionToString],\n        [hof_1.val(true), common_1.identity]\n    ]);\n    return stringifyPatternFn(value);\n};\nfunction stringify(o) {\n    var seen = [];\n    function format(val) {\n        if (predicates_1.isObject(val)) {\n            if (seen.indexOf(val) !== -1)\n                return '[circular ref]';\n            seen.push(val);\n        }\n        return stringifyPattern(val);\n    }\n    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n}\nexports.stringify = stringify;\n/** Returns a function that splits a string on a character or substring */\nexports.beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\n/**\n * Splits on a delimiter, but returns the delimiters in the array\n *\n * #### Example:\n * ```js\n * var splitOnSlashes = splitOnDelim('/');\n * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n * ```\n */\nfunction splitOnDelim(delim) {\n    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n    return function (str) {\n        return str.split(re).filter(common_1.identity);\n    };\n}\nexports.splitOnDelim = splitOnDelim;\n;\n/**\n * Reduce fn that joins neighboring strings\n *\n * Given an array of strings, returns a new array\n * where all neighboring strings have been joined.\n *\n * #### Example:\n * ```js\n * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n * ```\n */\nfunction joinNeighborsR(acc, x) {\n    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n    return common_1.pushR(acc, x);\n}\nexports.joinNeighborsR = joinNeighborsR;\n;\n//# sourceMappingURL=strings.js.map\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Transition tracing (debug)\n *\n * Enable transition tracing to print transition information to the console,\n * in order to help debug your application.\n * Tracing logs detailed information about each Transition to your console.\n *\n * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n *\n * ### ES6\n * ```js\n * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n * ```\n *\n * ### CJS\n * ```js\n * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n * ```\n *\n * ### Globals\n * ```js\n * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n * trace.enable(); // Trace everything (very verbose)\n * ```\n *\n * ### Angular 1:\n * ```js\n * app.run($trace => $trace.enable());\n * ```\n *\n * @coreapi\n * @module trace\n */ /** for typedoc */\nvar hof_1 = __webpack_require__(2);\nvar predicates_1 = __webpack_require__(1);\nvar strings_1 = __webpack_require__(5);\n/** @hidden */\nfunction uiViewString(viewData) {\n    if (!viewData)\n        return 'ui-view (defunct)';\n    return \"[ui-view#\" + viewData.id + \" tag \" +\n        (\"in template from '\" + (viewData.creationContext && viewData.creationContext.name || '(root)') + \"' state]: \") +\n        (\"fqn: '\" + viewData.fqn + \"', \") +\n        (\"name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\");\n}\n/** @hidden */\nvar viewConfigString = function (viewConfig) {\n    return \"[ViewConfig#\" + viewConfig.$id + \" from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\";\n};\n/** @hidden */\nfunction normalizedCat(input) {\n    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n}\n/**\n * Trace categories Enum\n *\n * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n *\n * `trace.enable(Category.TRANSITION)`\n *\n * These can also be provided using a matching string, or position ordinal\n *\n * `trace.enable(\"TRANSITION\")`\n *\n * `trace.enable(1)`\n */\nvar Category;\n(function (Category) {\n    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n})(Category = exports.Category || (exports.Category = {}));\n/** @hidden */ var _tid = hof_1.parse(\"$id\");\n/** @hidden */ var _rid = hof_1.parse(\"router.$id\");\n/** @hidden */ var transLbl = function (trans) { return \"Transition #\" + _tid(trans) + \"-\" + _rid(trans); };\n/**\n * Prints UI-Router Transition trace information to the console.\n */\nvar Trace = (function () {\n    /** @hidden */\n    function Trace() {\n        /** @hidden */\n        this._enabled = {};\n        this.approximateDigests = 0;\n    }\n    /** @hidden */\n    Trace.prototype._set = function (enabled, categories) {\n        var _this = this;\n        if (!categories.length) {\n            categories = Object.keys(Category)\n                .map(function (k) { return parseInt(k, 10); })\n                .filter(function (k) { return !isNaN(k); })\n                .map(function (key) { return Category[key]; });\n        }\n        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n    };\n    /**\n     * Enables a trace [[Category]]\n     *\n     * ```js\n     * trace.enable(\"TRANSITION\");\n     * ```\n     *\n     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.enable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(true, categories);\n    };\n    /**\n     * Disables a trace [[Category]]\n     *\n     * ```js\n     * trace.disable(\"VIEWCONFIG\");\n     * ```\n     *\n     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.disable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(false, categories);\n    };\n    /**\n     * Retrieves the enabled stateus of a [[Category]]\n     *\n     * ```js\n     * trace.enabled(\"VIEWCONFIG\"); // true or false\n     * ```\n     *\n     * @returns boolean true if the category is enabled\n     */\n    Trace.prototype.enabled = function (category) {\n        return !!this._enabled[normalizedCat(category)];\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionStart = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": Started  -> \" + strings_1.stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionIgnored = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": Ignored  <> \" + strings_1.stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.registeredHook.callback);\n        console.log(transLbl(trans) + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        console.log(transLbl(trans) + \":   <- Hook returned: \" + strings_1.maxLength(200, strings_1.stringify(hookResult)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvePath = function (path, when, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + \":         Resolving \" + path + \" (\" + when + \")\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + \":               <- Resolved  \" + resolvable + \" to: \" + strings_1.maxLength(200, strings_1.stringify(resolvable.data)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceError = function (reason, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": <- Rejected \" + strings_1.stringify(trans) + \", reason: \" + reason);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceSuccess = function (finalState, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": <- Success  \" + strings_1.stringify(trans) + \", final state: \" + finalState.name);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n        if (extra === void 0) { extra = \"\"; }\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewFill = function (viewData, html) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n    };\n    return Trace;\n}());\nexports.Trace = Trace;\n/**\n * The [[Trace]] singleton\n *\n * #### Example:\n * ```js\n * import {trace} from \"angular-ui-router\";\n * trace.enable(1, 5);\n * ```\n */\nvar trace = new Trace();\nexports.trace = trace;\n//# sourceMappingURL=trace.js.map\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\n/**\n * Encapsulate the target (destination) state/params/options of a [[Transition]].\n *\n * This class is frequently used to redirect a transition to a new destination.\n *\n * See:\n *\n * - [[HookResult]]\n * - [[TransitionHookFn]]\n * - [[TransitionService.onStart]]\n *\n * To create a `TargetState`, use [[StateService.target]].\n *\n * ---\n *\n * This class wraps:\n *\n * 1) an identifier for a state\n * 2) a set of parameters\n * 3) and transition options\n * 4) the registered state object (the [[StateDeclaration]])\n *\n * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).\n * The `TargetState` class normalizes those options.\n *\n * A `TargetState` may be valid (the state being targeted exists in the registry)\n * or invalid (the state being targeted is not registered).\n */\nvar TargetState = (function () {\n    /**\n     * The TargetState constructor\n     *\n     * Note: Do not construct a `TargetState` manually.\n     * To create a `TargetState`, use the [[StateService.target]] factory method.\n     *\n     * @param _identifier An identifier for a state.\n     *    Either a fully-qualified state name, or the object used to define the state.\n     * @param _definition The internal state representation, if exists.\n     * @param _params Parameters for the target state\n     * @param _options Transition options.\n     *\n     * @internalapi\n     */\n    function TargetState(_identifier, _definition, _params, _options) {\n        if (_options === void 0) { _options = {}; }\n        this._identifier = _identifier;\n        this._definition = _definition;\n        this._options = _options;\n        this._params = _params || {};\n    }\n    /** The name of the state this object targets */\n    TargetState.prototype.name = function () {\n        return this._definition && this._definition.name || this._identifier;\n    };\n    /** The identifier used when creating this TargetState */\n    TargetState.prototype.identifier = function () {\n        return this._identifier;\n    };\n    /** The target parameter values */\n    TargetState.prototype.params = function () {\n        return this._params;\n    };\n    /** The internal state object (if it was found) */\n    TargetState.prototype.$state = function () {\n        return this._definition;\n    };\n    /** The internal state declaration (if it was found) */\n    TargetState.prototype.state = function () {\n        return this._definition && this._definition.self;\n    };\n    /** The target options */\n    TargetState.prototype.options = function () {\n        return this._options;\n    };\n    /** True if the target state was found */\n    TargetState.prototype.exists = function () {\n        return !!(this._definition && this._definition.self);\n    };\n    /** True if the object is valid */\n    TargetState.prototype.valid = function () {\n        return !this.error();\n    };\n    /** If the object is invalid, returns the reason why */\n    TargetState.prototype.error = function () {\n        var base = this.options().relative;\n        if (!this._definition && !!base) {\n            var stateName = base.name ? base.name : base;\n            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n        }\n        if (!this._definition)\n            return \"No such state '\" + this.name() + \"'\";\n        if (!this._definition.self)\n            return \"State '\" + this.name() + \"' has an invalid definition\";\n    };\n    TargetState.prototype.toString = function () {\n        return \"'\" + this.name() + \"'\" + common_1.toJson(this.params());\n    };\n    return TargetState;\n}());\n/** Returns true if the object has a state property that might be a state or state name */\nTargetState.isDef = function (obj) {\n    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n};\nexports.TargetState = TargetState;\n//# sourceMappingURL=targetState.js.map\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ng_from_import = __webpack_require__(22);\nvar ng_from_global = angular;\nexports.ng = (ng_from_import && ng_from_import.module) ? ng_from_import : ng_from_global;\n//# sourceMappingURL=angular.js.map\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar predicates_1 = __webpack_require__(1);\nvar coreservices_1 = __webpack_require__(3);\nvar paramType_1 = __webpack_require__(26);\n/** @hidden */ var hasOwn = Object.prototype.hasOwnProperty;\n/** @hidden */ var isShorthand = function (cfg) {\n    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n};\n/** @internalapi */\nvar DefType;\n(function (DefType) {\n    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n})(DefType = exports.DefType || (exports.DefType = {}));\n/** @hidden */\nfunction unwrapShorthand(cfg) {\n    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n    getStaticDefaultValue['__cacheable'] = true;\n    function getStaticDefaultValue() {\n        return cfg.value;\n    }\n    return common_1.extend(cfg, {\n        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,\n    });\n}\n/** @hidden */\nfunction getType(cfg, urlType, location, id, paramTypes) {\n    if (cfg.type && urlType && urlType.name !== 'string')\n        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n        return paramTypes.type(cfg.type);\n    if (urlType)\n        return urlType;\n    if (!cfg.type) {\n        var type = location === DefType.CONFIG ? \"any\" :\n            location === DefType.PATH ? \"path\" :\n                location === DefType.SEARCH ? \"query\" : \"string\";\n        return paramTypes.type(type);\n    }\n    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/**\n * @internalapi\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n    var squash = config.squash;\n    if (!isOptional || squash === false)\n        return false;\n    if (!predicates_1.isDefined(squash) || squash == null)\n        return defaultPolicy;\n    if (squash === true || predicates_1.isString(squash))\n        return squash;\n    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n}\n/** @internalapi */\nfunction getReplace(config, arrayMode, isOptional, squash) {\n    var replace, configuredKeys, defaultPolicy = [\n        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") },\n    ];\n    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n    if (predicates_1.isString(squash))\n        replace.push({ from: squash, to: undefined });\n    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n}\n/** @internalapi */\nvar Param = (function () {\n    function Param(id, type, config, location, urlMatcherFactory) {\n        config = unwrapShorthand(config);\n        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n        var arrayMode = getArrayMode();\n        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n        var replace = getReplace(config, arrayMode, isOptional, squash);\n        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n        function getArrayMode() {\n            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n        }\n        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config });\n    }\n    Param.prototype.isDefaultValue = function (value) {\n        return this.isOptional && this.type.equals(this.value(), value);\n    };\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    Param.prototype.value = function (value) {\n        var _this = this;\n        /**\n         * [Internal] Get the default value of a parameter, which may be an injectable function.\n         */\n        var getDefaultValue = function () {\n            if (_this._defaultValueCache)\n                return _this._defaultValueCache.defaultValue;\n            if (!coreservices_1.services.$injector)\n                throw new Error(\"Injectable functions cannot be called at configuration time\");\n            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n            if (_this.config.$$fn['__cacheable']) {\n                _this._defaultValueCache = { defaultValue: defaultValue };\n            }\n            return defaultValue;\n        };\n        var replaceSpecialValues = function (val) {\n            for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {\n                var tuple = _a[_i];\n                if (tuple.from === val)\n                    return tuple.to;\n            }\n            return val;\n        };\n        value = replaceSpecialValues(value);\n        return predicates_1.isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n    };\n    Param.prototype.isSearch = function () {\n        return this.location === DefType.SEARCH;\n    };\n    Param.prototype.validates = function (value) {\n        // There was no parameter value, but the param is optional\n        if ((predicates_1.isUndefined(value) || value === null) && this.isOptional)\n            return true;\n        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n        var normalized = this.type.$normalize(value);\n        if (!this.type.is(normalized))\n            return false;\n        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n        var encoded = this.type.encode(normalized);\n        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n    };\n    Param.prototype.toString = function () {\n        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n    };\n    Param.values = function (params, values) {\n        if (values === void 0) { values = {}; }\n        var paramValues = {};\n        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {\n            var param = params_1[_i];\n            paramValues[param.id] = param.value(values[param.id]);\n        }\n        return paramValues;\n    };\n    /**\n     * Finds [[Param]] objects which have different param values\n     *\n     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n     *\n     * @param params: The list of Param objects to filter\n     * @param values1: The first set of parameter values\n     * @param values2: the second set of parameter values\n     *\n     * @returns any Param objects whose values were different between values1 and values2\n     */\n    Param.changed = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n    };\n    /**\n     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n     *\n     * @param params The list of [[Param]] objects to check\n     * @param values1 The first set of param values\n     * @param values2 The second set of param values\n     *\n     * @returns true if the param values in values1 and values2 are equal\n     */\n    Param.equals = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return Param.changed(params, values1, values2).length === 0;\n    };\n    /** Returns true if a the parameter values are valid, according to the Param definitions */\n    Param.validates = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n    };\n    return Param;\n}());\nexports.Param = Param;\n//# sourceMappingURL=param.js.map\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TransitionHookPhase;\n(function (TransitionHookPhase) {\n    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n    TransitionHookPhase[TransitionHookPhase[\"RUN\"] = 2] = \"RUN\";\n    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\nvar TransitionHookScope;\n(function (TransitionHookScope) {\n    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n//# sourceMappingURL=interface.js.map\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module resolve\n */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar coreservices_1 = __webpack_require__(3);\nvar trace_1 = __webpack_require__(6);\nvar strings_1 = __webpack_require__(5);\nvar predicates_1 = __webpack_require__(1);\n// TODO: explicitly make this user configurable\nexports.defaultResolvePolicy = {\n    when: \"LAZY\",\n    async: \"WAIT\"\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nvar Resolvable = (function () {\n    function Resolvable(arg1, resolveFn, deps, policy, data) {\n        this.resolved = false;\n        this.promise = undefined;\n        if (arg1 instanceof Resolvable) {\n            common_1.extend(this, arg1);\n        }\n        else if (predicates_1.isFunction(resolveFn)) {\n            if (arg1 == null || arg1 == undefined)\n                throw new Error(\"new Resolvable(): token argument is required\");\n            if (!predicates_1.isFunction(resolveFn))\n                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n            this.token = arg1;\n            this.policy = policy;\n            this.resolveFn = resolveFn;\n            this.deps = deps || [];\n            this.data = data;\n            this.resolved = data !== undefined;\n            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n        }\n        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n            var literal = arg1;\n            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n        }\n    }\n    Resolvable.prototype.getPolicy = function (state) {\n        var thisPolicy = this.policy || {};\n        var statePolicy = state && state.resolvePolicy || {};\n        return {\n            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n        };\n    };\n    /**\n     * Asynchronously resolve this Resolvable's data\n     *\n     * Given a ResolveContext that this Resolvable is found in:\n     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n     * and update the Resolvable's state\n     */\n    Resolvable.prototype.resolve = function (resolveContext, trans) {\n        var _this = this;\n        var $q = coreservices_1.services.$q;\n        // Gets all dependencies from ResolveContext and wait for them to be resolved\n        var getResolvableDependencies = function () {\n            return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) {\n                return resolvable.get(resolveContext, trans);\n            }));\n        };\n        // Invokes the resolve function passing the resolved dependencies as arguments\n        var invokeResolveFn = function (resolvedDeps) {\n            return _this.resolveFn.apply(null, resolvedDeps);\n        };\n        /**\n         * For RXWAIT policy:\n         *\n         * Given an observable returned from a resolve function:\n         * - enables .cache() mode (this allows multicast subscribers)\n         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n         * - Waits for the promise, then return the cached observable (not the first emitted value).\n         */\n        var waitForRx = function (observable$) {\n            var cached = observable$.cache(1);\n            return cached.take(1).toPromise().then(function () { return cached; });\n        };\n        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n        var node = resolveContext.findNode(this);\n        var state = node && node.state;\n        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : common_1.identity;\n        // After the final value has been resolved, update the state of the Resolvable\n        var applyResolvedValue = function (resolvedValue) {\n            _this.data = resolvedValue;\n            _this.resolved = true;\n            trace_1.trace.traceResolvableResolved(_this, trans);\n            return _this.data;\n        };\n        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n        return this.promise = $q.when()\n            .then(getResolvableDependencies)\n            .then(invokeResolveFn)\n            .then(maybeWaitForRx)\n            .then(applyResolvedValue);\n    };\n    /**\n     * Gets a promise for this Resolvable's data.\n     *\n     * Fetches the data and returns a promise.\n     * Returns the existing promise if it has already been fetched once.\n     */\n    Resolvable.prototype.get = function (resolveContext, trans) {\n        return this.promise || this.resolve(resolveContext, trans);\n    };\n    Resolvable.prototype.toString = function () {\n        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n    };\n    Resolvable.prototype.clone = function () {\n        return new Resolvable(this);\n    };\n    return Resolvable;\n}());\nResolvable.fromData = function (token, data) {\n    return new Resolvable(token, function () { return data; }, null, null, data);\n};\nexports.Resolvable = Resolvable;\n//# sourceMappingURL=resolvable.js.map\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(0);\nvar strings_1 = __webpack_require__(5);\nvar hof_1 = __webpack_require__(2);\nvar RejectType;\n(function (RejectType) {\n    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n})(RejectType = exports.RejectType || (exports.RejectType = {}));\n/** @hidden */ var id = 0;\nvar Rejection = (function () {\n    function Rejection(type, message, detail) {\n        this.$id = id++;\n        this.type = type;\n        this.message = message;\n        this.detail = detail;\n    }\n    Rejection.prototype.toString = function () {\n        var detailString = function (d) {\n            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n        };\n        var detail = detailString(this.detail);\n        var _a = this, $id = _a.$id, type = _a.type, message = _a.message;\n        return \"Transition Rejection($id: \" + $id + \" type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n    };\n    Rejection.prototype.toPromise = function () {\n        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n    };\n    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n    Rejection.isRejectionPromise = function (obj) {\n        return obj && (typeof obj.then === 'function') && hof_1.is(Rejection)(obj._transitionRejection);\n    };\n    /** Returns a Rejection due to transition superseded */\n    Rejection.superseded = function (detail, options) {\n        var message = \"The transition has been superseded by a different transition\";\n        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n        if (options && options.redirected) {\n            rejection.redirected = true;\n        }\n        return rejection;\n    };\n    /** Returns a Rejection due to redirected transition */\n    Rejection.redirected = function (detail) {\n        return Rejection.superseded(detail, { redirected: true });\n    };\n    /** Returns a Rejection due to invalid transition */\n    Rejection.invalid = function (detail) {\n        var message = \"This transition is invalid\";\n        return new Rejection(RejectType.INVALID, message, detail);\n    };\n    /** Returns a Rejection due to ignored transition */\n    Rejection.ignored = function (detail) {\n        var message = \"The transition was ignored\";\n        return new Rejection(RejectType.IGNORED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.aborted = function (detail) {\n        var message = \"The transition has been aborted\";\n        return new Rejection(RejectType.ABORTED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.errored = function (detail) {\n        var message = \"The transition errored\";\n        return new Rejection(RejectType.ERROR, message, detail);\n    };\n    /**\n     * Returns a Rejection\n     *\n     * Normalizes a value as a Rejection.\n     * If the value is already a Rejection, returns it.\n     * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).\n     *\n     * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.\n     */\n    Rejection.normalize = function (detail) {\n        return hof_1.is(Rejection)(detail) ? detail : Rejection.errored(detail);\n    };\n    return Rejection;\n}());\nexports.Rejection = Rejection;\n//# sourceMappingURL=rejectFactory.js.map\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar interface_1 = __webpack_require__(10);\nvar common_1 = __webpack_require__(0);\nvar strings_1 = __webpack_require__(5);\nvar predicates_1 = __webpack_require__(1);\nvar hof_1 = __webpack_require__(2);\nvar trace_1 = __webpack_require__(6);\nvar coreservices_1 = __webpack_require__(3);\nvar rejectFactory_1 = __webpack_require__(12);\nvar targetState_1 = __webpack_require__(7);\nvar defaultOptions = {\n    current: common_1.noop,\n    transition: null,\n    traceData: {},\n    bind: null,\n};\n/** @hidden */\nvar TransitionHook = (function () {\n    function TransitionHook(transition, stateContext, registeredHook, options) {\n        var _this = this;\n        this.transition = transition;\n        this.stateContext = stateContext;\n        this.registeredHook = registeredHook;\n        this.options = options;\n        this.isSuperseded = function () {\n            return _this.type.hookPhase === interface_1.TransitionHookPhase.RUN && !_this.options.transition.isActive();\n        };\n        this.options = common_1.defaults(options, defaultOptions);\n        this.type = registeredHook.eventType;\n    }\n    TransitionHook.prototype.logError = function (err) {\n        this.transition.router.stateService.defaultErrorHandler()(err);\n    };\n    TransitionHook.prototype.invokeHook = function () {\n        var _this = this;\n        var hook = this.registeredHook;\n        if (hook._deregistered)\n            return;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        var options = this.options;\n        trace_1.trace.traceHookInvocation(this, this.transition, options);\n        var invokeCallback = function () {\n            return hook.callback.call(options.bind, _this.transition, _this.stateContext);\n        };\n        var normalizeErr = function (err) {\n            return rejectFactory_1.Rejection.normalize(err).toPromise();\n        };\n        var handleError = function (err) {\n            return hook.eventType.getErrorHandler(_this)(err);\n        };\n        var handleResult = function (result) {\n            return hook.eventType.getResultHandler(_this)(result);\n        };\n        try {\n            var result = invokeCallback();\n            if (!this.type.synchronous && predicates_1.isPromise(result)) {\n                return result.catch(normalizeErr)\n                    .then(handleResult, handleError);\n            }\n            else {\n                return handleResult(result);\n            }\n        }\n        catch (err) {\n            // If callback throws (synchronously)\n            return handleError(rejectFactory_1.Rejection.normalize(err));\n        }\n    };\n    /**\n     * This method handles the return value of a Transition Hook.\n     *\n     * A hook can return false (cancel), a TargetState (redirect),\n     * or a promise (which may later resolve to false or a redirect)\n     *\n     * This also handles \"transition superseded\" -- when a new transition\n     * was started while the hook was still running\n     */\n    TransitionHook.prototype.handleHookResult = function (result) {\n        var _this = this;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        // Hook returned a promise\n        if (predicates_1.isPromise(result)) {\n            // Wait for the promise, then reprocess with the resulting value\n            return result.then(function (val) { return _this.handleHookResult(val); });\n        }\n        trace_1.trace.traceHookResult(result, this.transition, this.options);\n        // Hook returned false\n        if (result === false) {\n            // Abort this Transition\n            return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise();\n        }\n        var isTargetState = hof_1.is(targetState_1.TargetState);\n        // hook returned a TargetState\n        if (isTargetState(result)) {\n            // Halt the current Transition and redirect (a new Transition) to the TargetState.\n            return rejectFactory_1.Rejection.redirected(result).toPromise();\n        }\n    };\n    /**\n     * Return a Rejection promise if the transition is no longer current due\n     * to a stopped router (disposed), or a new transition has started and superseded this one.\n     */\n    TransitionHook.prototype.getNotCurrentRejection = function () {\n        var router = this.transition.router;\n        // The router is stopped\n        if (router._disposed) {\n            return rejectFactory_1.Rejection.aborted(\"UIRouter instance #\" + router.$id + \" has been stopped (disposed)\").toPromise();\n        }\n        if (this.transition._aborted) {\n            return rejectFactory_1.Rejection.aborted().toPromise();\n        }\n        // This transition is no longer current.\n        // Another transition started while this hook was still running.\n        if (this.isSuperseded()) {\n            // Abort this transition\n            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n        }\n    };\n    TransitionHook.prototype.toString = function () {\n        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(registeredHook.callback);\n        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n    };\n    /**\n     * Chains together an array of TransitionHooks.\n     *\n     * Given a list of [[TransitionHook]] objects, chains them together.\n     * Each hook is invoked after the previous one completes.\n     *\n     * #### Example:\n     * ```js\n     * var hooks: TransitionHook[] = getHooks();\n     * let promise: Promise<any> = TransitionHook.chain(hooks);\n     *\n     * promise.then(handleSuccess, handleError);\n     * ```\n     *\n     * @param hooks the list of hooks to chain together\n     * @param waitFor if provided, the chain is `.then()`'ed off this promise\n     * @returns a `Promise` for sequentially invoking the hooks (in order)\n     */\n    TransitionHook.chain = function (hooks, waitFor) {\n        // Chain the next hook off the previous\n        var createHookChainR = function (prev, nextHook) {\n            return prev.then(function () { return nextHook.invokeHook(); });\n        };\n        return hooks.reduce(createHookChainR, waitFor || coreservices_1.services.$q.when());\n    };\n    /**\n     * Invokes all the provided TransitionHooks, in order.\n     * Each hook's return value is checked.\n     * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n     * If no hook returns a promise, then all hooks are processed synchronously.\n     *\n     * @param hooks the list of TransitionHooks to invoke\n     * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n     *\n     * @returns a promise for the async result, or the result of the callback\n     */\n    TransitionHook.invokeHooks = function (hooks, doneCallback) {\n        for (var idx = 0; idx < hooks.length; idx++) {\n            var hookResult = hooks[idx].invokeHook();\n            if (predicates_1.isPromise(hookResult)) {\n                var remainingHooks = hooks.slice(idx + 1);\n                return TransitionHook.chain(remainingHooks, hookResult)\n                    .then(doneCallback);\n            }\n        }\n        return doneCallback();\n    };\n    /**\n     * Run all TransitionHooks, ignoring their return value.\n     */\n    TransitionHook.runAllHooks = function (hooks) {\n        hooks.forEach(function (hook) { return hook.invokeHook(); });\n    };\n    return TransitionHook;\n}());\n/**\n * These GetResultHandler(s) are used by [[invokeHook]] below\n * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n */\nTransitionHook.HANDLE_RESULT = function (hook) { return function (result) {\n    return hook.handleHookResult(result);\n}; };\n/**\n * If the result is a promise rejection, log it.\n * Otherwise, ignore the result.\n */\nTransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {\n    predicates_1.isPromise(result) && result.catch(function (err) {\n        return hook.logError(rejectFactory_1.Rejection.normalize(err));\n    });\n    return undefined;\n}; };\n/**\n * These GetErrorHandler(s) are used by [[invokeHook]] below\n * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n */\nTransitionHook.LOG_ERROR = function (hook) { return function (error) {\n    return hook.logError(error);\n}; };\nTransitionHook.REJECT_ERROR = function (hook) { return function (error) {\n    return common_1.silentRejection(error);\n}; };\nTransitionHook.THROW_ERROR = function (hook) { return function (error) {\n    throw error;\n}; };\nexports.TransitionHook = TransitionHook;\n//# sourceMappingURL=transitionHook.js.map\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = __webpack_require__(16);\nvar common_1 = __webpack_require__(0);\nvar beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\nexports.splitHash = beforeAfterSubstr(\"#\");\nexports.splitQuery = beforeAfterSubstr(\"?\");\nexports.splitEqual = beforeAfterSubstr(\"=\");\nexports.trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\nexports.keyValsToObjectR = function (accum, _a) {\n    var key = _a[0], val = _a[1];\n    if (!accum.hasOwnProperty(key)) {\n        accum[key] = val;\n    }\n    else if (index_1.isArray(accum[key])) {\n        accum[key].push(val);\n    }\n    else {\n        accum[key] = [accum[key], val];\n    }\n    return accum;\n};\nexports.getParams = function (queryString) {\n    return queryString.split(\"&\").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});\n};\nfunction parseUrl(url) {\n    var orEmptyString = function (x) { return x || \"\"; };\n    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n    return { path: path, search: search, hash: hash, url: url };\n}\nexports.parseUrl = parseUrl;\nexports.buildUrl = function (loc) {\n    var path = loc.path();\n    var searchObject = loc.search();\n    var hash = loc.hash();\n    var search = Object.keys(searchObject).map(function (key) {\n        var param = searchObject[key];\n        var vals = index_1.isArray(param) ? param : [param];\n        return vals.map(function (val) { return key + \"=\" + val; });\n    }).reduce(common_1.unnestR, []).join(\"&\");\n    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n};\nfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n    return function (router) {\n        var service = router.locationService = new serviceClass(router);\n        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n        function dispose(router) {\n            router.dispose(service);\n            router.dispose(configuration);\n        }\n        return { name: name, service: service, configuration: configuration, dispose: dispose };\n    };\n}\nexports.locationPluginFactory = locationPluginFactory;\n//# sourceMappingURL=utils.js.map\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */\n/**\n * Matches state names using glob-like pattern strings.\n *\n * Globs can be used in specific APIs including:\n *\n * - [[StateService.is]]\n * - [[StateService.includes]]\n * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n *\n * A `Glob` string is a pattern which matches state names.\n * Nested state names are split into segments (separated by a dot) when processing.\n * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n *\n * Globs work according to the following rules:\n *\n * ### Exact match:\n *\n * The glob `'A.B'` matches the state named exactly `'A.B'`.\n *\n * | Glob        |Matches states named|Does not match state named|\n * |:------------|:--------------------|:---------------------|\n * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n *\n * ### Single star (`*`)\n *\n * A single star (`*`) is a wildcard that matches exactly one segment.\n *\n * | Glob        |Matches states named  |Does not match state named |\n * |:------------|:---------------------|:--------------------------|\n * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n *\n * ### Double star (`**`)\n *\n * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n *\n * | Glob        |Matches states named                           |Does not match state named         |\n * |:------------|:----------------------------------------------|:----------------------------------|\n * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n *\n */\nvar Glob = (function () {\n    function Glob(text) {\n        this.text = text;\n        this.glob = text.split('.');\n        var regexpString = this.text.split('.')\n            .map(function (seg) {\n            if (seg === '**')\n                return '(?:|(?:\\\\.[^.]*)*)';\n            if (seg === '*')\n                return '\\\\.[^.]*';\n            return '\\\\.' + seg;\n        }).join('');\n        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n    }\n    Glob.prototype.matches = function (name) {\n        return this.regexp.test('.' + name);\n    };\n    /** Returns true if the string has glob-like characters in it */\n    Glob.is = function (text) {\n        return !!/[!,*]+/.exec(text);\n    };\n    /** Returns a glob from the string, or null if the string isn't Glob-like */\n    Glob.fromString = function (text) {\n        return Glob.is(text) ? new Glob(text) : null;\n    };\n    return Glob;\n}());\nexports.Glob = Glob;\n//# sourceMappingURL=glob.js.map\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module common */ /** for typedoc */\n__export(__webpack_require__(0));\n__export(__webpack_require__(3));\n__export(__webpack_require__(15));\n__export(__webpack_require__(2));\n__export(__webpack_require__(1));\n__export(__webpack_require__(25));\n__export(__webpack_require__(5));\n__export(__webpack_require__(6));\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/** @module path */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar targetState_1 = __webpack_require__(7);\nvar pathNode_1 = __webpack_require__(27);\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nvar PathUtils = (function () {\n    function PathUtils() {\n    }\n    /** Given a PathNode[], create an TargetState */\n    PathUtils.makeTargetState = function (path) {\n        var state = common_1.tail(path).state;\n        return new targetState_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    PathUtils.buildPath = function (targetState) {\n        var toParams = targetState.params();\n        return targetState.$state().path.map(function (state) { return new pathNode_1.PathNode(state).applyRawParams(toParams); });\n    };\n    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n    PathUtils.buildToPath = function (fromPath, targetState) {\n        var toPath = PathUtils.buildPath(targetState);\n        if (targetState.options().inherit) {\n            return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n        }\n        return toPath;\n    };\n    /**\n     * Creates ViewConfig objects and adds to nodes.\n     *\n     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n     */\n    PathUtils.applyViewConfigs = function ($view, path, states) {\n        // Only apply the viewConfigs to the nodes for the given states\n        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n            var viewDecls = common_1.values(node.state.views || {});\n            var subPath = PathUtils.subPath(path, function (n) { return n === node; });\n            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n            node.views = viewConfigs.reduce(common_1.unnestR, []);\n        });\n    };\n    /**\n     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n     *\n     * For a parameter in a node to be inherited from the from path:\n     * - The toPath's node must have a matching node in the fromPath (by state).\n     * - The parameter name must not be found in the toKeys parameter array.\n     *\n     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n     * it is not inherited from the fromPath.\n     */\n    PathUtils.inheritParams = function (fromPath, toPath, toKeys) {\n        if (toKeys === void 0) { toKeys = []; }\n        function nodeParamVals(path, state) {\n            var node = common_1.find(path, hof_1.propEq('state', state));\n            return common_1.extend({}, node && node.paramValues);\n        }\n        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (param) { return !param.inherit; })\n            .map(hof_1.prop('id'));\n        /**\n         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n         */\n        function makeInheritedParamsNode(toNode) {\n            // All param values for the node (may include default key/vals, when key was not found in toParams)\n            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n            // limited to only those keys found in toParams\n            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n            toParamVals = common_1.omit(toParamVals, toKeys);\n            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n            return new pathNode_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n        }\n        // The param keys specified by the incoming toParams\n        return toPath.map(makeInheritedParamsNode);\n    };\n    /**\n     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n     */\n    PathUtils.treeChanges = function (fromPath, toPath, reloadState) {\n        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n        var nodesMatch = function (node1, node2) {\n            return node1.equals(node2, PathUtils.nonDynamicParams);\n        };\n        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n            keep++;\n        }\n        /** Given a retained node, return a new node which uses the to node's param values */\n        function applyToParams(retainedNode, idx) {\n            var cloned = pathNode_1.PathNode.clone(retainedNode);\n            cloned.paramValues = toPath[idx].paramValues;\n            return cloned;\n        }\n        var from, retained, exiting, entering, to;\n        from = fromPath;\n        retained = from.slice(0, keep);\n        exiting = from.slice(keep);\n        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n        var retainedWithToParams = retained.map(applyToParams);\n        entering = toPath.slice(keep);\n        to = (retainedWithToParams).concat(entering);\n        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n    };\n    /**\n     * Returns a new path which is: the subpath of the first path which matches the second path.\n     *\n     * The new path starts from root and contains any nodes that match the nodes in the second path.\n     * It stops before the first non-matching node.\n     *\n     * Nodes are compared using their state property and their parameter values.\n     * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n     *\n     * @param pathA the first path\n     * @param pathB the second path\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     *\n     * @returns an array of PathNodes from the first path which match the nodes in the second path\n     */\n    PathUtils.matching = function (pathA, pathB, paramsFn) {\n        var done = false;\n        var tuples = common_1.arrayTuples(pathA, pathB);\n        return tuples.reduce(function (matching, _a) {\n            var nodeA = _a[0], nodeB = _a[1];\n            done = done || !nodeA.equals(nodeB, paramsFn);\n            return done ? matching : matching.concat(nodeA);\n        }, []);\n    };\n    /**\n     * Returns true if two paths are identical.\n     *\n     * @param pathA\n     * @param pathB\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     * @returns true if the the states and parameter values for both paths are identical\n     */\n    PathUtils.equals = function (pathA, pathB, paramsFn) {\n        return pathA.length === pathB.length &&\n            PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n    };\n    /**\n     * Return a subpath of a path, which stops at the first matching node\n     *\n     * Given an array of nodes, returns a subset of the array starting from the first node,\n     * stopping when the first node matches the predicate.\n     *\n     * @param path a path of [[PathNode]]s\n     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n     * @returns a subpath up to the matching node, or undefined if no match is found\n     */\n    PathUtils.subPath = function (path, predicate) {\n        var node = common_1.find(path, predicate);\n        var elementIdx = path.indexOf(node);\n        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n    };\n    return PathUtils;\n}());\nPathUtils.nonDynamicParams = function (node) {\n    return node.state.parameters({ inherit: false })\n        .filter(function (param) { return !param.dynamic; });\n};\n/** Gets the raw parameter values from a path */\nPathUtils.paramValues = function (path) {\n    return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {});\n};\nexports.PathUtils = PathUtils;\n//# sourceMappingURL=pathFactory.js.map\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module resolve */\n/** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar trace_1 = __webpack_require__(6);\nvar coreservices_1 = __webpack_require__(3);\nvar interface_1 = __webpack_require__(37);\nvar resolvable_1 = __webpack_require__(11);\nvar pathFactory_1 = __webpack_require__(17);\nvar strings_1 = __webpack_require__(5);\nvar when = interface_1.resolvePolicies.when;\nvar ALL_WHENS = [when.EAGER, when.LAZY];\nvar EAGER_WHENS = [when.EAGER];\nexports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nvar ResolveContext = (function () {\n    function ResolveContext(_path) {\n        this._path = _path;\n    }\n    /** Gets all the tokens found in the resolve context, de-duplicated */\n    ResolveContext.prototype.getTokens = function () {\n        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n    };\n    /**\n     * Gets the Resolvable that matches the token\n     *\n     * Gets the last Resolvable that matches the token in this context, or undefined.\n     * Throws an error if it doesn't exist in the ResolveContext\n     */\n    ResolveContext.prototype.getResolvable = function (token) {\n        var matching = this._path.map(function (node) { return node.resolvables; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (r) { return r.token === token; });\n        return common_1.tail(matching);\n    };\n    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n    ResolveContext.prototype.getPolicy = function (resolvable) {\n        var node = this.findNode(resolvable);\n        return resolvable.getPolicy(node.state);\n    };\n    /**\n     * Returns a ResolveContext that includes a portion of this one\n     *\n     * Given a state, this method creates a new ResolveContext from this one.\n     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n     *\n     * #### Why\n     *\n     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n     * This method is used to create a narrower context when injecting ancestor nodes.\n     *\n     * @example\n     * `let ABCD = new ResolveContext([A, B, C, D]);`\n     *\n     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n     * However, `B` should only be able to access resolvables from `A`, `B`.\n     *\n     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n     * `let AB = ABCD.subcontext(a)`\n     */\n    ResolveContext.prototype.subContext = function (state) {\n        return new ResolveContext(pathFactory_1.PathUtils.subPath(this._path, function (node) { return node.state === state; }));\n    };\n    /**\n     * Adds Resolvables to the node that matches the state\n     *\n     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n     * The resolvable is added to the node matching the `state` parameter.\n     *\n     * These new resolvables are not automatically fetched.\n     * The calling code should either fetch them, fetch something that depends on them,\n     * or rely on [[resolvePath]] being called when some state is being entered.\n     *\n     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n     *\n     * @param newResolvables the new Resolvables\n     * @param state Used to find the node to put the resolvable on\n     */\n    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n        var node = common_1.find(this._path, hof_1.propEq('state', state));\n        var keys = newResolvables.map(function (r) { return r.token; });\n        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n    };\n    /**\n     * Returns a promise for an array of resolved path Element promises\n     *\n     * @param when\n     * @param trans\n     * @returns {Promise<any>|any}\n     */\n    ResolveContext.prototype.resolvePath = function (when, trans) {\n        var _this = this;\n        if (when === void 0) { when = \"LAZY\"; }\n        // This option determines which 'when' policy Resolvables we are about to fetch.\n        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n        // get the subpath to the state argument, if provided\n        trace_1.trace.traceResolvePath(this._path, when, trans);\n        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n            return function (resolvable) {\n                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n            };\n        };\n        // Trigger all the (matching) Resolvables in the path\n        // Reduce all the \"WAIT\" Resolvables into an array\n        var promises = this._path.reduce(function (acc, node) {\n            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n            // For the matching Resolvables, start their async fetch process.\n            var subContext = _this.subContext(node.state);\n            var getResult = function (r) { return r.get(subContext, trans)\n                .then(function (value) { return ({ token: r.token, value: value }); }); };\n            nowait.forEach(getResult);\n            return acc.concat(wait.map(getResult));\n        }, []);\n        // Wait for all the \"WAIT\" resolvables\n        return coreservices_1.services.$q.all(promises);\n    };\n    ResolveContext.prototype.injector = function () {\n        return this._injector || (this._injector = new UIInjectorImpl(this));\n    };\n    ResolveContext.prototype.findNode = function (resolvable) {\n        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n    };\n    /**\n     * Gets the async dependencies of a Resolvable\n     *\n     * Given a Resolvable, returns its dependencies as a Resolvable[]\n     */\n    ResolveContext.prototype.getDependencies = function (resolvable) {\n        var _this = this;\n        var node = this.findNode(resolvable);\n        // Find which other resolvables are \"visible\" to the `resolvable` argument\n        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n        var subPath = pathFactory_1.PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;\n        var availableResolvables = subPath\n            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n        var getDependency = function (token) {\n            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n            if (matching.length)\n                return common_1.tail(matching);\n            var fromInjector = _this.injector().getNative(token);\n            if (!fromInjector) {\n                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n            }\n            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n        };\n        return resolvable.deps.map(getDependency);\n    };\n    return ResolveContext;\n}());\nexports.ResolveContext = ResolveContext;\nvar UIInjectorImpl = (function () {\n    function UIInjectorImpl(context) {\n        this.context = context;\n        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n    }\n    UIInjectorImpl.prototype.get = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable) {\n            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n                return resolvable.get(this.context);\n            }\n            if (!resolvable.resolved) {\n                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n            }\n            return resolvable.data;\n        }\n        return this.native && this.native.get(token);\n    };\n    UIInjectorImpl.prototype.getAsync = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable)\n            return resolvable.get(this.context);\n        return coreservices_1.services.$q.when(this.native.get(token));\n    };\n    UIInjectorImpl.prototype.getNative = function (token) {\n        return this.native && this.native.get(token);\n    };\n    return UIInjectorImpl;\n}());\n//# sourceMappingURL=resolveContext.js.map\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar trace_1 = __webpack_require__(6);\nvar coreservices_1 = __webpack_require__(3);\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar hof_1 = __webpack_require__(2);\nvar interface_1 = __webpack_require__(10); // has or is using\nvar transitionHook_1 = __webpack_require__(13);\nvar hookRegistry_1 = __webpack_require__(29);\nvar hookBuilder_1 = __webpack_require__(44);\nvar pathFactory_1 = __webpack_require__(17);\nvar targetState_1 = __webpack_require__(7);\nvar param_1 = __webpack_require__(9);\nvar resolvable_1 = __webpack_require__(11);\nvar resolveContext_1 = __webpack_require__(18);\n/** @hidden */\nvar stateSelf = hof_1.prop(\"self\");\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nvar Transition = (function () {\n    /**\n     * Creates a new Transition object.\n     *\n     * If the target state is not valid, an error is thrown.\n     *\n     * @internalapi\n     *\n     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n     *        encapsulates the \"from state\".\n     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n     * @param router The [[UIRouter]] instance\n     */\n    function Transition(fromPath, targetState, router) {\n        var _this = this;\n        /** @hidden */\n        this._deferred = coreservices_1.services.$q.defer();\n        /**\n         * This promise is resolved or rejected based on the outcome of the Transition.\n         *\n         * When the transition is successful, the promise is resolved\n         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n         */\n        this.promise = this._deferred.promise;\n        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n        this._registeredHooks = {};\n        /** @hidden */\n        this._hookBuilder = new hookBuilder_1.HookBuilder(this);\n        /** Checks if this transition is currently active/running. */\n        this.isActive = function () {\n            return _this.router.globals.transition === _this;\n        };\n        this.router = router;\n        this._targetState = targetState;\n        if (!targetState.valid()) {\n            throw new Error(targetState.error());\n        }\n        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n        this.$id = router.transitionService._transitionCount++;\n        var toPath = pathFactory_1.PathUtils.buildToPath(fromPath, targetState);\n        this._treeChanges = pathFactory_1.PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n        this.createTransitionHookRegFns();\n        var onCreateHooks = this._hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n        transitionHook_1.TransitionHook.invokeHooks(onCreateHooks, function () { return null; });\n        this.applyViewConfigs(router);\n    }\n    /** @hidden */\n    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onError = function (criteria, callback, options) { return; };\n    /** @hidden\n     * Creates the transition-level hook registration functions\n     * (which can then be used to register hooks)\n     */\n    Transition.prototype.createTransitionHookRegFns = function () {\n        var _this = this;\n        this.router.transitionService._pluginapi._getEvents()\n            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n    };\n    /** @internalapi */\n    Transition.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    Transition.prototype.applyViewConfigs = function (router) {\n        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n        pathFactory_1.PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal from [State] object\n     */\n    Transition.prototype.$from = function () {\n        return common_1.tail(this._treeChanges.from).state;\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal to [State] object\n     */\n    Transition.prototype.$to = function () {\n        return common_1.tail(this._treeChanges.to).state;\n    };\n    /**\n     * Returns the \"from state\"\n     *\n     * Returns the state that the transition is coming *from*.\n     *\n     * @returns The state declaration object for the Transition's (\"from state\").\n     */\n    Transition.prototype.from = function () {\n        return this.$from().self;\n    };\n    /**\n     * Returns the \"to state\"\n     *\n     * Returns the state that the transition is going *to*.\n     *\n     * @returns The state declaration object for the Transition's target state (\"to state\").\n     */\n    Transition.prototype.to = function () {\n        return this.$to().self;\n    };\n    /**\n     * Gets the Target State\n     *\n     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n     *\n     * @returns the [[TargetState]] of this Transition\n     */\n    Transition.prototype.targetState = function () {\n        return this._targetState;\n    };\n    /**\n     * Determines whether two transitions are equivalent.\n     * @deprecated\n     */\n    Transition.prototype.is = function (compare) {\n        if (compare instanceof Transition) {\n            // TODO: Also compare parameters\n            return this.is({ to: compare.$to().name, from: compare.$from().name });\n        }\n        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n    };\n    Transition.prototype.params = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    /**\n     * Creates a [[UIInjector]] Dependency Injector\n     *\n     * Returns a Dependency Injector for the Transition's target state (to state).\n     * The injector provides resolve values which the target state has access to.\n     *\n     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n     *\n     * #### Example:\n     * ```js\n     * .onEnter({ entering: 'myState' }, trans => {\n     *   var myResolveValue = trans.injector().get('myResolve');\n     *   // Inject a global service from the global/native injector (if it exists)\n     *   var MyService = trans.injector().get('MyService');\n     * })\n     * ```\n     *\n     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n     * #### Example:\n     * ```js\n     * .onBefore({}, trans => {\n     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n     *     return myResolveValue !== 'ABORT';\n     *   });\n     * });\n     * ```\n     *\n     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n     * #### Example:\n     * ```js\n     * .onEnter({ to: 'foo.bar' }, trans => {\n     *   // returns result of `foo` state's `data` resolve\n     *   // even though `foo.bar` also has a `data` resolve\n     *   var fooData = trans.injector('foo').get('data');\n     * });\n     * ```\n     *\n     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n     * The resolve data from the `from` path will be returned.\n     * #### Example:\n     * ```js\n     * .onExit({ exiting: 'foo.bar' }, trans => {\n     *   // Gets the resolve value of `data` from the exiting state.\n     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n     * });\n     * ```\n     *\n     *\n     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n     *\n     * @returns a [[UIInjector]]\n     */\n    Transition.prototype.injector = function (state, pathName) {\n        if (pathName === void 0) { pathName = \"to\"; }\n        var path = this._treeChanges[pathName];\n        if (state)\n            path = pathFactory_1.PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n        return new resolveContext_1.ResolveContext(path).injector();\n    };\n    /**\n     * Gets all available resolve tokens (keys)\n     *\n     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n     * available to the Transition.\n     *\n     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n     * in the Transition's [[TreeChanges.to]] path.\n     *\n     * #### Example:\n     * This example logs all resolve values\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n     * ```\n     *\n     * #### Example:\n     * This example creates promises for each resolve value.\n     * This triggers fetches of resolves (if any have not yet been fetched).\n     * When all promises have all settled, it logs the resolve values.\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * let promise = tokens.map(token => trans.injector().getAsync(token));\n     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n     * ```\n     *\n     * Note: Angular 1 users whould use `$q.all()`\n     *\n     * @param pathname resolve context's path name (e.g., `to` or `from`)\n     *\n     * @returns an array of resolve tokens (keys)\n     */\n    Transition.prototype.getResolveTokens = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n    };\n    /**\n     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n     *\n     * #### Example:\n     * ```js\n     * transitionService.onBefore({}, transition => {\n     *   transition.addResolvable({\n     *     token: 'myResolve',\n     *     deps: ['MyService'],\n     *     resolveFn: myService => myService.getData()\n     *   });\n     * });\n     * ```\n     *\n     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n     */\n    Transition.prototype.addResolvable = function (resolvable, state) {\n        if (state === void 0) { state = \"\"; }\n        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n        var stateName = (typeof state === \"string\") ? state : state.name;\n        var topath = this._treeChanges.to;\n        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n        var resolveContext = new resolveContext_1.ResolveContext(topath);\n        resolveContext.addResolvables([resolvable], targetNode.state);\n    };\n    /**\n     * Gets the transition from which this transition was redirected.\n     *\n     * If the current transition is a redirect, this method returns the transition that was redirected.\n     *\n     * #### Example:\n     * ```js\n     * let transitionA = $state.go('A').transition\n     * transitionA.onStart({}, () => $state.target('B'));\n     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n     *   trans.to().name === 'B'; // true\n     *   trans.redirectedFrom() === transitionA; // true\n     * });\n     * ```\n     *\n     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n     */\n    Transition.prototype.redirectedFrom = function () {\n        return this._options.redirectedFrom || null;\n    };\n    /**\n     * Gets the original transition in a redirect chain\n     *\n     * A transition might belong to a long chain of multiple redirects.\n     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n     *\n     * #### Example:\n     * ```js\n     * // states\n     * registry.register({ name: 'A', redirectTo: 'B' });\n     * registry.register({ name: 'B', redirectTo: 'C' });\n     * registry.register({ name: 'C', redirectTo: 'D' });\n     * registry.register({ name: 'D' });\n     *\n     * let transitionA = $state.go('A').transition\n     *\n     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n     *   trans.to().name === 'D'; // true\n     *   trans.redirectedFrom().to().name === 'C'; // true\n     *   trans.originalTransition() === transitionA; // true\n     *   trans.originalTransition().to().name === 'A'; // true\n     * });\n     * ```\n     *\n     * @returns The original Transition that started a redirect chain\n     */\n    Transition.prototype.originalTransition = function () {\n        var rf = this.redirectedFrom();\n        return (rf && rf.originalTransition()) || this;\n    };\n    /**\n     * Get the transition options\n     *\n     * @returns the options for this Transition.\n     */\n    Transition.prototype.options = function () {\n        return this._options;\n    };\n    /**\n     * Gets the states being entered.\n     *\n     * @returns an array of states that will be entered during this transition.\n     */\n    Transition.prototype.entering = function () {\n        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Gets the states being exited.\n     *\n     * @returns an array of states that will be exited during this transition.\n     */\n    Transition.prototype.exiting = function () {\n        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n    };\n    /**\n     * Gets the states being retained.\n     *\n     * @returns an array of states that are already entered from a previous Transition, that will not be\n     *    exited during this Transition\n     */\n    Transition.prototype.retained = function () {\n        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Get the [[ViewConfig]]s associated with this Transition\n     *\n     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n     *\n     * @param pathname the name of the path to fetch views for:\n     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n     *\n     * @returns a list of ViewConfig objects for the given path.\n     */\n    Transition.prototype.views = function (pathname, state) {\n        if (pathname === void 0) { pathname = \"entering\"; }\n        var path = this._treeChanges[pathname];\n        path = !state ? path : path.filter(hof_1.propEq('state', state));\n        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n    };\n    Transition.prototype.treeChanges = function (pathname) {\n        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n    };\n    /**\n     * Creates a new transition that is a redirection of the current one.\n     *\n     * This transition can be returned from a [[TransitionService]] hook to\n     * redirect a transition to a new state and/or set of parameters.\n     *\n     * @internalapi\n     *\n     * @returns Returns a new [[Transition]] instance.\n     */\n    Transition.prototype.redirect = function (targetState) {\n        var redirects = 1, trans = this;\n        while ((trans = trans.redirectedFrom()) != null) {\n            if (++redirects > 20)\n                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n        }\n        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n        // If the original transition was caused by URL sync, then use { location: 'replace' }\n        // on the new transition (unless the target state explicitly specifies location: false).\n        // This causes the original url to be replaced with the url for the redirect target\n        // so the original url disappears from the browser history.\n        if (this.options().source === 'url' && targetState.options().location !== false) {\n            redirectOpts.location = 'replace';\n        }\n        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n        var originalEnteringNodes = this._treeChanges.entering;\n        var redirectEnteringNodes = newTransition._treeChanges.entering;\n        // --- Re-use resolve data from original transition ---\n        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n        // redirected transition.\n        //\n        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n        // You can wait for the resolve, then redirect to a child state based on the result.\n        // The redirected transition does not have to re-fetch the resolve.\n        // ---------------------------------------------------------\n        var nodeIsReloading = function (reloadState) { return function (node) {\n            return reloadState && node.state.includes[reloadState.name];\n        }; };\n        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n        var matchingEnteringNodes = pathFactory_1.PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, pathFactory_1.PathUtils.nonDynamicParams)\n            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n        matchingEnteringNodes.forEach(function (node, idx) {\n            node.resolvables = originalEnteringNodes[idx].resolvables;\n        });\n        return newTransition;\n    };\n    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n    Transition.prototype._changedParams = function () {\n        var tc = this._treeChanges;\n        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n        // If user explicitly wants a reload\n        if (this._options.reload)\n            return undefined;\n        // If any states are exiting or entering\n        if (tc.exiting.length || tc.entering.length)\n            return undefined;\n        // If to/from path lengths differ\n        if (tc.to.length !== tc.from.length)\n            return undefined;\n        // If the to/from paths are different\n        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n            .reduce(common_1.anyTrueR, false);\n        if (pathsDiffer)\n            return undefined;\n        // Find any parameter values that differ\n        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n        return tuples.map(function (_a) {\n            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n            return param_1.Param.changed(schema, toVals, fromVals);\n        }).reduce(common_1.unnestR, []);\n    };\n    /**\n     * Returns true if the transition is dynamic.\n     *\n     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n     *\n     * @returns true if the Transition is dynamic\n     */\n    Transition.prototype.dynamic = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n    };\n    /**\n     * Returns true if the transition is ignored.\n     *\n     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n     *\n     * @returns true if the Transition is ignored.\n     */\n    Transition.prototype.ignored = function () {\n        return !!this._ignoredReason();\n    };\n    /** @hidden */\n    Transition.prototype._ignoredReason = function () {\n        var pending = this.router.globals.transition;\n        var reloadState = this._options.reloadState;\n        var same = function (pathA, pathB) {\n            if (pathA.length !== pathB.length)\n                return false;\n            var matching = pathFactory_1.PathUtils.matching(pathA, pathB);\n            return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;\n        };\n        var newTC = this.treeChanges();\n        var pendTC = pending && pending.treeChanges();\n        if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))\n            return \"SameAsPending\";\n        if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))\n            return \"SameAsCurrent\";\n    };\n    /**\n     * Runs the transition\n     *\n     * This method is generally called from the [[StateService.transitionTo]]\n     *\n     * @internalapi\n     *\n     * @returns a promise for a successful transition.\n     */\n    Transition.prototype.run = function () {\n        var _this = this;\n        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n        // Gets transition hooks array for the given phase\n        var getHooksFor = function (phase) {\n            return _this._hookBuilder.buildHooksForPhase(phase);\n        };\n        // When the chain is complete, then resolve or reject the deferred\n        var transitionSuccess = function () {\n            trace_1.trace.traceSuccess(_this.$to(), _this);\n            _this.success = true;\n            _this._deferred.resolve(_this.to());\n            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.SUCCESS));\n        };\n        var transitionError = function (reason) {\n            trace_1.trace.traceError(reason, _this);\n            _this.success = false;\n            _this._deferred.reject(reason);\n            _this._error = reason;\n            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.ERROR));\n        };\n        var runTransition = function () {\n            // Wait to build the RUN hook chain until the BEFORE hooks are done\n            // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n            var allRunHooks = getHooksFor(interface_1.TransitionHookPhase.RUN);\n            var done = function () { return coreservices_1.services.$q.when(undefined); };\n            return transitionHook_1.TransitionHook.invokeHooks(allRunHooks, done);\n        };\n        var startTransition = function () {\n            var globals = _this.router.globals;\n            globals.lastStartedTransitionId = _this.$id;\n            globals.transition = _this;\n            globals.transitionHistory.enqueue(_this);\n            trace_1.trace.traceTransitionStart(_this);\n            return coreservices_1.services.$q.when(undefined);\n        };\n        var allBeforeHooks = getHooksFor(interface_1.TransitionHookPhase.BEFORE);\n        transitionHook_1.TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n            .then(runTransition)\n            .then(transitionSuccess, transitionError);\n        return this.promise;\n    };\n    /**\n     * Checks if the Transition is valid\n     *\n     * @returns true if the Transition is valid\n     */\n    Transition.prototype.valid = function () {\n        return !this.error() || this.success !== undefined;\n    };\n    /**\n     * Aborts this transition\n     *\n     * Imperative API to abort a Transition.\n     * This only applies to Transitions that are not yet complete.\n     */\n    Transition.prototype.abort = function () {\n        // Do not set flag if the transition is already complete\n        if (predicates_1.isUndefined(this.success)) {\n            this._aborted = true;\n        }\n    };\n    /**\n     * The Transition error reason.\n     *\n     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n     *\n     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n     */\n    Transition.prototype.error = function () {\n        var state = this.$to();\n        if (state.self.abstract)\n            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n        if (!param_1.Param.validates(state.parameters(), this.params()))\n            return \"Param values not valid for state '\" + state.name + \"'\";\n        if (this.success === false)\n            return this._error;\n    };\n    /**\n     * A string representation of the Transition\n     *\n     * @returns A string representation of the Transition\n     */\n    Transition.prototype.toString = function () {\n        var fromStateOrName = this.from();\n        var toStateOrName = this.to();\n        var avoidEmptyHash = function (params) {\n            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, [\"#\"]);\n        };\n        // (X) means the to state is invalid.\n        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n    };\n    return Transition;\n}());\n/** @hidden */\nTransition.diToken = Transition;\nexports.Transition = Transition;\n//# sourceMappingURL=transition.js.map\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar predicates_1 = __webpack_require__(1);\nvar param_1 = __webpack_require__(9);\nvar strings_1 = __webpack_require__(5);\n/** @hidden */\nfunction quoteRegExp(string, param) {\n    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!param)\n        return result;\n    switch (param.squash) {\n        case false:\n            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n            break;\n        case true:\n            result = result.replace(/\\/$/, '');\n            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n            break;\n        default:\n            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n            break;\n    }\n    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n/** @hidden */\nvar memoizeTo = function (obj, prop, fn) {\n    return obj[prop] = obj[prop] || fn();\n};\n/** @hidden */\nvar splitOnSlash = strings_1.splitOnDelim('/');\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nvar UrlMatcher = (function () {\n    /**\n     * @param pattern The pattern to compile into a matcher.\n     * @param paramTypes The [[ParamTypes]] registry\n     * @param config  A configuration object\n     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n     */\n    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n        var _this = this;\n        this.config = config;\n        /** @hidden */\n        this._cache = { path: [this] };\n        /** @hidden */\n        this._children = [];\n        /** @hidden */\n        this._params = [];\n        /** @hidden */\n        this._segments = [];\n        /** @hidden */\n        this._compiled = [];\n        this.pattern = pattern;\n        this.config = common_1.defaults(this.config, {\n            params: {},\n            strict: true,\n            caseInsensitive: false,\n            paramMap: common_1.identity\n        });\n        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n        //   '*' name\n        //   ':' name\n        //   '{' name '}'\n        //   '{' name ':' regexp '}'\n        // The regular expression is somewhat complicated due to the need to allow curly braces\n        // inside the regular expression. The placeholder regexp breaks down as follows:\n        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n        //    \\\\.                            - a backslash escape\n        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n        var checkParamErrors = function (id) {\n            if (!UrlMatcher.nameValidator.test(id))\n                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n        };\n        // Split into static segments separated by path parameter placeholders.\n        // The number of segments is always 1 more than the number of parameters.\n        var matchDetails = function (m, isSearch) {\n            // IE[78] returns '' for unmatched groups instead of null\n            var id = m[2] || m[3];\n            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n            }); };\n            return {\n                id: id,\n                regexp: regexp,\n                cfg: _this.config.params[id],\n                segment: pattern.substring(last, m.index),\n                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n            };\n        };\n        var p, segment;\n        while ((m = placeholder.exec(pattern))) {\n            p = matchDetails(m, false);\n            if (p.segment.indexOf('?') >= 0)\n                break; // we're into the search part\n            checkParamErrors(p.id);\n            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n            this._segments.push(p.segment);\n            patterns.push([p.segment, common_1.tail(this._params)]);\n            last = placeholder.lastIndex;\n        }\n        segment = pattern.substring(last);\n        // Find any search parameter names and remove them from the last segment\n        var i = segment.indexOf('?');\n        if (i >= 0) {\n            var search = segment.substring(i);\n            segment = segment.substring(0, i);\n            if (search.length > 0) {\n                last = 0;\n                while ((m = searchPlaceholder.exec(search))) {\n                    p = matchDetails(m, true);\n                    checkParamErrors(p.id);\n                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n                    last = placeholder.lastIndex;\n                    // check if ?&\n                }\n            }\n        }\n        this._segments.push(segment);\n        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n    }\n    /**\n     * Creates a new concatenated UrlMatcher\n     *\n     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n     *\n     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n     */\n    UrlMatcher.prototype.append = function (url) {\n        this._children.push(url);\n        url._cache = {\n            path: this._cache.path.concat(url),\n            parent: this,\n            pattern: null,\n        };\n        return url;\n    };\n    /** @hidden */\n    UrlMatcher.prototype.isRoot = function () {\n        return this._cache.path[0] === this;\n    };\n    /** Returns the input pattern string */\n    UrlMatcher.prototype.toString = function () {\n        return this.pattern;\n    };\n    /**\n     * Tests the specified url/path against this matcher.\n     *\n     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n     * parameter values.  Returns null if the path does not match.\n     *\n     * The returned object contains the values\n     * of any search parameters that are mentioned in the pattern, but their value may be null if\n     * they are not present in `search`. This means that search parameters are always treated\n     * as optional.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n     *   x: '1', q: 'hello'\n     * });\n     * // returns { id: 'bob', q: 'hello', r: null }\n     * ```\n     *\n     * @param path    The URL path to match, e.g. `$location.path()`.\n     * @param search  URL search parameters, e.g. `$location.search()`.\n     * @param hash    URL hash e.g. `$location.hash()`.\n     * @param options\n     *\n     * @returns The captured parameter values.\n     */\n    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n        var _this = this;\n        if (search === void 0) { search = {}; }\n        if (options === void 0) { options = {}; }\n        var match = memoizeTo(this._cache, 'pattern', function () {\n            return new RegExp([\n                '^',\n                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n                _this.config.strict === false ? '\\/?' : '',\n                '$'\n            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n        }).exec(path);\n        if (!match)\n            return null;\n        //options = defaults(options, { isolate: false });\n        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n        if (nPathSegments !== match.length - 1)\n            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n        function decodePathArray(string) {\n            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n            var split = reverseString(string).split(/-(?!\\\\)/);\n            var allReversed = common_1.map(split, reverseString);\n            return common_1.map(allReversed, unquoteDashes).reverse();\n        }\n        for (var i = 0; i < nPathSegments; i++) {\n            var param = pathParams[i];\n            var value = match[i + 1];\n            // if the param value matches a pre-replace pair, replace the value before decoding.\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (value && param.array === true)\n                value = decodePathArray(value);\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        }\n        searchParams.forEach(function (param) {\n            var value = search[param.id];\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        });\n        if (hash)\n            values[\"#\"] = hash;\n        return values;\n    };\n    /**\n     * @hidden\n     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n     *\n     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n     *    pattern has no parameters, an empty array is returned.\n     */\n    UrlMatcher.prototype.parameters = function (opts) {\n        if (opts === void 0) { opts = {}; }\n        if (opts.inherit === false)\n            return this._params;\n        return common_1.unnest(this._cache.path.map(function (matcher) { return matcher._params; }));\n    };\n    /**\n     * @hidden\n     * Returns a single parameter from this UrlMatcher by id\n     *\n     * @param id\n     * @param opts\n     * @returns {T|Param|any|boolean|UrlMatcher|null}\n     */\n    UrlMatcher.prototype.parameter = function (id, opts) {\n        var _this = this;\n        if (opts === void 0) { opts = {}; }\n        var findParam = function () {\n            for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {\n                var param = _a[_i];\n                if (param.id === id)\n                    return param;\n            }\n        };\n        var parent = this._cache.parent;\n        return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;\n    };\n    /**\n     * Validates the input parameter values against this UrlMatcher\n     *\n     * Checks an object hash of parameters to validate their correctness according to the parameter\n     * types of this `UrlMatcher`.\n     *\n     * @param params The object hash of parameters to validate.\n     * @returns Returns `true` if `params` validates, otherwise `false`.\n     */\n    UrlMatcher.prototype.validates = function (params) {\n        var validParamVal = function (param, val) {\n            return !param || param.validates(val);\n        };\n        params = params || {};\n        // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher\n        var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });\n        return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(common_1.allTrueR, true);\n    };\n    /**\n     * Given a set of parameter values, creates a URL from this UrlMatcher.\n     *\n     * Creates a URL that matches this pattern by substituting the specified values\n     * for the path and search parameters.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n     * // returns '/user/bob?q=yes'\n     * ```\n     *\n     * @param values  the values to substitute for the parameters in this pattern.\n     * @returns the formatted URL (path and optionally search part).\n     */\n    UrlMatcher.prototype.format = function (values) {\n        if (values === void 0) { values = {}; }\n        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n        var urlMatchers = this._cache.path;\n        // Extract all the static segments and Params (processed as ParamDetails)\n        // into an ordered array\n        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams)\n            .reduce(common_1.unnestR, [])\n            .map(function (x) { return predicates_1.isString(x) ? x : getDetails(x); });\n        // Extract the query params into a separate array\n        var queryParams = urlMatchers.map(UrlMatcher.queryParams)\n            .reduce(common_1.unnestR, [])\n            .map(getDetails);\n        var isInvalid = function (param) { return param.isValid === false; };\n        if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {\n            return null;\n        }\n        /**\n         * Given a Param, applies the parameter value, then returns detailed information about it\n         */\n        function getDetails(param) {\n            // Normalize to typed value\n            var value = param.value(values[param.id]);\n            var isValid = param.validates(value);\n            var isDefaultValue = param.isDefaultValue(value);\n            // Check if we're in squash mode for the parameter\n            var squash = isDefaultValue ? param.squash : false;\n            // Allow the Parameter's Type to encode the value\n            var encoded = param.type.encode(value);\n            return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n        }\n        // Build up the path-portion from the list of static segments and parameters\n        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n            // The element is a static segment (a raw string); just append it\n            if (predicates_1.isString(x))\n                return acc + x;\n            // Otherwise, it's a ParamDetails.\n            var squash = x.squash, encoded = x.encoded, param = x.param;\n            // If squash is === true, try to remove a slash from the path\n            if (squash === true)\n                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n            // If squash is a string, use the string for the param value\n            if (predicates_1.isString(squash))\n                return acc + squash;\n            if (squash !== false)\n                return acc; // ?\n            if (encoded == null)\n                return acc;\n            // If this parameter value is an array, encode the value using encodeDashes\n            if (predicates_1.isArray(encoded))\n                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n            // If the parameter type is \"raw\", then do not encodeURIComponent\n            if (param.raw)\n                return acc + encoded;\n            // Encode the value\n            return acc + encodeURIComponent(encoded);\n        }, \"\");\n        // Build the query string by applying parameter values (array or regular)\n        // then mapping to key=value, then flattening and joining using \"&\"\n        var queryString = queryParams.map(function (paramDetails) {\n            var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;\n            if (encoded == null || (isDefaultValue && squash !== false))\n                return;\n            if (!predicates_1.isArray(encoded))\n                encoded = [encoded];\n            if (encoded.length === 0)\n                return;\n            if (!param.raw)\n                encoded = common_1.map(encoded, encodeURIComponent);\n            return encoded.map(function (val) { return param.id + \"=\" + val; });\n        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n    };\n    /** @hidden */\n    UrlMatcher.encodeDashes = function (str) {\n        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n        var staticSegments = matcher._segments;\n        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n            .reduce(common_1.unnestR, [])\n            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's query params */\n    UrlMatcher.queryParams = function (matcher) {\n        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n    };\n    /**\n     * Compare two UrlMatchers\n     *\n     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n     * Each static path segment is a static string between a path separator (slash character).\n     * Each dynamic segment is a path parameter.\n     *\n     * The comparison function sorts static segments before dynamic ones.\n     */\n    UrlMatcher.compare = function (a, b) {\n        /**\n         * Turn a UrlMatcher and all its parent matchers into an array\n         * of slash literals '/', string literals, and Param objects\n         *\n         * This example matcher matches strings like \"/foo/:param/tail\":\n         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n         *\n         * Caches the result as `matcher._cache.segments`\n         */\n        var segments = function (matcher) {\n            return matcher._cache.segments = matcher._cache.segments ||\n                matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n                    .reduce(common_1.unnestR, [])\n                    .reduce(strings_1.joinNeighborsR, [])\n                    .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n                    .reduce(common_1.unnestR, []);\n        };\n        /**\n         * Gets the sort weight for each segment of a UrlMatcher\n         *\n         * Caches the result as `matcher._cache.weights`\n         */\n        var weights = function (matcher) {\n            return matcher._cache.weights = matcher._cache.weights ||\n                segments(matcher).map(function (segment) {\n                    // Sort slashes first, then static strings, the Params\n                    if (segment === '/')\n                        return 1;\n                    if (predicates_1.isString(segment))\n                        return 2;\n                    if (segment instanceof param_1.Param)\n                        return 3;\n                });\n        };\n        var cmp, i, pairs = common_1.arrayTuples(weights(a), weights(b));\n        for (i = 0; i < pairs.length; i++) {\n            cmp = pairs[i][0] - pairs[i][1];\n            if (cmp !== 0)\n                return cmp;\n        }\n        return 0;\n    };\n    return UrlMatcher;\n}());\n/** @hidden */\nUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\nexports.UrlMatcher = UrlMatcher;\n//# sourceMappingURL=urlMatcher.js.map\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @internalapi\n * @module vanilla\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = __webpack_require__(14);\nvar predicates_1 = __webpack_require__(1);\nvar common_1 = __webpack_require__(0);\n/** A base `LocationServices` */\nvar BaseLocationServices = (function () {\n    function BaseLocationServices(router, fireAfterUpdate) {\n        var _this = this;\n        this.fireAfterUpdate = fireAfterUpdate;\n        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n        this._listeners = [];\n        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n        this._location = window && window.location;\n        this._history = window && window.history;\n    }\n    BaseLocationServices.prototype.url = function (url, replace) {\n        if (replace === void 0) { replace = true; }\n        if (predicates_1.isDefined(url) && url !== this._get()) {\n            this._set(null, null, url, replace);\n            if (this.fireAfterUpdate) {\n                var evt_1 = common_1.extend(new Event(\"locationchange\"), { url: url });\n                this._listeners.forEach(function (cb) { return cb(evt_1); });\n            }\n        }\n        return utils_1.buildUrl(this);\n    };\n    BaseLocationServices.prototype.onChange = function (cb) {\n        var _this = this;\n        this._listeners.push(cb);\n        return function () { return common_1.removeFrom(_this._listeners, cb); };\n    };\n    BaseLocationServices.prototype.dispose = function (router) {\n        common_1.deregAll(this._listeners);\n    };\n    return BaseLocationServices;\n}());\nexports.BaseLocationServices = BaseLocationServices;\n//# sourceMappingURL=baseLocationService.js.map\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Angular 1 types\n *\n * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.\n * The customizations to the core types for Angular UI-Router are documented here.\n *\n * The optional [[$resolve]] service is also documented here.\n *\n * @module ng1\n * @preferred\n */\n/** for typedoc */\nvar angular_1 = __webpack_require__(8);\nvar core_1 = __webpack_require__(4);\nvar views_1 = __webpack_require__(24);\nvar templateFactory_1 = __webpack_require__(67);\nvar stateProvider_1 = __webpack_require__(31);\nvar onEnterExitRetain_1 = __webpack_require__(66);\nvar locationServices_1 = __webpack_require__(64);\nvar urlRouterProvider_1 = __webpack_require__(32);\nangular_1.ng.module(\"ui.router.angular1\", []);\nvar mod_init = angular_1.ng.module('ui.router.init', []);\nvar mod_util = angular_1.ng.module('ui.router.util', ['ng', 'ui.router.init']);\nvar mod_rtr = angular_1.ng.module('ui.router.router', ['ui.router.util']);\nvar mod_state = angular_1.ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);\nvar mod_main = angular_1.ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);\nvar mod_cmpt = angular_1.ng.module('ui.router.compat', ['ui.router']); // tslint:disable-line\nvar router = null;\n$uiRouter.$inject = ['$locationProvider'];\n/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */\nfunction $uiRouter($locationProvider) {\n    // Create a new instance of the Router when the $uiRouterProvider is initialized\n    router = this.router = new core_1.UIRouter();\n    router.stateProvider = new stateProvider_1.StateProvider(router.stateRegistry, router.stateService);\n    // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties\n    router.stateRegistry.decorator(\"views\", views_1.ng1ViewsBuilder);\n    router.stateRegistry.decorator(\"onExit\", onEnterExitRetain_1.getStateHookBuilder(\"onExit\"));\n    router.stateRegistry.decorator(\"onRetain\", onEnterExitRetain_1.getStateHookBuilder(\"onRetain\"));\n    router.stateRegistry.decorator(\"onEnter\", onEnterExitRetain_1.getStateHookBuilder(\"onEnter\"));\n    router.viewService._pluginapi._viewConfigFactory('ng1', views_1.getNg1ViewConfigFactory());\n    var ng1LocationService = router.locationService = router.locationConfig = new locationServices_1.Ng1LocationServices($locationProvider);\n    locationServices_1.Ng1LocationServices.monkeyPatchPathParameterType(router);\n    // backwards compat: also expose router instance as $uiRouterProvider.router\n    router['router'] = router;\n    router['$get'] = $get;\n    $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];\n    function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {\n        ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);\n        delete router['router'];\n        delete router['$get'];\n        return router;\n    }\n    return router;\n}\nvar getProviderFor = function (serviceName) { return ['$uiRouterProvider', function ($urp) {\n        var service = $urp.router[serviceName];\n        service[\"$get\"] = function () { return service; };\n        return service;\n    }]; };\n// This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)\nrunBlock.$inject = ['$injector', '$q', '$uiRouter'];\nfunction runBlock($injector, $q, $uiRouter) {\n    core_1.services.$injector = $injector;\n    core_1.services.$q = $q;\n    // The $injector is now available.\n    // Find any resolvables that had dependency annotation deferred\n    $uiRouter.stateRegistry.get()\n        .map(function (x) { return x.$$state().resolvables; })\n        .reduce(core_1.unnestR, [])\n        .filter(function (x) { return x.deps === \"deferred\"; })\n        .forEach(function (resolvable) { return resolvable.deps = $injector.annotate(resolvable.resolveFn); });\n}\n// $urlRouter service and $urlRouterProvider\nvar getUrlRouterProvider = function (uiRouter) {\n    return uiRouter.urlRouterProvider = new urlRouterProvider_1.UrlRouterProvider(uiRouter);\n};\n// $state service and $stateProvider\n// $urlRouter service and $urlRouterProvider\nvar getStateProvider = function () {\n    return core_1.extend(router.stateProvider, { $get: function () { return router.stateService; } });\n};\nwatchDigests.$inject = ['$rootScope'];\nfunction watchDigests($rootScope) {\n    $rootScope.$watch(function () { core_1.trace.approximateDigests++; });\n}\nexports.watchDigests = watchDigests;\nmod_init.provider(\"$uiRouter\", $uiRouter);\nmod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);\nmod_util.provider('$urlService', getProviderFor('urlService'));\nmod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);\nmod_util.provider('$templateFactory', function () { return new templateFactory_1.TemplateFactory(); });\nmod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));\nmod_state.provider('$uiRouterGlobals', getProviderFor('globals'));\nmod_state.provider('$transitions', getProviderFor('transitionService'));\nmod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);\nmod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);\nmod_main.factory('$view', function () { return router.viewService; });\nmod_main.service(\"$trace\", function () { return core_1.trace; });\nmod_main.run(watchDigests);\nmod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);\nmod_state.run(['$state', function ($state) { }]);\nmod_rtr.run(['$urlRouter', function ($urlRouter) { }]);\nmod_init.run(runBlock);\n/** @hidden TODO: find a place to move this */\nexports.getLocals = function (ctx) {\n    var tokens = ctx.getTokens().filter(core_1.isString);\n    var tuples = tokens.map(function (key) {\n        var resolvable = ctx.getResolvable(key);\n        var waitPolicy = ctx.getPolicy(resolvable).async;\n        return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];\n    });\n    return tuples.reduce(core_1.applyPairs, {});\n};\n//# sourceMappingURL=services.js.map\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(4);\nfunction getNg1ViewConfigFactory() {\n    var templateFactory = null;\n    return function (path, view) {\n        templateFactory = templateFactory || core_1.services.$injector.get(\"$templateFactory\");\n        return [new Ng1ViewConfig(path, view, templateFactory)];\n    };\n}\nexports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;\nvar hasAnyKey = function (keys, obj) {\n    return keys.reduce(function (acc, key) { return acc || core_1.isDefined(obj[key]); }, false);\n};\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `views`.\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * handles the `views` property with logic specific to @uirouter/angularjs (ng1).\n *\n * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n * and applies the state-level configuration to a view named `$default`.\n */\nfunction ng1ViewsBuilder(state) {\n    // Do not process root state\n    if (!state.parent)\n        return {};\n    var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);\n    // Do not allow a state to have both state-level props and also a `views: {}` property.\n    // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.\n    // However, the `$default` approach should not be mixed with a separate `views: ` block.\n    if (core_1.isDefined(state.views) && hasAnyKey(allViewKeys, state)) {\n        throw new Error(\"State '\" + state.name + \"' has a 'views' object. \" +\n            \"It cannot also have \\\"view properties\\\" at the state level.  \" +\n            \"Move the following properties into a view (in the 'views' object): \" +\n            (\" \" + allViewKeys.filter(function (key) { return core_1.isDefined(state[key]); }).join(\", \")));\n    }\n    var views = {}, viewsObject = state.views || { \"$default\": core_1.pick(state, allViewKeys) };\n    core_1.forEach(viewsObject, function (config, name) {\n        // Account for views: { \"\": { template... } }\n        name = name || \"$default\";\n        // Account for views: { header: \"headerComponent\" }\n        if (core_1.isString(config))\n            config = { component: config };\n        // Make a shallow copy of the config object\n        config = core_1.extend({}, config);\n        // Do not allow a view to mix props for component-style view with props for template/controller-style view\n        if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {\n            throw new Error(\"Cannot combine: \" + compKeys.join(\"|\") + \" with: \" + nonCompKeys.join(\"|\") + \" in stateview: '\" + name + \"@\" + state.name + \"'\");\n        }\n        config.resolveAs = config.resolveAs || '$resolve';\n        config.$type = \"ng1\";\n        config.$context = state;\n        config.$name = name;\n        var normalized = core_1.ViewService.normalizeUIViewTarget(config.$context, config.$name);\n        config.$uiViewName = normalized.uiViewName;\n        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n        views[name] = config;\n    });\n    return views;\n}\nexports.ng1ViewsBuilder = ng1ViewsBuilder;\nvar id = 0;\nvar Ng1ViewConfig = (function () {\n    function Ng1ViewConfig(path, viewDecl, factory) {\n        var _this = this;\n        this.path = path;\n        this.viewDecl = viewDecl;\n        this.factory = factory;\n        this.$id = id++;\n        this.loaded = false;\n        this.getTemplate = function (uiView, context) {\n            return _this.component ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings) : _this.template;\n        };\n    }\n    Ng1ViewConfig.prototype.load = function () {\n        var _this = this;\n        var $q = core_1.services.$q;\n        var context = new core_1.ResolveContext(this.path);\n        var params = this.path.reduce(function (acc, node) { return core_1.extend(acc, node.paramValues); }, {});\n        var promises = {\n            template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),\n            controller: $q.when(this.getController(context))\n        };\n        return $q.all(promises).then(function (results) {\n            core_1.trace.traceViewServiceEvent(\"Loaded\", _this);\n            _this.controller = results.controller;\n            core_1.extend(_this, results.template); // Either { template: \"tpl\" } or { component: \"cmpName\" }\n            return _this;\n        });\n    };\n    /**\n     * Gets the controller for a view configuration.\n     *\n     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.\n     */\n    Ng1ViewConfig.prototype.getController = function (context) {\n        var provider = this.viewDecl.controllerProvider;\n        if (!core_1.isInjectable(provider))\n            return this.viewDecl.controller;\n        var deps = core_1.services.$injector.annotate(provider);\n        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;\n        var resolvable = new core_1.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    return Ng1ViewConfig;\n}());\nexports.Ng1ViewConfig = Ng1ViewConfig;\n//# sourceMappingURL=views.js.map\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module common\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Queue = (function () {\n    function Queue(_items, _limit) {\n        if (_items === void 0) { _items = []; }\n        if (_limit === void 0) { _limit = null; }\n        this._items = _items;\n        this._limit = _limit;\n    }\n    Queue.prototype.enqueue = function (item) {\n        var items = this._items;\n        items.push(item);\n        if (this._limit && items.length > this._limit)\n            items.shift();\n        return item;\n    };\n    Queue.prototype.dequeue = function () {\n        if (this.size())\n            return this._items.splice(0, 1)[0];\n    };\n    Queue.prototype.clear = function () {\n        var current = this._items;\n        this._items = [];\n        return current;\n    };\n    Queue.prototype.size = function () {\n        return this._items.length;\n    };\n    Queue.prototype.remove = function (item) {\n        var idx = this._items.indexOf(item);\n        return idx > -1 && this._items.splice(idx, 1)[0];\n    };\n    Queue.prototype.peekTail = function () {\n        return this._items[this._items.length - 1];\n    };\n    Queue.prototype.peekHead = function () {\n        if (this.size())\n            return this._items[0];\n    };\n    return Queue;\n}());\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\nvar ParamType = (function () {\n    /**\n     * @param def  A configuration object which contains the custom type definition.  The object's\n     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n     * @returns a new ParamType object\n     */\n    function ParamType(def) {\n        /** @inheritdoc */\n        this.pattern = /.*/;\n        /** @inheritdoc */\n        this.inherit = true;\n        common_1.extend(this, def);\n    }\n    // consider these four methods to be \"abstract methods\" that should be overridden\n    /** @inheritdoc */\n    ParamType.prototype.is = function (val, key) { return true; };\n    /** @inheritdoc */\n    ParamType.prototype.encode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.decode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.equals = function (a, b) { return a == b; };\n    ParamType.prototype.$subPattern = function () {\n        var sub = this.pattern.toString();\n        return sub.substr(1, sub.length - 2);\n    };\n    ParamType.prototype.toString = function () {\n        return \"{ParamType:\" + this.name + \"}\";\n    };\n    /** Given an encoded string, or a decoded object, returns a decoded object */\n    ParamType.prototype.$normalize = function (val) {\n        return this.is(val) ? val : this.decode(val);\n    };\n    /**\n     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n     * e.g.:\n     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n     * - url: \"/path?queryParam=1&queryParam=2\n     * - $stateParams.queryParam will be [1, 2]\n     * if `mode` is \"auto\", then\n     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n     */\n    ParamType.prototype.$asArray = function (mode, isSearch) {\n        if (!mode)\n            return this;\n        if (mode === \"auto\" && !isSearch)\n            throw new Error(\"'auto' array mode is for query parameters only\");\n        return new ArrayType(this, mode);\n    };\n    return ParamType;\n}());\nexports.ParamType = ParamType;\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\nfunction ArrayType(type, mode) {\n    var _this = this;\n    // Wrap non-array value as array\n    function arrayWrap(val) {\n        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n    }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n        switch (val.length) {\n            case 0: return undefined;\n            case 1: return mode === \"auto\" ? val[0] : val;\n            default: return val;\n        }\n    }\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n        return function handleArray(val) {\n            if (predicates_1.isArray(val) && val.length === 0)\n                return val;\n            var arr = arrayWrap(val);\n            var result = common_1.map(arr, callback);\n            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n        };\n    }\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n        return function handleArray(val1, val2) {\n            var left = arrayWrap(val1), right = arrayWrap(val2);\n            if (left.length !== right.length)\n                return false;\n            for (var i = 0; i < left.length; i++) {\n                if (!callback(left[i], right[i]))\n                    return false;\n            }\n            return true;\n        };\n    }\n    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n        var paramTypeFn = type[name].bind(type);\n        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n        _this[name] = wrapperFn(paramTypeFn);\n    });\n    common_1.extend(this, {\n        dynamic: type.dynamic,\n        name: type.name,\n        pattern: type.pattern,\n        inherit: type.inherit,\n        is: arrayHandler(type.is.bind(type), true),\n        $arrayMode: mode\n    });\n}\n//# sourceMappingURL=paramType.js.map\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module path */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar param_1 = __webpack_require__(9);\n/**\n * @internalapi\n *\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nvar PathNode = (function () {\n    function PathNode(stateOrNode) {\n        if (stateOrNode instanceof PathNode) {\n            var node = stateOrNode;\n            this.state = node.state;\n            this.paramSchema = node.paramSchema.slice();\n            this.paramValues = common_1.extend({}, node.paramValues);\n            this.resolvables = node.resolvables.slice();\n            this.views = node.views && node.views.slice();\n        }\n        else {\n            var state = stateOrNode;\n            this.state = state;\n            this.paramSchema = state.parameters({ inherit: false });\n            this.paramValues = {};\n            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n        }\n    }\n    /** Sets [[paramValues]] for the node, from the values of an object hash */\n    PathNode.prototype.applyRawParams = function (params) {\n        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n        return this;\n    };\n    /** Gets a specific [[Param]] metadata that belongs to the node */\n    PathNode.prototype.parameter = function (name) {\n        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n    };\n    /**\n     * @returns true if the state and parameter values for another PathNode are\n     * equal to the state and param values for this PathNode\n     */\n    PathNode.prototype.equals = function (node, paramsFn) {\n        var diff = this.diff(node, paramsFn);\n        return diff && diff.length === 0;\n    };\n    /**\n     * Finds Params with different parameter values on another PathNode.\n     *\n     * Given another node (of the same state), finds the parameter values which differ.\n     * Returns the [[Param]] (schema objects) whose parameter values differ.\n     *\n     * Given another node for a different state, returns `false`\n     *\n     * @param node The node to compare to\n     * @param paramsFn A function that returns which parameters should be compared.\n     * @returns The [[Param]]s which differ, or null if the two nodes are for different states\n     */\n    PathNode.prototype.diff = function (node, paramsFn) {\n        if (this.state !== node.state)\n            return false;\n        var params = paramsFn ? paramsFn(this) : this.paramSchema;\n        return param_1.Param.changed(params, this.paramValues, node.paramValues);\n    };\n    /** Returns a clone of the PathNode */\n    PathNode.clone = function (node) {\n        return new PathNode(node);\n    };\n    return PathNode;\n}());\nexports.PathNode = PathNode;\n//# sourceMappingURL=pathNode.js.map\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar glob_1 = __webpack_require__(15);\nvar predicates_1 = __webpack_require__(1);\n/**\n * Internal representation of a UI-Router state.\n *\n * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n *\n * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.\n *\n * This class prototypally inherits from the corresponding [[StateDeclaration]].\n * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n */\nvar StateObject = (function () {\n    /** @deprecated use State.create() */\n    function StateObject(config) {\n        return StateObject.create(config || {});\n    }\n    /**\n     * Create a state object to put the private/internal implementation details onto.\n     * The object's prototype chain looks like:\n     * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)\n     *\n     * @param stateDecl the user-supplied State Declaration\n     * @returns {StateObject} an internal State object\n     */\n    StateObject.create = function (stateDecl) {\n        stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;\n        var state = common_1.inherit(common_1.inherit(stateDecl, StateObject.prototype));\n        stateDecl.$$state = function () { return state; };\n        state.self = stateDecl;\n        state.__stateObjectCache = {\n            nameGlob: glob_1.Glob.fromString(state.name) // might return null\n        };\n        return state;\n    };\n    /**\n     * Returns true if the provided parameter is the same state.\n     *\n     * Compares the identity of the state against the passed value, which is either an object\n     * reference to the actual `State` instance, the original definition object passed to\n     * `$stateProvider.state()`, or the fully-qualified name.\n     *\n     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n     * @returns Returns `true` if `ref` matches the current `State` instance.\n     */\n    StateObject.prototype.is = function (ref) {\n        return this === ref || this.self === ref || this.fqn() === ref;\n    };\n    /**\n     * @deprecated this does not properly handle dot notation\n     * @returns Returns a dot-separated name of the state.\n     */\n    StateObject.prototype.fqn = function () {\n        if (!this.parent || !(this.parent instanceof this.constructor))\n            return this.name;\n        var name = this.parent.fqn();\n        return name ? name + \".\" + this.name : this.name;\n    };\n    /**\n     * Returns the root node of this state's tree.\n     *\n     * @returns The root of this state's tree.\n     */\n    StateObject.prototype.root = function () {\n        return this.parent && this.parent.root() || this;\n    };\n    /**\n     * Gets the state's `Param` objects\n     *\n     * Gets the list of [[Param]] objects owned by the state.\n     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.\n     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n     *\n     * @param opts options\n     */\n    StateObject.prototype.parameters = function (opts) {\n        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n        return inherited.concat(common_1.values(this.params))\n            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n    };\n    /**\n     * Returns a single [[Param]] that is owned by the state\n     *\n     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.\n     * @param id the name of the [[Param]] to return\n     * @param opts options\n     */\n    StateObject.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        return (this.url && this.url.parameter(id, opts) ||\n            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n            opts.inherit && this.parent && this.parent.parameter(id));\n    };\n    StateObject.prototype.toString = function () {\n        return this.fqn();\n    };\n    return StateObject;\n}());\n/** Predicate which returns true if the object is an class with @State() decorator */\nStateObject.isStateClass = function (stateDecl) {\n    return predicates_1.isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;\n};\n/** Predicate which returns true if the object is an internal [[StateObject]] object */\nStateObject.isState = function (obj) {\n    return predicates_1.isObject(obj['__stateObjectCache']);\n};\nexports.StateObject = StateObject;\n//# sourceMappingURL=stateObject.js.map\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar interface_1 = __webpack_require__(10); // has or is using\nvar glob_1 = __webpack_require__(15);\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nfunction matchState(state, criterion) {\n    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n    function matchGlobs(_state) {\n        var globStrings = toMatch;\n        for (var i = 0; i < globStrings.length; i++) {\n            var glob = new glob_1.Glob(globStrings[i]);\n            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n    return !!matchFn(state);\n}\nexports.matchState = matchState;\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nvar RegisteredHook = (function () {\n    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n        if (options === void 0) { options = {}; }\n        this.tranSvc = tranSvc;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.matchCriteria = matchCriteria;\n        this.priority = options.priority || 0;\n        this.bind = options.bind || null;\n        this._deregistered = false;\n    }\n    /**\n     * Gets the matching [[PathNode]]s\n     *\n     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n     *\n     * Returning `null` is significant to distinguish between the default\n     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n     * when the nodes is an empty array.\n     *\n     * This is useful to allow a transition match criteria of `entering: true`\n     * to still match a transition, even when `entering === []`.  Contrast that\n     * with `entering: (state) => true` which only matches when a state is actually\n     * being entered.\n     */\n    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n        if (criterion === true)\n            return nodes;\n        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n        return matching.length ? matching : null;\n    };\n    /**\n     * Gets the default match criteria (all `true`)\n     *\n     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n     *\n     * ```js\n     * {\n     *   to: true,\n     *   from: true,\n     *   entering: true,\n     *   exiting: true,\n     *   retained: true,\n     * }\n     */\n    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n    };\n    /**\n     * Gets matching nodes as [[IMatchingNodes]]\n     *\n     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n     *\n     * ```js\n     * let matches: IMatchingNodes = {\n     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n     * };\n     * ```\n     */\n    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n        var _this = this;\n        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n        return paths.reduce(function (mn, pathtype) {\n            // STATE scope criteria matches against every node in the path.\n            // TRANSITION scope criteria matches against only the last node in the path\n            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n            var path = treeChanges[pathtype.name] || [];\n            var nodes = isStateHook ? path : [common_1.tail(path)];\n            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n            return mn;\n        }, {});\n    };\n    /**\n     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n     *\n     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n     */\n    RegisteredHook.prototype.matches = function (treeChanges) {\n        var matches = this._getMatchingNodes(treeChanges);\n        // Check if all the criteria matched the TreeChanges object\n        var allMatched = common_1.values(matches).every(common_1.identity);\n        return allMatched ? matches : null;\n    };\n    return RegisteredHook;\n}());\nexports.RegisteredHook = RegisteredHook;\n/** @hidden Return a registration function of the requested type. */\nfunction makeEvent(registry, transitionService, eventType) {\n    // Create the object which holds the registered transition hooks.\n    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n    var hooks = _registeredHooks[eventType.name] = [];\n    // Create hook registration function on the IHookRegistry for the event\n    registry[eventType.name] = hookRegistrationFn;\n    function hookRegistrationFn(matchObject, callback, options) {\n        if (options === void 0) { options = {}; }\n        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n        hooks.push(registeredHook);\n        return function deregisterEventHook() {\n            registeredHook._deregistered = true;\n            common_1.removeFrom(hooks)(registeredHook);\n        };\n    }\n    return hookRegistrationFn;\n}\nexports.makeEvent = makeEvent;\n//# sourceMappingURL=hookRegistry.js.map\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar interface_1 = __webpack_require__(10);\nvar transition_1 = __webpack_require__(19);\nvar hookRegistry_1 = __webpack_require__(29);\nvar coreResolvables_1 = __webpack_require__(69);\nvar redirectTo_1 = __webpack_require__(73);\nvar onEnterExitRetain_1 = __webpack_require__(72);\nvar resolve_1 = __webpack_require__(74);\nvar views_1 = __webpack_require__(77);\nvar updateGlobals_1 = __webpack_require__(75);\nvar url_1 = __webpack_require__(76);\nvar lazyLoad_1 = __webpack_require__(34);\nvar transitionEventType_1 = __webpack_require__(45);\nvar transitionHook_1 = __webpack_require__(13);\nvar predicates_1 = __webpack_require__(1);\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar ignoredTransition_1 = __webpack_require__(70);\nvar invalidTransition_1 = __webpack_require__(71);\n/**\n * The default [[Transition]] options.\n *\n * Include this object when applying custom defaults:\n * let reloadOpts = { reload: true, notify: true }\n * let options = defaults(theirOpts, customDefaults, defaultOptions);\n */\nexports.defaultTransOpts = {\n    location: true,\n    relative: null,\n    inherit: false,\n    notify: true,\n    reload: false,\n    custom: {},\n    current: function () { return null; },\n    source: \"unknown\"\n};\n/**\n * This class provides services related to Transitions.\n *\n * - Most importantly, it allows global Transition Hooks to be registered.\n * - It allows the default transition error handler to be set.\n * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n *\n * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n */\nvar TransitionService = (function () {\n    /** @hidden */\n    function TransitionService(_router) {\n        /** @hidden */\n        this._transitionCount = 0;\n        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n        this._eventTypes = [];\n        /** @hidden The registered transition hooks */\n        this._registeredHooks = {};\n        /** @hidden The  paths on a criteria object */\n        this._criteriaPaths = {};\n        this._router = _router;\n        this.$view = _router.viewService;\n        this._deregisterHookFns = {};\n        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n            '_definePathType',\n            '_defineEvent',\n            '_getPathTypes',\n            '_getEvents',\n            'getHooks',\n        ]);\n        this._defineCorePaths();\n        this._defineCoreEvents();\n        this._registerCoreTransitionHooks();\n    }\n    /**\n     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n     *\n     * Registers a transition lifecycle hook, which is invoked during transition construction.\n     *\n     * This low level hook should only be used by plugins.\n     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n     * The Sticky States plugin uses this hook to modify the treechanges.\n     *\n     * ### Lifecycle\n     *\n     * `onCreate` hooks are invoked *while a transition is being constructed*.\n     *\n     * ### Return value\n     *\n     * The hook's return value is ignored\n     *\n     * @internalapi\n     * @param criteria defines which Transitions the Hook should be invoked for.\n     * @param callback the hook function which will be invoked.\n     * @param options the registration options\n     * @returns a function which deregisters the hook.\n     */\n    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n    /**\n     * dispose\n     * @internalapi\n     */\n    TransitionService.prototype.dispose = function (router) {\n        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n            hook._deregistered = true;\n            common_1.removeFrom(hooksArray, hook);\n        }); });\n    };\n    /**\n     * Creates a new [[Transition]] object\n     *\n     * This is a factory function for creating new Transition objects.\n     * It is used internally by the [[StateService]] and should generally not be called by application code.\n     *\n     * @param fromPath the path to the current state (the from state)\n     * @param targetState the target state (destination)\n     * @returns a Transition\n     */\n    TransitionService.prototype.create = function (fromPath, targetState) {\n        return new transition_1.Transition(fromPath, targetState, this._router);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCoreEvents = function () {\n        var Phase = interface_1.TransitionHookPhase;\n        var TH = transitionHook_1.TransitionHook;\n        var paths = this._criteriaPaths;\n        var NORMAL_SORT = false, REVERSE_SORT = true;\n        var ASYNCHRONOUS = false, SYNCHRONOUS = true;\n        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);\n        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to);\n        this._defineEvent(\"onStart\", Phase.RUN, 0, paths.to);\n        this._defineEvent(\"onExit\", Phase.RUN, 100, paths.exiting, REVERSE_SORT);\n        this._defineEvent(\"onRetain\", Phase.RUN, 200, paths.retained);\n        this._defineEvent(\"onEnter\", Phase.RUN, 300, paths.entering);\n        this._defineEvent(\"onFinish\", Phase.RUN, 400, paths.to);\n        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCorePaths = function () {\n        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n        this._definePathType(\"to\", TRANSITION);\n        this._definePathType(\"from\", TRANSITION);\n        this._definePathType(\"exiting\", STATE);\n        this._definePathType(\"retained\", STATE);\n        this._definePathType(\"entering\", STATE);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);\n        this._eventTypes.push(eventType);\n        hookRegistry_1.makeEvent(this, this, eventType);\n    };\n    ;\n    /** @hidden */\n    TransitionService.prototype._getEvents = function (phase) {\n        var transitionHookTypes = predicates_1.isDefined(phase) ?\n            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n            this._eventTypes.slice();\n        return transitionHookTypes.sort(function (l, r) {\n            var cmpByPhase = l.hookPhase - r.hookPhase;\n            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n        });\n    };\n    /**\n     * Adds a Path to be used as a criterion against a TreeChanges path\n     *\n     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n     *\n     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n     *\n     * @hidden\n     */\n    TransitionService.prototype._definePathType = function (name, hookScope) {\n        this._criteriaPaths[name] = { name: name, scope: hookScope };\n    };\n    /** * @hidden */\n    TransitionService.prototype._getPathTypes = function () {\n        return this._criteriaPaths;\n    };\n    /** @hidden */\n    TransitionService.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    /** @hidden */\n    TransitionService.prototype._registerCoreTransitionHooks = function () {\n        var fns = this._deregisterHookFns;\n        fns.addCoreResolves = coreResolvables_1.registerAddCoreResolvables(this);\n        fns.ignored = ignoredTransition_1.registerIgnoredTransitionHook(this);\n        fns.invalid = invalidTransition_1.registerInvalidTransitionHook(this);\n        // Wire up redirectTo hook\n        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n        // Wire up onExit/Retain/Enter state hooks\n        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n        // Wire up Resolve hooks\n        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n        // Wire up the View management hooks\n        fns.loadViews = views_1.registerLoadEnteringViews(this);\n        fns.activateViews = views_1.registerActivateViews(this);\n        // Updates global state after a transition\n        fns.updateGlobals = updateGlobals_1.registerUpdateGlobalState(this);\n        // After globals.current is updated at priority: 10000\n        fns.updateUrl = url_1.registerUpdateUrl(this);\n        // Lazy load state trees\n        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n    };\n    return TransitionService;\n}());\nexports.TransitionService = TransitionService;\n//# sourceMappingURL=transitionService.js.map\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module ng1 */ /** for typedoc */\nvar core_1 = __webpack_require__(4);\n/**\n * The Angular 1 `StateProvider`\n *\n * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\nvar StateProvider = (function () {\n    function StateProvider(stateRegistry, stateService) {\n        this.stateRegistry = stateRegistry;\n        this.stateService = stateService;\n        core_1.createProxyFunctions(core_1.val(StateProvider.prototype), this, core_1.val(this));\n    }\n    /**\n     * Decorates states when they are registered\n     *\n     * Allows you to extend (carefully) or override (at your own peril) the\n     * `stateBuilder` object used internally by [[StateRegistry]].\n     * This can be used to add custom functionality to ui-router,\n     * for example inferring templateUrl based on the state name.\n     *\n     * When passing only a name, it returns the current (original or decorated) builder\n     * function that matches `name`.\n     *\n     * The builder functions that can be decorated are listed below. Though not all\n     * necessarily have a good use case for decoration, that is up to you to decide.\n     *\n     * In addition, users can attach custom decorators, which will generate new\n     * properties within the state's internal definition. There is currently no clear\n     * use-case for this beyond accessing internal states (i.e. $state.$current),\n     * however, expect this to become increasingly relevant as we introduce additional\n     * meta-programming features.\n     *\n     * **Warning**: Decorators should not be interdependent because the order of\n     * execution of the builder functions in non-deterministic. Builder functions\n     * should only be dependent on the state definition object and super function.\n     *\n     *\n     * Existing builder functions and current return values:\n     *\n     * - **parent** `{object}` - returns the parent state object.\n     * - **data** `{object}` - returns state data, including any inherited data that is not\n     *   overridden by own values (if any).\n     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n     *   or `null`.\n     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n     *   navigable).\n     * - **params** `{object}` - returns an array of state params that are ensured to\n     *   be a super-set of parent's params.\n     * - **views** `{object}` - returns a views object where each key is an absolute view\n     *   name (i.e. \"viewName@stateName\") and each value is the config object\n     *   (template, controller) for the view. Even when you don't use the views object\n     *   explicitly on a state config, one is still created for you internally.\n     *   So by decorating this builder function you have access to decorating template\n     *   and controller properties.\n     * - **ownParams** `{object}` - returns an array of params that belong to the state,\n     *   not including any params defined by ancestor states.\n     * - **path** `{string}` - returns the full path from the root down to this state.\n     *   Needed for state activation.\n     * - **includes** `{object}` - returns an object that includes every state that\n     *   would pass a `$state.includes()` test.\n     *\n     * #### Example:\n     * Override the internal 'views' builder with a function that takes the state\n     * definition, and a reference to the internal function being overridden:\n     * ```js\n     * $stateProvider.decorator('views', function (state, parent) {\n     *   let result = {},\n     *       views = parent(state);\n     *\n     *   angular.forEach(views, function (config, name) {\n     *     let autoName = (state.name + '.' + name).replace('.', '/');\n     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n     *     result[name] = config;\n     *   });\n     *   return result;\n     * });\n     *\n     * $stateProvider.state('home', {\n     *   views: {\n     *     'contact.list': { controller: 'ListController' },\n     *     'contact.item': { controller: 'ItemController' }\n     *   }\n     * });\n     * ```\n     *\n     *\n     * ```js\n     * // Auto-populates list and item views with /partials/home/contact/list.html,\n     * // and /partials/home/contact/item.html, respectively.\n     * $state.go('home');\n     * ```\n     *\n     * @param {string} name The name of the builder function to decorate.\n     * @param {object} func A function that is responsible for decorating the original\n     * builder function. The function receives two parameters:\n     *\n     *   - `{object}` - state - The state config object.\n     *   - `{object}` - super - The original builder function.\n     *\n     * @return {object} $stateProvider - $stateProvider instance\n     */\n    StateProvider.prototype.decorator = function (name, func) {\n        return this.stateRegistry.decorator(name, func) || this;\n    };\n    StateProvider.prototype.state = function (name, definition) {\n        if (core_1.isObject(name)) {\n            definition = name;\n        }\n        else {\n            definition.name = name;\n        }\n        this.stateRegistry.register(definition);\n        return this;\n    };\n    /**\n     * Registers an invalid state handler\n     *\n     * This is a passthrough to [[StateService.onInvalid]] for ng1.\n     */\n    StateProvider.prototype.onInvalid = function (callback) {\n        return this.stateService.onInvalid(callback);\n    };\n    return StateProvider;\n}());\nexports.StateProvider = StateProvider;\n//# sourceMappingURL=stateProvider.js.map\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module url */ /** */\nvar core_1 = __webpack_require__(4);\nvar core_2 = __webpack_require__(4);\n/**\n * Manages rules for client-side URL\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class manages the router rules for what to do when the URL changes.\n *\n * This provider remains for backwards compatibility.\n *\n * @deprecated\n */\nvar UrlRouterProvider = (function () {\n    /** @hidden */\n    function UrlRouterProvider(router) {\n        this._router = router;\n        this._urlRouter = router.urlRouter;\n    }\n    /** @hidden */\n    UrlRouterProvider.prototype.$get = function () {\n        var urlRouter = this._urlRouter;\n        urlRouter.update(true);\n        if (!urlRouter.interceptDeferred)\n            urlRouter.listen();\n        return urlRouter;\n    };\n    /**\n     * Registers a url handler function.\n     *\n     * Registers a low level url handler (a `rule`).\n     * A rule detects specific URL patterns and returns a redirect, or performs some action.\n     *\n     * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Here's an example of how you might allow case insensitive urls\n     *   $urlRouterProvider.rule(function ($injector, $location) {\n     *     var path = $location.path(),\n     *         normalized = path.toLowerCase();\n     *\n     *     if (path !== normalized) {\n     *       return normalized;\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param ruleFn\n     * Handler function that takes `$injector` and `$location` services as arguments.\n     * You can use them to detect a url and return a different url as a string.\n     *\n     * @return [[UrlRouterProvider]] (`this`)\n     */\n    UrlRouterProvider.prototype.rule = function (ruleFn) {\n        var _this = this;\n        if (!core_2.isFunction(ruleFn))\n            throw new Error(\"'rule' must be a function\");\n        var match = function () {\n            return ruleFn(core_2.services.$injector, _this._router.locationService);\n        };\n        var rule = new core_1.BaseUrlRule(match, core_2.identity);\n        this._urlRouter.rule(rule);\n        return this;\n    };\n    ;\n    /**\n     * Defines the path or behavior to use when no url can be matched.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // if the path doesn't match any of the urls you configured\n     *   // otherwise will take care of routing the user to the\n     *   // specified url\n     *   $urlRouterProvider.otherwise('/index');\n     *\n     *   // Example of using function rule as param\n     *   $urlRouterProvider.otherwise(function ($injector, $location) {\n     *     return '/a/valid/url';\n     *   });\n     * });\n     * ```\n     *\n     * @param rule\n     * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.\n     * The function version is passed two params: `$injector` and `$location` services, and should return a url string.\n     *\n     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n     */\n    UrlRouterProvider.prototype.otherwise = function (rule) {\n        var _this = this;\n        var urlRouter = this._urlRouter;\n        if (core_2.isString(rule)) {\n            urlRouter.otherwise(rule);\n        }\n        else if (core_2.isFunction(rule)) {\n            urlRouter.otherwise(function () { return rule(core_2.services.$injector, _this._router.locationService); });\n        }\n        else {\n            throw new Error(\"'rule' must be a string or function\");\n        }\n        return this;\n    };\n    ;\n    /**\n     * Registers a handler for a given url matching.\n     *\n     * If the handler is a string, it is\n     * treated as a redirect, and is interpolated according to the syntax of match\n     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n     *\n     * If the handler is a function, it is injectable.\n     * It gets invoked if `$location` matches.\n     * You have the option of inject the match object as `$match`.\n     *\n     * The handler can return\n     *\n     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n     *   will continue trying to find another one that matches.\n     * - **string** which is treated as a redirect and passed to `$location.url()`\n     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n     *     if ($state.$current.navigable !== state ||\n     *         !equalForKeys($match, $stateParams) {\n     *      $state.transitionTo(state, $match, false);\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param what A pattern string to match, compiled as a [[UrlMatcher]].\n     * @param handler The path (or function that returns a path) that you want to redirect your user to.\n     * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]\n     *\n     * Note: the handler may also invoke arbitrary code, such as `$state.go()`\n     */\n    UrlRouterProvider.prototype.when = function (what, handler) {\n        if (core_2.isArray(handler) || core_2.isFunction(handler)) {\n            handler = UrlRouterProvider.injectableHandler(this._router, handler);\n        }\n        this._urlRouter.when(what, handler);\n        return this;\n    };\n    ;\n    UrlRouterProvider.injectableHandler = function (router, handler) {\n        return function (match) {\n            return core_2.services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params });\n        };\n    };\n    /**\n     * Disables monitoring of the URL.\n     *\n     * Call this method before UI-Router has bootstrapped.\n     * It will stop UI-Router from performing the initial url sync.\n     *\n     * This can be useful to perform some asynchronous initialization before the router starts.\n     * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Prevent $urlRouter from automatically intercepting URL changes;\n     *   $urlRouterProvider.deferIntercept();\n     * })\n     *\n     * app.run(function (MyService, $urlRouter, $http) {\n     *   $http.get(\"/stuff\").then(function(resp) {\n     *     MyService.doStuff(resp.data);\n     *     $urlRouter.listen();\n     *     $urlRouter.sync();\n     *   });\n     * });\n     * ```\n     *\n     * @param defer Indicates whether to defer location change interception.\n     *        Passing no parameter is equivalent to `true`.\n     */\n    UrlRouterProvider.prototype.deferIntercept = function (defer) {\n        this._urlRouter.deferIntercept(defer);\n    };\n    ;\n    return UrlRouterProvider;\n}());\nexports.UrlRouterProvider = UrlRouterProvider;\n//# sourceMappingURL=urlRouterProvider.js.map\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */ /** */\nvar stateParams_1 = __webpack_require__(36);\nvar queue_1 = __webpack_require__(25);\n/**\n * Global router state\n *\n * This is where we hold the global mutable state such as current state, current\n * params, current transition, etc.\n */\nvar UIRouterGlobals = (function () {\n    function UIRouterGlobals() {\n        /**\n         * Current parameter values\n         *\n         * The parameter values from the latest successful transition\n         */\n        this.params = new stateParams_1.StateParams();\n        /** @internalapi */\n        this.lastStartedTransitionId = -1;\n        /** @internalapi */\n        this.transitionHistory = new queue_1.Queue([], 1);\n        /** @internalapi */\n        this.successfulTransitions = new queue_1.Queue([], 1);\n    }\n    UIRouterGlobals.prototype.dispose = function () {\n        this.transitionHistory.clear();\n        this.successfulTransitions.clear();\n        this.transition = null;\n    };\n    return UIRouterGlobals;\n}());\nexports.UIRouterGlobals = UIRouterGlobals;\n//# sourceMappingURL=globals.js.map\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar coreservices_1 = __webpack_require__(3);\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => System.import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nvar lazyLoadHook = function (transition) {\n    var router = transition.router;\n    function retryTransition() {\n        if (transition.originalTransition().options().source !== 'url') {\n            // The original transition was not triggered via url sync\n            // The lazy state should be loaded now, so re-try the original transition\n            var orig = transition.targetState();\n            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n        }\n        // The original transition was triggered via url sync\n        // Run the URL rules and find the best match\n        var $url = router.urlService;\n        var result = $url.match($url.parts());\n        var rule = result && result.rule;\n        // If the best match is a state, redirect the transition (instead\n        // of calling sync() which supersedes the current transition)\n        if (rule && rule.type === \"STATE\") {\n            var state = rule.state;\n            var params = result.match;\n            return router.stateService.target(state, params, transition.options());\n        }\n        // No matching state found, so let .sync() choose the best non-state match/otherwise\n        router.urlService.sync();\n    }\n    var promises = transition.entering()\n        .filter(function (state) { return !!state.$$state().lazyLoad; })\n        .map(function (state) { return lazyLoadState(transition, state); });\n    return coreservices_1.services.$q.all(promises).then(retryTransition);\n};\nexports.registerLazyLoadHook = function (transitionService) {\n    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nfunction lazyLoadState(transition, state) {\n    var lazyLoadFn = state.$$state().lazyLoad;\n    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n    var promise = lazyLoadFn['_promise'];\n    if (!promise) {\n        var success = function (result) {\n            delete state.lazyLoad;\n            delete state.$$state().lazyLoad;\n            delete lazyLoadFn['_promise'];\n            return result;\n        };\n        var error = function (err) {\n            delete lazyLoadFn['_promise'];\n            return coreservices_1.services.$q.reject(err);\n        };\n        promise = lazyLoadFn['_promise'] =\n            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n                .then(updateStateRegistry)\n                .then(success, error);\n    }\n    /** Register any lazy loaded state definitions */\n    function updateStateRegistry(result) {\n        if (result && Array.isArray(result.states)) {\n            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n        }\n        return result;\n    }\n    return promise;\n}\nexports.lazyLoadState = lazyLoadState;\n//# sourceMappingURL=lazyLoad.js.map\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar hof_1 = __webpack_require__(2);\nvar coreservices_1 = __webpack_require__(3);\nvar paramType_1 = __webpack_require__(26);\n/**\n * A registry for parameter types.\n *\n * This registry manages the built-in (and custom) parameter types.\n *\n * The built-in parameter types are:\n *\n * - [[string]]\n * - [[path]]\n * - [[query]]\n * - [[hash]]\n * - [[int]]\n * - [[bool]]\n * - [[date]]\n * - [[json]]\n * - [[any]]\n */\nvar ParamTypes = (function () {\n    /** @internalapi */\n    function ParamTypes() {\n        /** @hidden */\n        this.enqueue = true;\n        /** @hidden */\n        this.typeQueue = [];\n        /** @internalapi */\n        this.defaultTypes = common_1.pick(ParamTypes.prototype, [\"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\"]);\n        // Register default types. Store them in the prototype of this.types.\n        var makeType = function (definition, name) {\n            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        };\n        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n    }\n    /** @internalapi */\n    ParamTypes.prototype.dispose = function () {\n        this.types = {};\n    };\n    /**\n     * Registers a parameter type\n     *\n     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n     */\n    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n        if (!predicates_1.isDefined(definition))\n            return this.types[name];\n        if (this.types.hasOwnProperty(name))\n            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        if (definitionFn) {\n            this.typeQueue.push({ name: name, def: definitionFn });\n            if (!this.enqueue)\n                this._flushTypeQueue();\n        }\n        return this;\n    };\n    /** @internalapi */\n    ParamTypes.prototype._flushTypeQueue = function () {\n        while (this.typeQueue.length) {\n            var type = this.typeQueue.shift();\n            if (type.pattern)\n                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n        }\n    };\n    return ParamTypes;\n}());\nexports.ParamTypes = ParamTypes;\n/** @hidden */\nfunction initDefaultTypes() {\n    var makeDefaultType = function (def) {\n        var valToString = function (val) {\n            return val != null ? val.toString() : val;\n        };\n        var defaultTypeBase = {\n            encode: valToString,\n            decode: valToString,\n            is: hof_1.is(String),\n            pattern: /.*/,\n            equals: function (a, b) { return a == b; },\n        };\n        return common_1.extend({}, defaultTypeBase, def);\n    };\n    // Default Parameter Type Definitions\n    common_1.extend(ParamTypes.prototype, {\n        string: makeDefaultType({}),\n        path: makeDefaultType({\n            pattern: /[^/]*/,\n        }),\n        query: makeDefaultType({}),\n        hash: makeDefaultType({\n            inherit: false,\n        }),\n        int: makeDefaultType({\n            decode: function (val) { return parseInt(val, 10); },\n            is: function (val) {\n                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n            },\n            pattern: /-?\\d+/,\n        }),\n        bool: makeDefaultType({\n            encode: function (val) { return val && 1 || 0; },\n            decode: function (val) { return parseInt(val, 10) !== 0; },\n            is: hof_1.is(Boolean),\n            pattern: /0|1/\n        }),\n        date: makeDefaultType({\n            encode: function (val) {\n                return !this.is(val) ? undefined : [\n                    val.getFullYear(),\n                    ('0' + (val.getMonth() + 1)).slice(-2),\n                    ('0' + val.getDate()).slice(-2)\n                ].join(\"-\");\n            },\n            decode: function (val) {\n                if (this.is(val))\n                    return val;\n                var match = this.capture.exec(val);\n                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n            },\n            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n            equals: function (l, r) {\n                return ['getFullYear', 'getMonth', 'getDate']\n                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n            },\n            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n        }),\n        json: makeDefaultType({\n            encode: common_1.toJson,\n            decode: common_1.fromJson,\n            is: hof_1.is(Object),\n            equals: common_1.equals,\n            pattern: /[^/]*/\n        }),\n        // does not encode/decode\n        any: makeDefaultType({\n            encode: common_1.identity,\n            decode: common_1.identity,\n            is: function () { return true; },\n            equals: common_1.equals,\n        }),\n    });\n}\ninitDefaultTypes();\n//# sourceMappingURL=paramTypes.js.map\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(0);\n/** @internalapi */\nvar StateParams = (function () {\n    function StateParams(params) {\n        if (params === void 0) { params = {}; }\n        common_1.extend(this, params);\n    }\n    /**\n     * Merges a set of parameters with all parameters inherited between the common parents of the\n     * current state and a given destination state.\n     *\n     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n     * @param {Object} $current Internal definition of object representing the current state.\n     * @param {Object} $to Internal definition of object representing state to transition to.\n     */\n    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n        for (var i in parents) {\n            if (!parents[i] || !parents[i].params)\n                continue;\n            parentParams = Object.keys(parents[i].params);\n            if (!parentParams.length)\n                continue;\n            for (var j in parentParams) {\n                if (inheritList.indexOf(parentParams[j]) >= 0)\n                    continue;\n                inheritList.push(parentParams[j]);\n                inherited[parentParams[j]] = this[parentParams[j]];\n            }\n        }\n        return common_1.extend({}, inherited, newParams);\n    };\n    ;\n    return StateParams;\n}());\nexports.StateParams = StateParams;\n//# sourceMappingURL=stateParams.js.map\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @internalapi */\nexports.resolvePolicies = {\n    when: {\n        LAZY: \"LAZY\",\n        EAGER: \"EAGER\"\n    },\n    async: {\n        WAIT: \"WAIT\",\n        NOWAIT: \"NOWAIT\",\n        RXWAIT: \"RXWAIT\"\n    }\n};\n//# sourceMappingURL=interface.js.map\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */ /** */\nvar urlMatcherFactory_1 = __webpack_require__(46);\nvar urlRouter_1 = __webpack_require__(47);\nvar transitionService_1 = __webpack_require__(30);\nvar view_1 = __webpack_require__(57);\nvar stateRegistry_1 = __webpack_require__(42);\nvar stateService_1 = __webpack_require__(43);\nvar globals_1 = __webpack_require__(33);\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar urlService_1 = __webpack_require__(49);\nvar trace_1 = __webpack_require__(6);\n/** @hidden */\nvar _routerInstance = 0;\n/**\n * The master class used to instantiate an instance of UI-Router.\n *\n * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n * This class instantiates and wires the UI-Router services together.\n *\n * After a new instance of the UIRouter class is created, it should be configured for your app.\n * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n *\n * ---\n *\n * Normally the framework code will bootstrap UI-Router.\n * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n * [[UrlService.listen]] then [[UrlService.sync]].\n */\nvar UIRouter = (function () {\n    /**\n     * Creates a new `UIRouter` object\n     *\n     * @param locationService a [[LocationServices]] implementation\n     * @param locationConfig a [[LocationConfig]] implementation\n     * @internalapi\n     */\n    function UIRouter(locationService, locationConfig) {\n        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n        this.locationService = locationService;\n        this.locationConfig = locationConfig;\n        /** @hidden */ this.$id = _routerInstance++;\n        /** @hidden */ this._disposed = false;\n        /** @hidden */ this._disposables = [];\n        /** Provides trace information to the console */\n        this.trace = trace_1.trace;\n        /** Provides services related to ui-view synchronization */\n        this.viewService = new view_1.ViewService();\n        /** Provides services related to Transitions */\n        this.transitionService = new transitionService_1.TransitionService(this);\n        /** Global router state */\n        this.globals = new globals_1.UIRouterGlobals();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlRouter = new urlRouter_1.UrlRouter(this);\n        /** Provides a registry for states, and related registration services */\n        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n        /** Provides services related to states */\n        this.stateService = new stateService_1.StateService(this);\n        /** Provides services related to the URL */\n        this.urlService = new urlService_1.UrlService(this);\n        /** @hidden */\n        this._plugins = {};\n        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n        this.globals.$current = this.stateRegistry.root();\n        this.globals.current = this.globals.$current.self;\n        this.disposable(this.globals);\n        this.disposable(this.stateService);\n        this.disposable(this.stateRegistry);\n        this.disposable(this.transitionService);\n        this.disposable(this.urlRouter);\n        this.disposable(locationService);\n        this.disposable(locationConfig);\n    }\n    /** Registers an object to be notified when the router is disposed */\n    UIRouter.prototype.disposable = function (disposable) {\n        this._disposables.push(disposable);\n    };\n    /**\n     * Disposes this router instance\n     *\n     * When called, clears resources retained by the router by calling `dispose(this)` on all\n     * registered [[disposable]] objects.\n     *\n     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n     *\n     * @param disposable (optional) the disposable to dispose\n     */\n    UIRouter.prototype.dispose = function (disposable) {\n        var _this = this;\n        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n            disposable.dispose(this);\n            return undefined;\n        }\n        this._disposed = true;\n        this._disposables.slice().forEach(function (d) {\n            try {\n                typeof d.dispose === 'function' && d.dispose(_this);\n                common_1.removeFrom(_this._disposables, d);\n            }\n            catch (ignored) { }\n        });\n    };\n    /**\n     * Adds a plugin to UI-Router\n     *\n     * This method adds a UI-Router Plugin.\n     * A plugin can enhance or change UI-Router behavior using any public API.\n     *\n     * #### Example:\n     * ```js\n     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n     *\n     * var plugin = router.addPlugin(MyCoolPlugin);\n     * ```\n     *\n     * ### Plugin authoring\n     *\n     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n     *\n     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n     * For example, it may configure router options or add a Transition Hook.\n     *\n     * The plugin can then be published as a separate module.\n     *\n     * #### Example:\n     * ```js\n     * export class MyAuthPlugin implements UIRouterPlugin {\n     *   constructor(router: UIRouter, options: any) {\n     *     this.name = \"MyAuthPlugin\";\n     *     let $transitions = router.transitionService;\n     *     let $state = router.stateService;\n     *\n     *     let authCriteria = {\n     *       to: (state) => state.data && state.data.requiresAuth\n     *     };\n     *\n     *     function authHook(transition: Transition) {\n     *       let authService = transition.injector().get('AuthService');\n     *       if (!authService.isAuthenticated()) {\n     *         return $state.target('login');\n     *       }\n     *     }\n     *\n     *     $transitions.onStart(authCriteria, authHook);\n     *   }\n     * }\n     * ```\n     *\n     * @param plugin one of:\n     *        - a plugin class which implements [[UIRouterPlugin]]\n     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n     * @param options options to pass to the plugin class/factory\n     * @returns the registered plugin instance\n     */\n    UIRouter.prototype.plugin = function (plugin, options) {\n        if (options === void 0) { options = {}; }\n        var pluginInstance = new plugin(this, options);\n        if (!pluginInstance.name)\n            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n        this._disposables.push(pluginInstance);\n        return this._plugins[pluginInstance.name] = pluginInstance;\n    };\n    UIRouter.prototype.getPlugin = function (pluginName) {\n        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n    };\n    return UIRouter;\n}());\nexports.UIRouter = UIRouter;\n//# sourceMappingURL=router.js.map\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar strings_1 = __webpack_require__(5);\nvar hof_1 = __webpack_require__(2);\nvar resolvable_1 = __webpack_require__(11);\nvar coreservices_1 = __webpack_require__(3);\nvar parseUrl = function (url) {\n    if (!predicates_1.isString(url))\n        return false;\n    var root = url.charAt(0) === '^';\n    return { val: root ? url.substring(1) : url, root: root };\n};\nfunction nameBuilder(state) {\n    return state.name;\n}\nfunction selfBuilder(state) {\n    state.self.$$state = function () { return state; };\n    return state.self;\n}\nfunction dataBuilder(state) {\n    if (state.parent && state.parent.data) {\n        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n    }\n    return state.data;\n}\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n    return function urlBuilder(state) {\n        var stateDec = state;\n        // For future states, i.e., states whose name ends with `.**`,\n        // match anything that starts with the url prefix\n        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n        }\n        var parsed = parseUrl(stateDec.url), parent = state.parent;\n        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n            params: state.params || {},\n            paramMap: function (paramConfig, isSearch) {\n                if (stateDec.reloadOnSearch === false && isSearch)\n                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n                return paramConfig;\n            }\n        });\n        if (!url)\n            return null;\n        if (!$urlMatcherFactoryProvider.isMatcher(url))\n            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n    };\n};\nvar getNavigableBuilder = function (isRoot) {\n    return function navigableBuilder(state) {\n        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n    };\n};\nvar getParamsBuilder = function (paramFactory) {\n    return function paramsBuilder(state) {\n        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n    };\n};\nfunction pathBuilder(state) {\n    return state.parent ? state.parent.path.concat(state) : [state];\n}\nfunction includesBuilder(state) {\n    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n    includes[state.name] = true;\n    return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\nfunction resolvablesBuilder(state) {\n    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n    var objects2Tuples = function (resolveObj, resolvePolicies) {\n        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n    };\n    /** fetch DI annotations from a function or ng1-style array */\n    var annotate = function (fn) {\n        var $injector = coreservices_1.services.$injector;\n        // ng1 doesn't have an $injector until runtime.\n        // If the $injector doesn't exist, use \"deferred\" literal as a\n        // marker indicating they should be annotated when runtime starts\n        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n    };\n    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n    /** true if the object looks like a provide literal, or a ng2 Provider */\n    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n    /** true if the object looks like a tuple from obj2Tuples */\n    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n    /** extracts the token from a Provider or provide literal */\n    var token = function (p) { return p.provide || p.token; };\n    /** Given a literal resolve or provider object, returns a Resolvable */\n    var literal2Resolvable = hof_1.pattern([\n        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n    ]);\n    var tuple2Resolvable = hof_1.pattern([\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n    ]);\n    var item2Resolvable = hof_1.pattern([\n        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n        [isResolveLiteral, literal2Resolvable],\n        [isLikeNg2Provider, literal2Resolvable],\n        [isTupleFromObj, tuple2Resolvable],\n        [hof_1.val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + strings_1.stringify(obj)); }]\n    ]);\n    // If resolveBlock is already an array, use it as-is.\n    // Otherwise, assume it's an object and convert to an Array of tuples\n    var decl = state.resolve;\n    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n    return items.map(item2Resolvable);\n}\nexports.resolvablesBuilder = resolvablesBuilder;\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[StateObject]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[StateObject]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n * using the [[builder]] method.\n */\nvar StateBuilder = (function () {\n    function StateBuilder(matcher, urlMatcherFactory) {\n        this.matcher = matcher;\n        var self = this;\n        var root = function () { return matcher.find(\"\"); };\n        var isRoot = function (state) { return state.name === \"\"; };\n        function parentBuilder(state) {\n            if (isRoot(state))\n                return null;\n            return matcher.find(self.parentName(state)) || root();\n        }\n        this.builders = {\n            name: [nameBuilder],\n            self: [selfBuilder],\n            parent: [parentBuilder],\n            data: [dataBuilder],\n            // Build a URLMatcher if necessary, either via a relative or absolute URL\n            url: [getUrlBuilder(urlMatcherFactory, root)],\n            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n            navigable: [getNavigableBuilder(isRoot)],\n            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n            // Each framework-specific ui-router implementation should define its own `views` builder\n            // e.g., src/ng1/statebuilders/views.ts\n            views: [],\n            // Keep a full path from the root down to this state as this is needed for state activation.\n            path: [pathBuilder],\n            // Speed up $state.includes() as it's used a lot\n            includes: [includesBuilder],\n            resolvables: [resolvablesBuilder]\n        };\n    }\n    /**\n     * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n     * More than one BuilderFunction can be registered for a given property.\n     *\n     * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n     *\n     * @param name The name of the State property being registered for.\n     * @param fn The BuilderFunction which will be used to build the State property\n     * @returns a function which deregisters the BuilderFunction\n     */\n    StateBuilder.prototype.builder = function (name, fn) {\n        var builders = this.builders;\n        var array = builders[name] || [];\n        // Backwards compat: if only one builder exists, return it, else return whole arary.\n        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n            return array.length > 1 ? array : array[0];\n        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n            return;\n        builders[name] = array;\n        builders[name].push(fn);\n        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n    };\n    /**\n     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n     * properties and API built.\n     *\n     * @param state an uninitialized State object\n     * @returns the built State object\n     */\n    StateBuilder.prototype.build = function (state) {\n        var _a = this, matcher = _a.matcher, builders = _a.builders;\n        var parent = this.parentName(state);\n        if (parent && !matcher.find(parent, undefined, false)) {\n            return null;\n        }\n        for (var key in builders) {\n            if (!builders.hasOwnProperty(key))\n                continue;\n            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n            state[key] = chain(state);\n        }\n        return state;\n    };\n    StateBuilder.prototype.parentName = function (state) {\n        var name = state.name || \"\";\n        var segments = name.split('.');\n        if (segments.length > 1) {\n            if (state.parent) {\n                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n            }\n            var lastSegment = segments.pop();\n            if (lastSegment === '**')\n                segments.pop();\n            return segments.join(\".\");\n        }\n        if (!state.parent)\n            return \"\";\n        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n    };\n    StateBuilder.prototype.name = function (state) {\n        var name = state.name;\n        if (name.indexOf('.') !== -1 || !state.parent)\n            return name;\n        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n        return parentName ? parentName + \".\" + name : name;\n    };\n    return StateBuilder;\n}());\nexports.StateBuilder = StateBuilder;\n//# sourceMappingURL=stateBuilder.js.map\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar predicates_1 = __webpack_require__(1);\nvar common_1 = __webpack_require__(0);\nvar StateMatcher = (function () {\n    function StateMatcher(_states) {\n        this._states = _states;\n    }\n    StateMatcher.prototype.isRelative = function (stateName) {\n        stateName = stateName || \"\";\n        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n    };\n    StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {\n        if (matchGlob === void 0) { matchGlob = true; }\n        if (!stateOrName && stateOrName !== \"\")\n            return undefined;\n        var isStr = predicates_1.isString(stateOrName);\n        var name = isStr ? stateOrName : stateOrName.name;\n        if (this.isRelative(name))\n            name = this.resolvePath(name, base);\n        var state = this._states[name];\n        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n            return state;\n        }\n        else if (isStr && matchGlob) {\n            var _states = common_1.values(this._states);\n            var matches = _states.filter(function (state) {\n                return state.__stateObjectCache.nameGlob &&\n                    state.__stateObjectCache.nameGlob.matches(name);\n            });\n            if (matches.length > 1) {\n                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n            }\n            return matches[0];\n        }\n        return undefined;\n    };\n    StateMatcher.prototype.resolvePath = function (name, base) {\n        if (!base)\n            throw new Error(\"No reference point given for path '\" + name + \"'\");\n        var baseState = this.find(base);\n        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n        for (; i < pathLength; i++) {\n            if (splitName[i] === \"\" && i === 0) {\n                current = baseState;\n                continue;\n            }\n            if (splitName[i] === \"^\") {\n                if (!current.parent)\n                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n                current = current.parent;\n                continue;\n            }\n            break;\n        }\n        var relName = splitName.slice(i).join(\".\");\n        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n    };\n    return StateMatcher;\n}());\nexports.StateMatcher = StateMatcher;\n//# sourceMappingURL=stateMatcher.js.map\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar stateObject_1 = __webpack_require__(28);\nvar hof_1 = __webpack_require__(2);\n/** @internalapi */\nvar StateQueueManager = (function () {\n    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n        this.$registry = $registry;\n        this.$urlRouter = $urlRouter;\n        this.states = states;\n        this.builder = builder;\n        this.listeners = listeners;\n        this.queue = [];\n        this.matcher = $registry.matcher;\n    }\n    /** @internalapi */\n    StateQueueManager.prototype.dispose = function () {\n        this.queue = [];\n    };\n    StateQueueManager.prototype.register = function (stateDecl) {\n        var queue = this.queue;\n        var state = stateObject_1.StateObject.create(stateDecl);\n        var name = state.name;\n        if (!predicates_1.isString(name))\n            throw new Error(\"State must have a valid name\");\n        if (this.states.hasOwnProperty(name) || common_1.inArray(queue.map(hof_1.prop('name')), name))\n            throw new Error(\"State '\" + name + \"' is already defined\");\n        queue.push(state);\n        this.flush();\n        return state;\n    };\n    StateQueueManager.prototype.flush = function () {\n        var _this = this;\n        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n        var registered = [], // states that got registered\n        orphans = [], // states that don't yet have a parent registered\n        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n        var getState = function (name) {\n            return _this.states.hasOwnProperty(name) && _this.states[name];\n        };\n        while (queue.length > 0) {\n            var state = queue.shift();\n            var name_1 = state.name;\n            var result = builder.build(state);\n            var orphanIdx = orphans.indexOf(state);\n            if (result) {\n                var existingState = getState(name_1);\n                if (existingState && existingState.name === name_1) {\n                    throw new Error(\"State '\" + name_1 + \"' is already defined\");\n                }\n                var existingFutureState = getState(name_1 + \".**\");\n                if (existingFutureState) {\n                    // Remove future state of the same name\n                    this.$registry.deregister(existingFutureState);\n                }\n                states[name_1] = state;\n                this.attachRoute(state);\n                if (orphanIdx >= 0)\n                    orphans.splice(orphanIdx, 1);\n                registered.push(state);\n                continue;\n            }\n            var prev = previousQueueLength[name_1];\n            previousQueueLength[name_1] = queue.length;\n            if (orphanIdx >= 0 && prev === queue.length) {\n                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n                // throw new Error(`Cannot register orphaned state '${name}'`);\n                queue.push(state);\n                return states;\n            }\n            else if (orphanIdx < 0) {\n                orphans.push(state);\n            }\n            queue.push(state);\n        }\n        if (registered.length) {\n            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n        }\n        return states;\n    };\n    StateQueueManager.prototype.attachRoute = function (state) {\n        if (state.abstract || !state.url)\n            return;\n        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n    };\n    return StateQueueManager;\n}());\nexports.StateQueueManager = StateQueueManager;\n//# sourceMappingURL=stateQueueManager.js.map\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar stateMatcher_1 = __webpack_require__(40);\nvar stateBuilder_1 = __webpack_require__(39);\nvar stateQueueManager_1 = __webpack_require__(41);\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar StateRegistry = (function () {\n    /** @internalapi */\n    function StateRegistry(_router) {\n        this._router = _router;\n        this.states = {};\n        this.listeners = [];\n        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n        this._registerRoot();\n    }\n    /** @internalapi */\n    StateRegistry.prototype._registerRoot = function () {\n        var rootStateDef = {\n            name: '',\n            url: '^',\n            views: null,\n            params: {\n                '#': { value: null, type: 'hash', dynamic: true }\n            },\n            abstract: true\n        };\n        var _root = this._root = this.stateQueue.register(rootStateDef);\n        _root.navigable = null;\n    };\n    /** @internalapi */\n    StateRegistry.prototype.dispose = function () {\n        var _this = this;\n        this.stateQueue.dispose();\n        this.listeners = [];\n        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n    };\n    /**\n     * Listen for a State Registry events\n     *\n     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n     *\n     * #### Example:\n     * ```js\n     * let allStates = registry.get();\n     *\n     * // Later, invoke deregisterFn() to remove the listener\n     * let deregisterFn = registry.onStatesChanged((event, states) => {\n     *   switch(event) {\n     *     case: 'registered':\n     *       states.forEach(state => allStates.push(state));\n     *       break;\n     *     case: 'deregistered':\n     *       states.forEach(state => {\n     *         let idx = allStates.indexOf(state);\n     *         if (idx !== -1) allStates.splice(idx, 1);\n     *       });\n     *       break;\n     *   }\n     * });\n     * ```\n     *\n     * @param listener a callback function invoked when the registered states changes.\n     *        The function receives two parameters, `event` and `state`.\n     *        See [[StateRegistryListener]]\n     * @return a function that deregisters the listener\n     */\n    StateRegistry.prototype.onStatesChanged = function (listener) {\n        this.listeners.push(listener);\n        return function deregisterListener() {\n            common_1.removeFrom(this.listeners)(listener);\n        }.bind(this);\n    };\n    /**\n     * Gets the implicit root state\n     *\n     * Gets the root of the state tree.\n     * The root state is implicitly created by UI-Router.\n     * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]\n     *\n     * @return the root [[StateObject]]\n     */\n    StateRegistry.prototype.root = function () {\n        return this._root;\n    };\n    /**\n     * Adds a state to the registry\n     *\n     * Registers a [[StateDeclaration]] or queues it for registration.\n     *\n     * Note: a state will be queued if the state's parent isn't yet registered.\n     *\n     * @param stateDefinition the definition of the state to register.\n     * @returns the internal [[StateObject]] object.\n     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n     *          If the state was only queued, then the object is not fully built.\n     */\n    StateRegistry.prototype.register = function (stateDefinition) {\n        return this.stateQueue.register(stateDefinition);\n    };\n    /** @hidden */\n    StateRegistry.prototype._deregisterTree = function (state) {\n        var _this = this;\n        var all = this.get().map(function (s) { return s.$$state(); });\n        var getChildren = function (states) {\n            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n            return children.length === 0 ? children : children.concat(getChildren(children));\n        };\n        var children = getChildren([state]);\n        var deregistered = [state].concat(children).reverse();\n        deregistered.forEach(function (state) {\n            var $ur = _this._router.urlRouter;\n            // Remove URL rule\n            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n            // Remove state from registry\n            delete _this.states[state.name];\n        });\n        return deregistered;\n    };\n    /**\n     * Removes a state from the registry\n     *\n     * This removes a state from the registry.\n     * If the state has children, they are are also removed from the registry.\n     *\n     * @param stateOrName the state's name or object representation\n     * @returns {StateObject[]} a list of removed states\n     */\n    StateRegistry.prototype.deregister = function (stateOrName) {\n        var _state = this.get(stateOrName);\n        if (!_state)\n            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n        var deregisteredStates = this._deregisterTree(_state.$$state());\n        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n        return deregisteredStates;\n    };\n    StateRegistry.prototype.get = function (stateOrName, base) {\n        var _this = this;\n        if (arguments.length === 0)\n            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n        var found = this.matcher.find(stateOrName, base);\n        return found && found.self || null;\n    };\n    StateRegistry.prototype.decorator = function (name, func) {\n        return this.builder.builder(name, func);\n    };\n    return StateRegistry;\n}());\nexports.StateRegistry = StateRegistry;\n//# sourceMappingURL=stateRegistry.js.map\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module state\n */\n/** */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar queue_1 = __webpack_require__(25);\nvar coreservices_1 = __webpack_require__(3);\nvar pathFactory_1 = __webpack_require__(17);\nvar pathNode_1 = __webpack_require__(27);\nvar transitionService_1 = __webpack_require__(30);\nvar rejectFactory_1 = __webpack_require__(12);\nvar targetState_1 = __webpack_require__(7);\nvar param_1 = __webpack_require__(9);\nvar glob_1 = __webpack_require__(15);\nvar resolveContext_1 = __webpack_require__(18);\nvar lazyLoad_1 = __webpack_require__(34);\nvar hof_1 = __webpack_require__(2);\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\nvar StateService = (function () {\n    /** @internalapi */\n    function StateService(router) {\n        this.router = router;\n        /** @internalapi */\n        this.invalidCallbacks = [];\n        /** @hidden */\n        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n            if ($error$ instanceof Error && $error$.stack) {\n                console.error($error$);\n                console.error($error$.stack);\n            }\n            else if ($error$ instanceof rejectFactory_1.Rejection) {\n                console.error($error$.toString());\n                if ($error$.detail && $error$.detail.stack)\n                    console.error($error$.detail.stack);\n            }\n            else {\n                console.error($error$);\n            }\n        };\n        var getters = ['current', '$current', 'params', 'transition'];\n        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n    }\n    Object.defineProperty(StateService.prototype, \"transition\", {\n        /**\n         * The [[Transition]] currently in progress (or null)\n         *\n         * This is a passthrough through to [[UIRouterGlobals.transition]]\n         */\n        get: function () { return this.router.globals.transition; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"params\", {\n        /**\n         * The latest successful state parameters\n         *\n         * This is a passthrough through to [[UIRouterGlobals.params]]\n         */\n        get: function () { return this.router.globals.params; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"current\", {\n        /**\n         * The current [[StateDeclaration]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.current]]\n         */\n        get: function () { return this.router.globals.current; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"$current\", {\n        /**\n         * The current [[StateObject]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.$current]]\n         */\n        get: function () { return this.router.globals.$current; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internalapi */\n    StateService.prototype.dispose = function () {\n        this.defaultErrorHandler(common_1.noop);\n        this.invalidCallbacks = [];\n    };\n    /**\n     * Handler for when [[transitionTo]] is called with an invalid state.\n     *\n     * Invokes the [[onInvalid]] callbacks, in natural order.\n     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n     *\n     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n     *\n     * @internalapi\n     */\n    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n        var _this = this;\n        var fromState = pathFactory_1.PathUtils.makeTargetState(fromPath);\n        var globals = this.router.globals;\n        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n        var latest = latestThing();\n        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n        var checkForRedirect = function (result) {\n            if (!(result instanceof targetState_1.TargetState)) {\n                return;\n            }\n            var target = result;\n            // Recreate the TargetState, in case the state is now defined.\n            target = _this.target(target.identifier(), target.params(), target.options());\n            if (!target.valid()) {\n                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n            }\n            if (latestThing() !== latest) {\n                return rejectFactory_1.Rejection.superseded().toPromise();\n            }\n            return _this.transitionTo(target.identifier(), target.params(), target.options());\n        };\n        function invokeNextCallback() {\n            var nextCallback = callbackQueue.dequeue();\n            if (nextCallback === undefined)\n                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n        }\n        return invokeNextCallback();\n    };\n    /**\n     * Registers an Invalid State handler\n     *\n     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n     * has been called with an invalid state reference parameter\n     *\n     * Example:\n     * ```js\n     * stateService.onInvalid(function(to, from, injector) {\n     *   if (to.name() === 'foo') {\n     *     let lazyLoader = injector.get('LazyLoadService');\n     *     return lazyLoader.load('foo')\n     *         .then(() => stateService.target('foo'));\n     *   }\n     * });\n     * ```\n     *\n     * @param {function} callback invoked when the toState is invalid\n     *   This function receives the (invalid) toState, the fromState, and an injector.\n     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n     *   If one is returned, it is treated as a redirect.\n     *\n     * @returns a function which deregisters the callback\n     */\n    StateService.prototype.onInvalid = function (callback) {\n        this.invalidCallbacks.push(callback);\n        return function deregisterListener() {\n            common_1.removeFrom(this.invalidCallbacks)(callback);\n        }.bind(this);\n    };\n    /**\n     * Reloads the current state\n     *\n     * A method that force reloads the current state, or a partial state hierarchy.\n     * All resolves are re-resolved, and components reinstantiated.\n     *\n     * #### Example:\n     * ```js\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * ```\n     *\n     * Note: `reload()` is just an alias for:\n     *\n     * ```js\n     * $state.transitionTo($state.current, $state.params, {\n     *   reload: true, inherit: false\n     * });\n     * ```\n     *\n     * @param reloadState A state name or a state object.\n     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n     *\n     * #### Example:\n     * ```js\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n     * //and current state is 'contacts.detail.item'\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * ```\n     *\n     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n     */\n    StateService.prototype.reload = function (reloadState) {\n        return this.transitionTo(this.current, this.params, {\n            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n            inherit: false,\n            notify: false,\n        });\n    };\n    ;\n    /**\n     * Transition to a different state and/or parameters\n     *\n     * Convenience method for transitioning to a new state.\n     *\n     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n     * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.\n     * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).\n     * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters\n     * inherit from the current parameter values (because of `inherit: true`).\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to Absolute state name, state object, or relative state path (relative to current state).\n     *\n     * Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to the parent state\n     * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state\n     * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state\n     *\n     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n     *\n     *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).\n     *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.\n     *\n     * @param options Transition options\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     */\n    StateService.prototype.go = function (to, params, options) {\n        var defautGoOpts = { relative: this.$current, inherit: true };\n        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n        return this.transitionTo(to, params, transOpts);\n    };\n    ;\n    /**\n     * Creates a [[TargetState]]\n     *\n     * This is a factory method for creating a TargetState\n     *\n     * This may be returned from a Transition Hook to redirect a transition, for example.\n     */\n    StateService.prototype.target = function (identifier, params, options) {\n        if (options === void 0) { options = {}; }\n        // If we're reloading, find the state object to reload from\n        if (predicates_1.isObject(options.reload) && !options.reload.name)\n            throw new Error('Invalid reload state object');\n        var reg = this.router.stateRegistry;\n        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n        if (options.reload && !options.reloadState)\n            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        var stateDefinition = reg.matcher.find(identifier, options.relative);\n        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n    };\n    ;\n    StateService.prototype.getCurrentPath = function () {\n        var _this = this;\n        var globals = this.router.globals;\n        var latestSuccess = globals.successfulTransitions.peekTail();\n        var rootPath = function () { return [new pathNode_1.PathNode(_this.router.stateRegistry.root())]; };\n        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n    };\n    /**\n     * Low-level method for transitioning to a new state.\n     *\n     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to State name or state object.\n     * @param toParams A map of the parameters that will be sent to the state,\n     *      will populate $stateParams.\n     * @param options Transition options\n     *\n     * @returns A promise representing the state of the new transition. See [[go]]\n     */\n    StateService.prototype.transitionTo = function (to, toParams, options) {\n        var _this = this;\n        if (toParams === void 0) { toParams = {}; }\n        if (options === void 0) { options = {}; }\n        var router = this.router;\n        var globals = router.globals;\n        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n        var getCurrent = function () {\n            return globals.transition;\n        };\n        options = common_1.extend(options, { current: getCurrent });\n        var ref = this.target(to, toParams, options);\n        var currentPath = this.getCurrentPath();\n        if (!ref.exists())\n            return this._handleInvalidTargetState(currentPath, ref);\n        if (!ref.valid())\n            return common_1.silentRejection(ref.error());\n        /**\n         * Special handling for Ignored, Aborted, and Redirected transitions\n         *\n         * The semantics for the transition.run() promise and the StateService.transitionTo()\n         * promise differ. For instance, the run() promise may be rejected because it was\n         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n         */\n        var rejectedTransitionHandler = function (transition) { return function (error) {\n            if (error instanceof rejectFactory_1.Rejection) {\n                var isLatest = router.globals.lastStartedTransitionId === transition.$id;\n                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n                    isLatest && router.urlRouter.update();\n                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n                    return coreservices_1.services.$q.when(globals.current);\n                }\n                var detail = error.detail;\n                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n                    // by returning the promise for the new (redirect) `Transition.run()`.\n                    var redirect = transition.redirect(detail);\n                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n                }\n                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n                    isLatest && router.urlRouter.update();\n                    return coreservices_1.services.$q.reject(error);\n                }\n            }\n            var errorHandler = _this.defaultErrorHandler();\n            errorHandler(error);\n            return coreservices_1.services.$q.reject(error);\n        }; };\n        var transition = this.router.transitionService.create(currentPath, ref);\n        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n        // Return a promise for the transition, which also has the transition object on it.\n        return common_1.extend(transitionToPromise, { transition: transition });\n    };\n    ;\n    /**\n     * Checks if the current state *is* the provided state\n     *\n     * Similar to [[includes]] but only checks for the full state name.\n     * If params is supplied then it will be tested for strict equality against the current\n     * active params object, so all params must match with none missing and no extras.\n     *\n     * #### Example:\n     * ```js\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     * ```\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * ```html\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * ```\n     *\n     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns Returns true if it is the state.\n     */\n    StateService.prototype.is = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (this.$current !== state)\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Checks if the current state *includes* the provided state\n     *\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * #### Example when `$state.$current.name === 'contacts.details.item'`\n     * ```js\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     * ```\n     *\n     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n     * ```js\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * ```\n     *\n     * @param stateOrName A partial name, relative name, glob pattern,\n     *   or state object to be searched for within the current state name.\n     * @param params A param object, e.g. `{sectionId: section.id}`,\n     *   that you'd like to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    StateService.prototype.includes = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n        if (glob) {\n            if (!glob.matches(this.$current.name))\n                return false;\n            stateOrName = this.$current.name;\n        }\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (!predicates_1.isDefined(include[state.name]))\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Generates a URL for a state and parameters\n     *\n     * Returns the url for the given state populated with the given params.\n     *\n     * #### Example:\n     * ```js\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * ```\n     *\n     * @param stateOrName The state name or state object you'd like to generate a url from.\n     * @param params An object of parameter values to fill the state's required parameters.\n     * @param options Options object. The options are:\n     *\n     * @returns {string} compiled state url\n     */\n    StateService.prototype.href = function (stateOrName, params, options) {\n        var defaultHrefOpts = {\n            lossy: true,\n            inherit: true,\n            absolute: false,\n            relative: this.$current,\n        };\n        options = common_1.defaults(options, defaultHrefOpts);\n        params = params || {};\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return null;\n        if (options.inherit)\n            params = this.params.$inherit(params, this.$current, state);\n        var nav = (state && options.lossy) ? state.navigable : state;\n        if (!nav || nav.url === undefined || nav.url === null) {\n            return null;\n        }\n        return this.router.urlRouter.href(nav.url, params, {\n            absolute: options.absolute,\n        });\n    };\n    ;\n    /**\n     * Sets or gets the default [[transitionTo]] error handler.\n     *\n     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n     * This includes errors caused by resolves and transition hooks.\n     *\n     * Note:\n     * This handler does not receive certain Transition rejections.\n     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n     *\n     * The built-in default error handler logs the error to the console.\n     *\n     * You can provide your own custom handler.\n     *\n     * #### Example:\n     * ```js\n     * stateService.defaultErrorHandler(function() {\n     *   // Do not log transitionTo errors\n     * });\n     * ```\n     *\n     * @param handler a global error handler function\n     * @returns the current global error handler\n     */\n    StateService.prototype.defaultErrorHandler = function (handler) {\n        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n    };\n    StateService.prototype.get = function (stateOrName, base) {\n        var reg = this.router.stateRegistry;\n        if (arguments.length === 0)\n            return reg.get();\n        return reg.get(stateOrName, base || this.$current);\n    };\n    /**\n     * Lazy loads a state\n     *\n     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n     *\n     * @param stateOrName the state that should be lazy loaded\n     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n     * This noop transition is not actually run.\n     *\n     * @returns a promise to lazy load\n     */\n    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n        var state = this.get(stateOrName);\n        if (!state || !state.lazyLoad)\n            throw new Error(\"Can not lazy load \" + stateOrName);\n        var currentPath = this.getCurrentPath();\n        var target = pathFactory_1.PathUtils.makeTargetState(currentPath);\n        transition = transition || this.router.transitionService.create(currentPath, target);\n        return lazyLoad_1.lazyLoadState(transition, state);\n    };\n    return StateService;\n}());\nexports.StateService = StateService;\n//# sourceMappingURL=stateService.js.map\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar interface_1 = __webpack_require__(10);\nvar transitionHook_1 = __webpack_require__(13);\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nvar HookBuilder = (function () {\n    function HookBuilder(transition) {\n        this.transition = transition;\n    }\n    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n        var _this = this;\n        var $transitions = this.transition.router.transitionService;\n        return $transitions._pluginapi._getEvents(phase)\n            .map(function (type) { return _this.buildHooks(type); })\n            .reduce(common_1.unnestR, [])\n            .filter(common_1.identity);\n    };\n    /**\n     * Returns an array of newly built TransitionHook objects.\n     *\n     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n     * - For each of the [[PathNode]]s, creates a TransitionHook\n     *\n     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n     */\n    HookBuilder.prototype.buildHooks = function (hookType) {\n        var transition = this.transition;\n        var treeChanges = transition.treeChanges();\n        // Find all the matching registered hooks for a given hook type\n        var matchingHooks = this.getMatchingHooks(hookType, treeChanges);\n        if (!matchingHooks)\n            return [];\n        var baseHookOptions = {\n            transition: transition,\n            current: transition.options().current\n        };\n        var makeTransitionHooks = function (hook) {\n            // Fetch the Nodes that caused this hook to match.\n            var matches = hook.matches(treeChanges);\n            // Select the PathNode[] that will be used as TransitionHook context objects\n            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n            // Return an array of HookTuples\n            return matchingNodes.map(function (node) {\n                var _options = common_1.extend({\n                    bind: hook.bind,\n                    traceData: { hookType: hookType.name, context: node }\n                }, baseHookOptions);\n                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state.self : null;\n                var transitionHook = new transitionHook_1.TransitionHook(transition, state, hook, _options);\n                return { hook: hook, node: node, transitionHook: transitionHook };\n            });\n        };\n        return matchingHooks.map(makeTransitionHooks)\n            .reduce(common_1.unnestR, [])\n            .sort(tupleSort(hookType.reverseSort))\n            .map(function (tuple) { return tuple.transitionHook; });\n    };\n    /**\n     * Finds all RegisteredHooks from:\n     * - The Transition object instance hook registry\n     * - The TransitionService ($transitions) global hook registry\n     *\n     * which matched:\n     * - the eventType\n     * - the matchCriteria (to, from, exiting, retained, entering)\n     *\n     * @returns an array of matched [[RegisteredHook]]s\n     */\n    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n        // Instance and Global hook registries\n        var $transitions = this.transition.router.transitionService;\n        var registries = isCreate ? [$transitions] : [this.transition, $transitions];\n        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n    };\n    return HookBuilder;\n}());\nexports.HookBuilder = HookBuilder;\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort) {\n    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n    return function nodeDepthThenPriority(l, r) {\n        var factor = reverseDepthSort ? -1 : 1;\n        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n    };\n}\n//# sourceMappingURL=hookBuilder.js.map\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar transitionHook_1 = __webpack_require__(13);\n/**\n * This class defines a type of hook, such as `onBefore` or `onEnter`.\n * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n *\n * @interalapi\n */\nvar TransitionEventType = (function () {\n    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        this.name = name;\n        this.hookPhase = hookPhase;\n        this.hookOrder = hookOrder;\n        this.criteriaMatchPath = criteriaMatchPath;\n        this.reverseSort = reverseSort;\n        this.getResultHandler = getResultHandler;\n        this.getErrorHandler = getErrorHandler;\n        this.synchronous = synchronous;\n    }\n    return TransitionEventType;\n}());\nexports.TransitionEventType = TransitionEventType;\n//# sourceMappingURL=transitionEventType.js.map\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module url\n */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar urlMatcher_1 = __webpack_require__(20);\nvar param_1 = __webpack_require__(9);\nvar paramTypes_1 = __webpack_require__(35);\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\nvar UrlMatcherFactory = (function () {\n    function UrlMatcherFactory() {\n        var _this = this;\n        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n        /** @hidden */ this._isCaseInsensitive = false;\n        /** @hidden */ this._isStrictMode = true;\n        /** @hidden */ this._defaultSquashPolicy = false;\n        /** @hidden */\n        this._getConfig = function (config) {\n            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n        };\n        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n        this.paramFactory = {\n            /** Creates a new [[Param]] from a CONFIG block */\n            fromConfig: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n            },\n            /** Creates a new [[Param]] from a url PATH */\n            fromPath: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n            },\n            /** Creates a new [[Param]] from a url SEARCH */\n            fromSearch: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n            },\n        };\n        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n    }\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.strictMode = function (value) {\n        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n    };\n    /**\n     * Creates a [[UrlMatcher]] for the specified pattern.\n     *\n     * @param pattern  The URL pattern.\n     * @param config  The config object hash.\n     * @returns The UrlMatcher.\n     */\n    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n    };\n    /**\n     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n     *\n     * @param object  The object to perform the type check against.\n     * @returns `true` if the object matches the `UrlMatcher` interface, by\n     *          implementing all the same methods.\n     */\n    UrlMatcherFactory.prototype.isMatcher = function (object) {\n        // TODO: typeof?\n        if (!predicates_1.isObject(object))\n            return false;\n        var result = true;\n        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n            if (predicates_1.isFunction(val))\n                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n        });\n        return result;\n    };\n    ;\n    /**\n     * Creates and registers a custom [[ParamType]] object\n     *\n     * A [[ParamType]] can be used to generate URLs with typed parameters.\n     *\n     * @param name  The type name.\n     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n     * @param definitionFn A function that is injected before the app runtime starts.\n     *        The result of this function should be a [[ParamTypeDefinition]].\n     *        The result is merged into the existing `definition`.\n     *        See [[ParamType]] for information on the values accepted.\n     *\n     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n     *\n     * Note: Register custom types *before using them* in a state definition.\n     *\n     * See [[ParamTypeDefinition]] for examples\n     */\n    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n        var type = this.paramTypes.type(name, definition, definitionFn);\n        return !predicates_1.isDefined(definition) ? type : this;\n    };\n    ;\n    /** @hidden */\n    UrlMatcherFactory.prototype.$get = function () {\n        this.paramTypes.enqueue = false;\n        this.paramTypes._flushTypeQueue();\n        return this;\n    };\n    ;\n    /** @internalapi */\n    UrlMatcherFactory.prototype.dispose = function () {\n        this.paramTypes.dispose();\n    };\n    return UrlMatcherFactory;\n}());\nexports.UrlMatcherFactory = UrlMatcherFactory;\n//# sourceMappingURL=urlMatcherFactory.js.map\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar urlMatcher_1 = __webpack_require__(20);\nvar hof_1 = __webpack_require__(2);\nvar urlRule_1 = __webpack_require__(48);\nvar targetState_1 = __webpack_require__(7);\n/** @hidden */\nfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n    if (baseHref === '/')\n        return url;\n    if (isHtml5)\n        return baseHref.slice(0, -1) + url;\n    if (absolute)\n        return baseHref.slice(1) + url;\n    return url;\n}\n/** @hidden */\nvar getMatcher = hof_1.prop(\"urlMatcher\");\n/**\n * Default rule priority sorting function.\n *\n * Sorts rules by:\n *\n * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n * - Registration order (for rule types other than STATE and URLMATCHER)\n *\n * @coreapi\n */\nvar defaultRuleSortFn;\ndefaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop(\"priority\"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop(\"type\"), function (type) { return ({ \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop(\"$id\"), common_1.inArray([\"REGEXP\", \"RAW\", \"OTHER\"])));\n/**\n * Updates URL and responds to URL changes\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class updates the URL when the state changes.\n * It also responds to changes in the URL.\n */\nvar UrlRouter = (function () {\n    /** @hidden */\n    function UrlRouter(router) {\n        /** @hidden */ this._sortFn = defaultRuleSortFn;\n        /** @hidden */ this._rules = [];\n        /** @hidden */ this.interceptDeferred = false;\n        /** @hidden */ this._id = 0;\n        /** @hidden */ this._sorted = false;\n        this._router = router;\n        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n    }\n    /** @internalapi */\n    UrlRouter.prototype.dispose = function () {\n        this.listen(false);\n        this._rules = [];\n        delete this._otherwiseFn;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sort = function (compareFn) {\n        this._rules.sort(this._sortFn = compareFn || this._sortFn);\n        this._sorted = true;\n    };\n    UrlRouter.prototype.ensureSorted = function () {\n        this._sorted || this.sort();\n    };\n    /**\n     * Given a URL, check all rules and return the best [[MatchResult]]\n     * @param url\n     * @returns {MatchResult}\n     */\n    UrlRouter.prototype.match = function (url) {\n        var _this = this;\n        this.ensureSorted();\n        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n        var rules = this.rules();\n        if (this._otherwiseFn)\n            rules.push(this._otherwiseFn);\n        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n        var checkRule = function (rule) {\n            var match = rule.match(url, _this._router);\n            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n        };\n        // The rules are pre-sorted.\n        // - Find the first matching rule.\n        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n        // - Choose the rule with the highest match weight.\n        var best;\n        for (var i = 0; i < rules.length; i++) {\n            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n            if (best && this._sortFn(rules[i], best.rule) !== 0)\n                break;\n            var current = checkRule(rules[i]);\n            // Pick the best MatchResult\n            best = (!best || current && current.weight > best.weight) ? current : best;\n        }\n        return best;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sync = function (evt) {\n        if (evt && evt.defaultPrevented)\n            return;\n        var router = this._router, $url = router.urlService, $state = router.stateService;\n        var url = {\n            path: $url.path(), search: $url.search(), hash: $url.hash(),\n        };\n        var best = this.match(url);\n        var applyResult = hof_1.pattern([\n            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n        ]);\n        applyResult(best && best.rule.handler(best.match, url, router));\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.listen = function (enabled) {\n        var _this = this;\n        if (enabled === false) {\n            this._stopFn && this._stopFn();\n            delete this._stopFn;\n        }\n        else {\n            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n        }\n    };\n    /**\n     * Internal API.\n     * @internalapi\n     */\n    UrlRouter.prototype.update = function (read) {\n        var $url = this._router.locationService;\n        if (read) {\n            this.location = $url.path();\n            return;\n        }\n        if ($url.path() === this.location)\n            return;\n        $url.url(this.location, true);\n    };\n    /**\n     * Internal API.\n     *\n     * Pushes a new location to the browser history.\n     *\n     * @internalapi\n     * @param urlMatcher\n     * @param params\n     * @param options\n     */\n    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n        var replace = options && !!options.replace;\n        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n    };\n    /**\n     * Builds and returns a URL with interpolated parameters\n     *\n     * #### Example:\n     * ```js\n     * matcher = $umf.compile(\"/about/:person\");\n     * params = { person: \"bob\" };\n     * $bob = $urlRouter.href(matcher, params);\n     * // $bob == \"/about/bob\";\n     * ```\n     *\n     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n     * @param params An object of parameter values to fill the matcher's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n     */\n    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n        var url = urlMatcher.format(params);\n        if (url == null)\n            return null;\n        options = options || { absolute: false };\n        var cfg = this._router.urlService.config;\n        var isHtml5 = cfg.html5Mode();\n        if (!isHtml5 && url !== null) {\n            url = \"#\" + cfg.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n        if (!options.absolute || !url) {\n            return url;\n        }\n        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n    };\n    /**\n     * Manually adds a URL Rule.\n     *\n     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n     *\n     * A rule should have a `match` function which returns truthy if the rule matched.\n     * It should also have a `handler` function which is invoked if the rule is the best match.\n     *\n     * @return a function that deregisters the rule\n     */\n    UrlRouter.prototype.rule = function (rule) {\n        var _this = this;\n        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n            throw new Error(\"invalid rule\");\n        rule.$id = this._id++;\n        rule.priority = rule.priority || 0;\n        this._rules.push(rule);\n        this._sorted = false;\n        return function () { return _this.removeRule(rule); };\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.removeRule = function (rule) {\n        common_1.removeFrom(this._rules, rule);\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.rules = function () {\n        this.ensureSorted();\n        return this._rules.slice();\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.otherwise = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n        this._sorted = false;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.initial = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        var matchFn = function (urlParts, router) {\n            return router.globals.transitionHistory.size() === 0 && !!/^\\/?$/.exec(urlParts.path);\n        };\n        this.rule(this.urlRuleFactory.create(matchFn, handlerFn));\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.when = function (matcher, handler, options) {\n        var rule = this.urlRuleFactory.create(matcher, handler);\n        if (predicates_1.isDefined(options && options.priority))\n            rule.priority = options.priority;\n        this.rule(rule);\n        return rule;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.deferIntercept = function (defer) {\n        if (defer === undefined)\n            defer = true;\n        this.interceptDeferred = defer;\n    };\n    ;\n    return UrlRouter;\n}());\nexports.UrlRouter = UrlRouter;\nfunction getHandlerFn(handler) {\n    if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n        throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n    }\n    return predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n}\n//# sourceMappingURL=urlRouter.js.map\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module url\n */ /** */\nvar urlMatcher_1 = __webpack_require__(20);\nvar predicates_1 = __webpack_require__(1);\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n * @internalapi\n */\nvar UrlRuleFactory = (function () {\n    function UrlRuleFactory(router) {\n        this.router = router;\n    }\n    UrlRuleFactory.prototype.compile = function (str) {\n        return this.router.urlMatcherFactory.compile(str);\n    };\n    UrlRuleFactory.prototype.create = function (what, handler) {\n        var _this = this;\n        var makeRule = hof_1.pattern([\n            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n            [predicates_1.isState, function (_what) { return _this.fromState(_what, _this.router); }],\n            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n        ]);\n        var rule = makeRule(what);\n        if (!rule)\n            throw new Error(\"invalid 'what' in when()\");\n        return rule;\n    };\n    /**\n     * A UrlRule which matches based on a UrlMatcher\n     *\n     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     *\n     * ## Handler as UrlMatcher\n     *\n     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n     * The url is replaced with the result.\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n        var _handler = handler;\n        if (predicates_1.isString(handler))\n            handler = this.router.urlMatcherFactory.compile(handler);\n        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n            _handler = function (match) { return handler.format(match); };\n        function match(url) {\n            var match = urlMatcher.exec(url.path, url.search, url.hash);\n            return urlMatcher.validates(match) && match;\n        }\n        // Prioritize URLs, lowest to highest:\n        // - Some optional URL parameters, but none matched\n        // - No optional parameters in URL\n        // - Some optional parameters, some matched\n        // - Some optional parameters, all matched\n        function matchPriority(params) {\n            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n            if (!optional.length)\n                return 0.000001;\n            var matched = optional.filter(function (param) { return params[param.id]; });\n            return matched.length / optional.length;\n        }\n        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    /**\n     * A UrlRule which matches a state by its url\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromState($state.get('foo'), router);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match);\n     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n     * ```\n     */\n    UrlRuleFactory.prototype.fromState = function (state, router) {\n        /**\n         * Handles match by transitioning to matched state\n         *\n         * First checks if the router should start a new transition.\n         * A new transition is not required if the current state's URL\n         * and the new URL are already identical\n         */\n        var handler = function (match) {\n            var $state = router.stateService;\n            var globals = router.globals;\n            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n            }\n        };\n        var details = { state: state, type: \"STATE\" };\n        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n    };\n    /**\n     * A UrlRule which matches based on a regular expression\n     *\n     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - regexp match array (from `regexp`)\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     *\n     * ## Handler as string\n     *\n     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n     * The string is first interpolated using `string.replace()` style pattern.\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n        if (regexp.global || regexp.sticky)\n            throw new Error(\"Rule RegExp must not be global or sticky\");\n        /**\n         * If handler is a string, the url will be replaced by the string.\n         * If the string has any String.replace() style variables in it (like `$2`),\n         * they will be replaced by the captures from [[match]]\n         */\n        var redirectUrlTo = function (match) {\n            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n                return match[what === '$' ? 0 : Number(what)];\n            });\n        };\n        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n        var match = function (url) {\n            return regexp.exec(url.path);\n        };\n        var details = { regexp: regexp, type: \"REGEXP\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    return UrlRuleFactory;\n}());\nUrlRuleFactory.isUrlRule = function (obj) {\n    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n};\nexports.UrlRuleFactory = UrlRuleFactory;\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nvar BaseUrlRule = (function () {\n    function BaseUrlRule(match, handler) {\n        var _this = this;\n        this.match = match;\n        this.type = \"RAW\";\n        this.matchPriority = function (match) { return 0 - _this.$id; };\n        this.handler = handler || common_1.identity;\n    }\n    return BaseUrlRule;\n}());\nexports.BaseUrlRule = BaseUrlRule;\n//# sourceMappingURL=urlRule.js.map\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @coreapi\n * @module url\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar coreservices_1 = __webpack_require__(3);\nvar common_1 = __webpack_require__(0);\n/** @hidden */\nvar makeStub = function (keys) {\n    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n};\n/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n/** @hidden */ var rulesFns = [\"sort\", \"when\", \"initial\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n/**\n * API for URL management\n */\nvar UrlService = (function () {\n    /** @hidden */\n    function UrlService(router, lateBind) {\n        if (lateBind === void 0) { lateBind = true; }\n        this.router = router;\n        this.rules = {};\n        this.config = {};\n        // proxy function calls from UrlService to the LocationService/LocationConfig\n        var locationServices = function () { return router.locationService; };\n        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n        var locationConfig = function () { return router.locationConfig; };\n        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n        var umf = function () { return router.urlMatcherFactory; };\n        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n        var urlRouter = function () { return router.urlRouter; };\n        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n    }\n    UrlService.prototype.url = function (newurl, replace, state) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.path = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.search = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.hash = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.onChange = function (callback) { return; };\n    ;\n    /**\n     * Returns the current URL parts\n     *\n     * This method returns the current URL components as a [[UrlParts]] object.\n     *\n     * @returns the current url parts\n     */\n    UrlService.prototype.parts = function () {\n        return { path: this.path(), search: this.search(), hash: this.hash() };\n    };\n    UrlService.prototype.dispose = function () { };\n    /** @inheritdoc */\n    UrlService.prototype.sync = function (evt) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.listen = function (enabled) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.deferIntercept = function (defer) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.match = function (urlParts) { return; };\n    return UrlService;\n}());\n/** @hidden */\nUrlService.locationServiceStub = makeStub(locationServicesFns);\n/** @hidden */\nUrlService.locationConfigStub = makeStub(locationConfigFns);\nexports.UrlService = UrlService;\n//# sourceMappingURL=urlService.js.map\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar predicates_1 = __webpack_require__(1);\n/** A `LocationConfig` that delegates to the browser's `location` object */\nvar BrowserLocationConfig = (function () {\n    function BrowserLocationConfig(router, _isHtml5) {\n        if (_isHtml5 === void 0) { _isHtml5 = false; }\n        this._isHtml5 = _isHtml5;\n        this._baseHref = undefined;\n        this._hashPrefix = \"\";\n    }\n    BrowserLocationConfig.prototype.port = function () {\n        if (location.port) {\n            return Number(location.port);\n        }\n        return this.protocol() === 'https' ? 443 : 80;\n    };\n    BrowserLocationConfig.prototype.protocol = function () {\n        return location.protocol.replace(/:/g, '');\n    };\n    BrowserLocationConfig.prototype.host = function () {\n        return location.host;\n    };\n    BrowserLocationConfig.prototype.html5Mode = function () {\n        return this._isHtml5;\n    };\n    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n    };\n    ;\n    BrowserLocationConfig.prototype.baseHref = function (href) {\n        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n    };\n    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n        var baseTags = document.getElementsByTagName(\"base\");\n        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n    };\n    BrowserLocationConfig.prototype.dispose = function () { };\n    return BrowserLocationConfig;\n}());\nexports.BrowserLocationConfig = BrowserLocationConfig;\n//# sourceMappingURL=browserLocationConfig.js.map\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar utils_1 = __webpack_require__(14);\nvar baseLocationService_1 = __webpack_require__(21);\n/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\nvar HashLocationService = (function (_super) {\n    __extends(HashLocationService, _super);\n    function HashLocationService(router) {\n        var _this = _super.call(this, router, false) || this;\n        window.addEventListener('hashchange', _this._listener, false);\n        return _this;\n    }\n    HashLocationService.prototype._get = function () {\n        return utils_1.trimHashVal(this._location.hash);\n    };\n    HashLocationService.prototype._set = function (state, title, url, replace) {\n        this._location.hash = url;\n    };\n    HashLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener('hashchange', this._listener);\n    };\n    return HashLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.HashLocationService = HashLocationService;\n//# sourceMappingURL=hashLocationService.js.map\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = __webpack_require__(16);\n// globally available injectables\nvar globals = {};\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nexports.$injector = {\n    /** Gets an object from DI based on a string token */\n    get: function (name) { return globals[name]; },\n    /** Returns true if an object named `name` exists in global DI */\n    has: function (name) { return exports.$injector.get(name) != null; },\n    /**\n     * Injects a function\n     *\n     * @param fn the function to inject\n     * @param context the function's `this` binding\n     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n     */\n    invoke: function (fn, context, locals) {\n        var all = index_1.extend({}, globals, locals || {});\n        var params = exports.$injector.annotate(fn);\n        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n        if (index_1.isFunction(fn))\n            return fn.apply(context, args);\n        else\n            return fn.slice(-1)[0].apply(context, args);\n    },\n    /**\n     * Returns a function's dependencies\n     *\n     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n     * @return an array of `string`s\n     */\n    annotate: function (fn) {\n        if (!index_1.isInjectable(fn))\n            throw new Error(\"Not an injectable function: \" + fn);\n        if (fn && fn.$inject)\n            return fn.$inject;\n        if (index_1.isArray(fn))\n            return fn.slice(0, -1);\n        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n        return result || [];\n    }\n};\n//# sourceMappingURL=injector.js.map\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar predicates_1 = __webpack_require__(1);\nvar common_1 = __webpack_require__(0);\n/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\nvar MemoryLocationConfig = (function () {\n    function MemoryLocationConfig() {\n        var _this = this;\n        this._baseHref = '';\n        this._port = 80;\n        this._protocol = \"http\";\n        this._host = \"localhost\";\n        this._hashPrefix = \"\";\n        this.port = function () { return _this._port; };\n        this.protocol = function () { return _this._protocol; };\n        this.host = function () { return _this._host; };\n        this.baseHref = function () { return _this._baseHref; };\n        this.html5Mode = function () { return false; };\n        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n        this.dispose = common_1.noop;\n    }\n    return MemoryLocationConfig;\n}());\nexports.MemoryLocationConfig = MemoryLocationConfig;\n//# sourceMappingURL=memoryLocationConfig.js.map\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar baseLocationService_1 = __webpack_require__(21);\n/** A `LocationServices` that gets/sets the current location from an in-memory object */\nvar MemoryLocationService = (function (_super) {\n    __extends(MemoryLocationService, _super);\n    function MemoryLocationService(router) {\n        return _super.call(this, router, true) || this;\n    }\n    MemoryLocationService.prototype._get = function () {\n        return this._url;\n    };\n    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n        this._url = url;\n    };\n    return MemoryLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.MemoryLocationService = MemoryLocationService;\n//# sourceMappingURL=memoryLocationService.js.map\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = __webpack_require__(14);\nvar baseLocationService_1 = __webpack_require__(21);\n/**\n * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n *\n * Uses `history.pushState` and `history.replaceState`\n */\nvar PushStateLocationService = (function (_super) {\n    __extends(PushStateLocationService, _super);\n    function PushStateLocationService(router) {\n        var _this = _super.call(this, router, true) || this;\n        _this._config = router.urlService.config;\n        window.addEventListener(\"popstate\", _this._listener, false);\n        return _this;\n    }\n    ;\n    PushStateLocationService.prototype._get = function () {\n        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n        search = utils_1.splitQuery(search)[1]; // strip ? if found\n        hash = utils_1.splitHash(hash)[1]; // strip # if found\n        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n    };\n    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n        var _a = this, _config = _a._config, _history = _a._history;\n        var fullUrl = _config.baseHref() + url;\n        if (replace) {\n            _history.replaceState(state, title, fullUrl);\n        }\n        else {\n            _history.pushState(state, title, fullUrl);\n        }\n    };\n    PushStateLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener(\"popstate\", this._listener);\n    };\n    return PushStateLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.PushStateLocationService = PushStateLocationService;\n//# sourceMappingURL=pushStateLocationService.js.map\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = __webpack_require__(16);\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\nexports.$q = {\n    /** Normalizes a value as a promise */\n    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n    /** Normalizes a value as a promise rejection */\n    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n    /** @returns a deferred object, which has `resolve` and `reject` functions */\n    defer: function () {\n        var deferred = {};\n        deferred.promise = new Promise(function (resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n    /** Like Promise.all(), but also supports object key/promise notation like $q */\n    all: function (promises) {\n        if (index_1.isArray(promises)) {\n            return Promise.all(promises);\n        }\n        if (index_1.isObject(promises)) {\n            // Convert promises map to promises array.\n            // When each promise resolves, map it to a tuple { key: key, val: val }\n            var chain = Object.keys(promises)\n                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n            // Then wait for all promises to resolve, and convert them back to an object\n            return exports.$q.all(chain).then(function (values) {\n                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n            });\n        }\n    }\n};\n//# sourceMappingURL=q.js.map\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module view\n */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar predicates_1 = __webpack_require__(1);\nvar trace_1 = __webpack_require__(6);\n/**\n * The View service\n *\n * This service pairs existing `ui-view` components (which live in the DOM)\n * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n *\n * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n *   The views from exited states are deactivated via [[deactivateViewConfig]].\n *   (See: the [[registerActivateViews]] Transition Hook)\n *\n * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n *\n * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n * are configured with the matching [[ViewConfig]](s)\n *\n */\nvar ViewService = (function () {\n    function ViewService() {\n        var _this = this;\n        this._uiViews = [];\n        this._viewConfigs = [];\n        this._viewConfigFactories = {};\n        this._pluginapi = {\n            _rootViewContext: this._rootViewContext.bind(this),\n            _viewConfigFactory: this._viewConfigFactory.bind(this),\n            _registeredUIViews: function () { return _this._uiViews; },\n            _activeViewConfigs: function () { return _this._viewConfigs; },\n        };\n    }\n    ViewService.prototype._rootViewContext = function (context) {\n        return this._rootContext = context || this._rootContext;\n    };\n    ;\n    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n        this._viewConfigFactories[viewType] = factory;\n    };\n    ViewService.prototype.createViewConfig = function (path, decl) {\n        var cfgFactory = this._viewConfigFactories[decl.$type];\n        if (!cfgFactory)\n            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n        var cfgs = cfgFactory(path, decl);\n        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n    };\n    /**\n     * Deactivates a ViewConfig.\n     *\n     * This function deactivates a `ViewConfig`.\n     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n     *\n     * @param viewConfig The ViewConfig view to deregister.\n     */\n    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n        common_1.removeFrom(this._viewConfigs, viewConfig);\n    };\n    ViewService.prototype.activateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n        this._viewConfigs.push(viewConfig);\n    };\n    ViewService.prototype.sync = function () {\n        var _this = this;\n        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n        // Return a weighted depth value for a uiView.\n        // The depth is the nesting depth of ui-views (based on FQN; times 10,000)\n        // plus the depth of the state that is populating the uiView\n        function uiViewDepth(uiView) {\n            var stateDepth = function (context) {\n                return context && context.parent ? stateDepth(context.parent) + 1 : 1;\n            };\n            return (uiView.fqn.split(\".\").length * 10000) + stateDepth(uiView.creationContext);\n        }\n        // Return the ViewConfig's context's depth in the context tree.\n        function viewConfigDepth(config) {\n            var context = config.viewDecl.$context, count = 0;\n            while (++count && context.parent)\n                context = context.parent;\n            return count;\n        }\n        // Given a depth function, returns a compare function which can return either ascending or descending order\n        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n        var matchingConfigPair = function (uiView) {\n            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n            if (matchingConfigs.length > 1) {\n                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n                // Sort by depth and return the match from the deepest child\n                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n            }\n            return [uiView, matchingConfigs[0]];\n        };\n        var configureUIView = function (_a) {\n            var uiView = _a[0], viewConfig = _a[1];\n            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n            if (_this._uiViews.indexOf(uiView) !== -1)\n                uiView.configUpdated(viewConfig);\n        };\n        // Sort views by FQN and state depth. Process uiviews nearest the root first.\n        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);\n    };\n    ;\n    /**\n     * Registers a `ui-view` component\n     *\n     * When a `ui-view` component is created, it uses this method to register itself.\n     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n     *\n     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n     * and what the view's state context is.\n     *\n     * Note: There is no corresponding `deregisterUIView`.\n     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n     *\n     * @param uiView The metadata for a UIView\n     * @return a de-registration function used when the view is destroyed.\n     */\n    ViewService.prototype.registerUIView = function (uiView) {\n        trace_1.trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n        var uiViews = this._uiViews;\n        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n        if (uiViews.filter(fqnMatches).length)\n            trace_1.trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n        uiViews.push(uiView);\n        this.sync();\n        return function () {\n            var idx = uiViews.indexOf(uiView);\n            if (idx === -1) {\n                trace_1.trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n                return;\n            }\n            trace_1.trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n            common_1.removeFrom(uiViews)(uiView);\n        };\n    };\n    ;\n    /**\n     * Returns the list of views currently available on the page, by fully-qualified name.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.available = function () {\n        return this._uiViews.map(hof_1.prop(\"fqn\"));\n    };\n    /**\n     * Returns the list of views on the page containing loaded content.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.active = function () {\n        return this._uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n    };\n    /**\n     * Normalizes a view's name from a state.views configuration block.\n     *\n     * This should be used by a framework implementation to calculate the values for\n     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n     *\n     * @param context the context object (state declaration) that the view belongs to\n     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n     *\n     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n     */\n    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n        if (rawViewName === void 0) { rawViewName = \"\"; }\n        // TODO: Validate incoming view name with a regexp to allow:\n        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n        var viewAtContext = rawViewName.split(\"@\");\n        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n        // Handle relative view-name sugar syntax.\n        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n        if (relativeViewNameSugar) {\n            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n        }\n        if (uiViewName.charAt(0) === '!') {\n            uiViewName = uiViewName.substr(1);\n            uiViewContextAnchor = \"\"; // target absolutely from root\n        }\n        // handle parent relative targeting \"^.^.^\"\n        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n        if (relativeMatch.exec(uiViewContextAnchor)) {\n            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n            uiViewContextAnchor = anchor.name;\n        }\n        else if (uiViewContextAnchor === '.') {\n            uiViewContextAnchor = context.name;\n        }\n        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n    };\n    return ViewService;\n}());\n/**\n * Given a ui-view and a ViewConfig, determines if they \"match\".\n *\n * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n *\n * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n *\n * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n *\n * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n * - the ui-view's name matches the ViewConfig's target name\n * - the ui-view's context matches the ViewConfig's anchor\n *\n * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n * - There exists a parent ui-view where:\n *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n *    - the parent ui-view's context matches the ViewConfig's anchor\n * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n *\n * Example:\n *\n * DOM:\n * <ui-view>                        <!-- created in the root context (name: \"\") -->\n *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n *       </ui-view>\n *     </ui-view>\n *   </ui-view>\n * </ui-view>\n *\n * uiViews: [\n *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n * ]\n *\n * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n *\n * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n *\n * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n *   the tail of the ui-view's fqn \"default.bar\"\n *\n * @internalapi\n */\nViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n    if (uiView.$type !== viewConfig.viewDecl.$type)\n        return false;\n    // Split names apart from both viewConfig and uiView into segments\n    var vc = viewConfig.viewDecl;\n    var vcSegments = vc.$uiViewName.split(\".\");\n    var uivSegments = uiView.fqn.split(\".\");\n    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n        return false;\n    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n    var negOffset = (1 - vcSegments.length) || undefined;\n    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n}; };\nexports.ViewService = ViewService;\n//# sourceMappingURL=view.js.map\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Main entry point for angular 1.x build\n * @module ng1\n */ /** */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(23));\n__export(__webpack_require__(24));\n__export(__webpack_require__(31));\n__export(__webpack_require__(32));\n__webpack_require__(63);\n__webpack_require__(61);\n__webpack_require__(65);\n__webpack_require__(62);\n__webpack_require__(68);\nexports.default = \"ui.router\";\nvar core = __webpack_require__(4);\nexports.core = core;\n__export(__webpack_require__(4));\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar $inject = ['$stateProvider', '$urlRouterProvider'];\n\nvar RouterHelperProvider = function () {\n  function RouterHelperProvider() {\n    var _this = this;\n\n    for (var _len = arguments.length, injects = Array(_len), _key = 0; _key < _len; _key++) {\n      injects[_key] = arguments[_key];\n    }\n\n    _classCallCheck(this, RouterHelperProvider);\n\n    RouterHelperProvider.$inject.forEach(function (item, index) {\n      return _this[item] = injects[index];\n    });\n    this.config = {\n      defaultRoute: '/',\n      docTitle: undefined,\n      resolveAlways: {}\n    };\n\n    this.configure = function (cfg) {\n      return Object.assign(_this.config, cfg);\n    };\n  }\n\n  _createClass(RouterHelperProvider, [{\n    key: '$get',\n    value: [\"$location\", \"$rootScope\", \"$state\", \"logger\", function $get($location, $rootScope, $state, logger) {\n      'ngInject';\n\n      var $stateProvider = this.$stateProvider;\n      var $urlRouterProvider = this.$urlRouterProvider;\n      var config = this.config;\n      var handlingStateChangeError = false;\n      var hasOtherwise = false;\n      var stateCounts = {\n        errors: 0,\n        changes: 0\n      };\n\n      _init();\n\n      return {\n        stateCounts: stateCounts,\n        configureStates: configureStates,\n        getStates: getStates\n      };\n\n      /* isparta ignore next  */\n      function _init() {\n        _handleRoutingErrors();\n        _updateDocTitle();\n      }\n\n      /* isparta ignore next  */\n      function _handleRoutingErrors() {\n        // Route cancellation:\n        // On routing error, go to the specific page.\n        $rootScope.$on('$stateChangeError', function (event, toState, toParams, fromState, fromParams, error) {\n          if (handlingStateChangeError) {\n            return;\n          }\n          stateCounts.errors++;\n          handlingStateChangeError = true;\n          var destination = toState && (toState.title || toState.name || toState.loadedTemplateUrl) || 'unknown target';\n          var msg = 'Error routing to ' + destination + '. ' + error;\n          logger.error(msg, [toState]);\n          $location.path(config.defaultRoute);\n        });\n      }\n\n      /* isparta ignore next  */\n      function _updateDocTitle() {\n        $rootScope.$on('$stateChangeSuccess', function (event, toState) {\n          stateCounts.changes++;\n          handlingStateChangeError = false;\n          var title = config.docTitle + ' ' + (toState.title || '');\n          $rootScope.title = title; // data bind to <title>\n        });\n      }\n\n      function configureStates(states, otherwisePath) {\n        states.forEach(function (state) {\n          state.config.resolve = Object.assign(state.config.resolve || {}, config.resolveAlways);\n          $stateProvider.state(state.state, state.config);\n        });\n        /* istanbul ignore if  */\n        if (otherwisePath && !hasOtherwise) {\n          hasOtherwise = true;\n          $urlRouterProvider.otherwise(otherwisePath);\n        }\n      }\n\n      function getStates() {\n        return $state.get();\n      }\n    }]\n  }]);\n\n  return RouterHelperProvider;\n}();\n\nRouterHelperProvider.$inject = $inject;\n\nexports.default = RouterHelperProvider;\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_60__;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Angular 1 Directives\n *\n * These are the directives included in UI-Router for Angular 1.\n * These directives are used in templates to create viewports and link/navigate to states.\n *\n * @ng1api\n * @preferred\n * @module directives\n */ /** for typedoc */\nvar angular_1 = __webpack_require__(8);\nvar core_1 = __webpack_require__(4);\n/** @hidden */\nfunction parseStateRef(ref) {\n    var paramsOnly = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n    if (paramsOnly)\n        ref = '(' + paramsOnly[1] + ')';\n    parsed = ref.replace(/\\n/g, \" \").match(/^\\s*([^(]*?)\\s*(\\((.*)\\))?\\s*$/);\n    if (!parsed || parsed.length !== 4)\n        throw new Error(\"Invalid state ref '\" + ref + \"'\");\n    return { state: parsed[1] || null, paramExpr: parsed[3] || null };\n}\n/** @hidden */\nfunction stateContext(el) {\n    var $uiView = el.parent().inheritedData('$uiView');\n    var path = core_1.parse('$cfg.path')($uiView);\n    return path ? core_1.tail(path).state.name : undefined;\n}\n/** @hidden */\nfunction processedDef($state, $element, def) {\n    var uiState = def.uiState || $state.current.name;\n    var uiStateOpts = core_1.extend(defaultOpts($element, $state), def.uiStateOpts || {});\n    var href = $state.href(uiState, def.uiStateParams, uiStateOpts);\n    return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };\n}\n/** @hidden */\nfunction getTypeInfo(el) {\n    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n    var isForm = el[0].nodeName === \"FORM\";\n    return {\n        attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n        isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n        clickable: !isForm\n    };\n}\n/** @hidden */\nfunction clickHook(el, $state, $timeout, type, getDef) {\n    return function (e) {\n        var button = e.which || e.button, target = getDef();\n        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n            var transition = $timeout(function () {\n                $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);\n            });\n            e.preventDefault();\n            // if the state has no URL, ignore one preventDefault from the <a> directive.\n            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;\n            e.preventDefault = function () {\n                if (ignorePreventDefaultCount-- <= 0)\n                    $timeout.cancel(transition);\n            };\n        }\n    };\n}\n/** @hidden */\nfunction defaultOpts(el, $state) {\n    return {\n        relative: stateContext(el) || $state.$current,\n        inherit: true,\n        source: \"sref\"\n    };\n}\n/** @hidden */\nfunction bindEvents(element, scope, hookFn, uiStateOpts) {\n    var events;\n    if (uiStateOpts) {\n        events = uiStateOpts.events;\n    }\n    if (!core_1.isArray(events)) {\n        events = ['click'];\n    }\n    var on = element.on ? 'on' : 'bind';\n    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n        var event_1 = events_1[_i];\n        element[on](event_1, hookFn);\n    }\n    scope.$on('$destroy', function () {\n        var off = element.off ? 'off' : 'unbind';\n        for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n            var event_2 = events_2[_i];\n            element[off](event_2, hookFn);\n        }\n    });\n}\n/**\n * `ui-sref`: A directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of the `ui-sref` is the name of the state to link to.\n *\n * #### Example:\n * This will activate the `home` state when the link is clicked.\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * ```\n *\n * ### Relative Links\n * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create a relative `ui-sref` which always targets the same destination.\n *\n * #### Example:\n * Both these links are relative to the parent state, even when a child state is currently active.\n * ```html\n * <a ui-sref=\".child1\">child 1 state</a>\n * <a ui-sref=\".child2\">child 2 state</a>\n * ```\n *\n * This link activates the parent state.\n * ```html\n * <a ui-sref=\"^\">Return</a>\n * ```\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * #### Example:\n * Assuming the `users` state has a url of `/users/`\n * ```html\n * <a ui-sref=\"users\" href=\"/users/\">Users</a>\n * ```\n *\n * ### Parameter Values\n * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.\n * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.\n * The content inside the parentheses is an expression, evaluated to the parameter values.\n *\n * #### Example:\n * This example renders a list of links to users.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"user in users\">\n *   <a ui-sref=\"users.detail({ userId: user.id })\">{{ user.displayName }}</a>\n * </li>\n * ```\n *\n * Note:\n * The parameter values expression is `$watch`ed for updates.\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n *\n * #### Example:\n * ```html\n * <a ui-sref=\"home\" ui-sref-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-sref-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-sref=\"contacts\" ui-sref-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Examples\n * If you have the following template:\n *\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * <a ui-sref=\"about\">About</a>\n * <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * ```\n *\n * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:\n *\n * ```html\n * <a href=\"#/home\" ui-sref=\"home\">Home</a>\n * <a href=\"#/about\" ui-sref=\"about\">About</a>\n * <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a href=\"#/home\" ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * ```\n *\n * ### Notes\n *\n * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-sref=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n *\n * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).\n * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.\n */\nvar uiSref;\nuiSref = ['$uiRouter', '$timeout',\n    function $StateRefDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var ref = parseStateRef(attrs.uiSref);\n                rawDef.uiState = ref.state;\n                rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                if (ref.paramExpr) {\n                    scope.$watch(ref.paramExpr, function (val) {\n                        rawDef.uiStateParams = core_1.extend({}, val);\n                        update();\n                    }, true);\n                    rawDef.uiStateParams = core_1.extend({}, scope.$eval(ref.paramExpr));\n                }\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            }\n        };\n    }];\n/**\n * `ui-state`: A fully dynamic directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.\n * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**\n *\n * #### Example:\n * Create a list of links.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Relative Links\n * If the expression evaluates to a relative path, it is processed like [[uiSref]].\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create relative `ui-state` which always targets the same destination.\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * ### Parameter Values\n * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.\n * Param values should be provided using the `ui-state-params` attribute.\n * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * This example renders a list of links with param values.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\" ui-state-params=\"link.params\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * ```html\n * <a ui-state=\"returnto.state\" ui-state-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-state-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-state=\"contacts\" ui-state-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Notes\n *\n * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.\n *   However, it might be simpler to use [[uiSref]] parameter-only links.\n *\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-state=\"\" ui-state-params=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n * ```\n */\nvar uiState;\nuiState = ['$uiRouter', '$timeout',\n    function $StateRefDynamicDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];\n                var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return (acc[attr] = core_1.noop, acc); }, {});\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                inputAttrs.forEach(function (field) {\n                    rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;\n                    attrs.$observe(field, function (expr) {\n                        watchDeregFns[field]();\n                        watchDeregFns[field] = scope.$watch(expr, function (newval) {\n                            rawDef[field] = newval;\n                            update();\n                        }, true);\n                    });\n                });\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            }\n        };\n    }];\n/**\n * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active\n *\n * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the\n * related directive's state is active (and remove them when it is inactive).\n *\n * The primary use-case is to highlight the active link in navigation menus,\n * distinguishing it from the inactive menu items.\n *\n * ### Linking to a `ui-sref` or `ui-state`\n * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.\n * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.\n *\n * ### Matching\n *\n * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.\n * This is a \"fuzzy match\" which uses [[StateService.includes]].\n *\n * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).\n * This is an \"exact match\" which uses [[StateService.is]].\n *\n * ### Parameter values\n * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.\n * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.\n *\n * #### Example:\n * ```html\n * <li ng-repeat=\"user in users\" ui-sref-active=\"active\">\n *   <a ui-sref=\"user.details({ userId: user.id })\">{{ user.lastName }}</a>\n * </li>\n * ```\n *\n * ### Examples\n *\n * Given the following template:\n * #### Example:\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * When the app state is `app.user` (or any child state),\n * and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n *\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * ### Glob mode\n *\n * It is possible to pass `ui-sref-active` an expression that evaluates to an object.\n * The objects keys represent active class names and values represent the respective state names/globs.\n * `ui-sref-active` will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * #### Example:\n * Given the following template, with \"admin\" being an abstract state:\n * ```html\n * <div ui-sref-active=\"{'active': 'admin.**'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * ```\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied to both the <div> and <a> elements.\n * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.\n *\n * ### Notes:\n *\n * - The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`\n */\nvar uiSrefActive;\nuiSrefActive = ['$state', '$stateParams', '$interpolate', '$uiRouter',\n    function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {\n        return {\n            restrict: \"A\",\n            controller: ['$scope', '$element', '$attrs',\n                function ($scope, $element, $attrs) {\n                    var states = [], activeEqClass, uiSrefActive;\n                    // There probably isn't much point in $observing this\n                    // uiSrefActive and uiSrefActiveEq share the same directive object with some\n                    // slight difference in logic routing\n                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n                    try {\n                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n                    }\n                    catch (e) {\n                        // Do nothing. uiSrefActive is not a valid expression.\n                        // Fall back to using $interpolate below\n                    }\n                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n                    if (core_1.isObject(uiSrefActive)) {\n                        core_1.forEach(uiSrefActive, function (stateOrName, activeClass) {\n                            if (core_1.isString(stateOrName)) {\n                                var ref = parseStateRef(stateOrName);\n                                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n                            }\n                        });\n                    }\n                    // Allow uiSref to communicate with uiSrefActive[Equals]\n                    this.$$addStateInfo = function (newState, newParams) {\n                        // we already got an explicit state provided by ui-sref-active, so we\n                        // shadow the one that comes from ui-sref\n                        if (core_1.isObject(uiSrefActive) && states.length > 0) {\n                            return;\n                        }\n                        var deregister = addState(newState, newParams, uiSrefActive);\n                        update();\n                        return deregister;\n                    };\n                    function updateAfterTransition(trans) {\n                        trans.promise.then(update, core_1.noop);\n                    }\n                    $scope.$on('$stateChangeSuccess', update);\n                    $scope.$on('$destroy', $uiRouter.transitionService.onStart({}, updateAfterTransition));\n                    if ($uiRouter.globals.transition) {\n                        updateAfterTransition($uiRouter.globals.transition);\n                    }\n                    function addState(stateName, stateParams, activeClass) {\n                        var state = $state.get(stateName, stateContext($element));\n                        var stateInfo = {\n                            state: state || { name: stateName },\n                            params: stateParams,\n                            activeClass: activeClass\n                        };\n                        states.push(stateInfo);\n                        return function removeState() {\n                            core_1.removeFrom(states)(stateInfo);\n                        };\n                    }\n                    // Update route state\n                    function update() {\n                        var splitClasses = function (str) {\n                            return str.split(/\\s/).filter(core_1.identity);\n                        };\n                        var getClasses = function (stateList) {\n                            return stateList.map(function (x) { return x.activeClass; }).map(splitClasses).reduce(core_1.unnestR, []);\n                        };\n                        var allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(core_1.uniqR, []);\n                        var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));\n                        var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;\n                        var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];\n                        var addClasses = fuzzyClasses.concat(exactClasses).reduce(core_1.uniqR, []);\n                        var removeClasses = allClasses.filter(function (cls) { return !core_1.inArray(addClasses, cls); });\n                        $scope.$evalAsync(function () {\n                            addClasses.forEach(function (className) { return $element.addClass(className); });\n                            removeClasses.forEach(function (className) { return $element.removeClass(className); });\n                        });\n                    }\n                    update();\n                }]\n        };\n    }];\nangular_1.ng.module('ui.router.state')\n    .directive('uiSref', uiSref)\n    .directive('uiSrefActive', uiSrefActive)\n    .directive('uiSrefActiveEq', uiSrefActive)\n    .directive('uiState', uiState);\n//# sourceMappingURL=stateDirectives.js.map\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @ng1api\n * @module directives\n */ /** for typedoc */\nvar angular_1 = __webpack_require__(8);\nvar angular_2 = __webpack_require__(22);\nvar core_1 = __webpack_require__(4);\nvar views_1 = __webpack_require__(24);\nvar services_1 = __webpack_require__(23);\nexports.uiView = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q',\n    function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {\n        function getRenderer(attrs, scope) {\n            return {\n                enter: function (element, target, cb) {\n                    if (angular_1.ng.version.minor > 2) {\n                        $animate.enter(element, null, target).then(cb);\n                    }\n                    else {\n                        $animate.enter(element, null, target, cb);\n                    }\n                },\n                leave: function (element, cb) {\n                    if (angular_1.ng.version.minor > 2) {\n                        $animate.leave(element).then(cb);\n                    }\n                    else {\n                        $animate.leave(element, cb);\n                    }\n                }\n            };\n        }\n        function configsEqual(config1, config2) {\n            return config1 === config2;\n        }\n        var rootData = {\n            $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },\n            $uiView: {}\n        };\n        var directive = {\n            count: 0,\n            restrict: 'ECA',\n            terminal: true,\n            priority: 400,\n            transclude: 'element',\n            compile: function (tElement, tAttrs, $transclude) {\n                return function (scope, $element, attrs) {\n                    var previousEl, currentEl, currentScope, unregister, onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(attrs, scope), viewConfig = undefined, inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';\n                    var activeUIView = {\n                        $type: 'ng1',\n                        id: directive.count++,\n                        name: name,\n                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + \".\" + name : name,\n                        config: null,\n                        configUpdated: configUpdatedCallback,\n                        get creationContext() {\n                            var fromParentTagConfig = core_1.parse('$cfg.viewDecl.$context')(inherited);\n                            // Allow <ui-view name=\"foo\"><ui-view name=\"bar\"></ui-view></ui-view>\n                            // See https://github.com/angular-ui/ui-router/issues/3355\n                            var fromParentTag = core_1.parse('$uiView.creationContext')(inherited);\n                            return fromParentTagConfig || fromParentTag;\n                        }\n                    };\n                    core_1.trace.traceUIViewEvent(\"Linking\", activeUIView);\n                    function configUpdatedCallback(config) {\n                        if (config && !(config instanceof views_1.Ng1ViewConfig))\n                            return;\n                        if (configsEqual(viewConfig, config))\n                            return;\n                        core_1.trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n                        viewConfig = config;\n                        updateView(config);\n                    }\n                    $element.data('$uiView', { $uiView: activeUIView });\n                    updateView();\n                    unregister = $view.registerUIView(activeUIView);\n                    scope.$on(\"$destroy\", function () {\n                        core_1.trace.traceUIViewEvent(\"Destroying/Unregistering\", activeUIView);\n                        unregister();\n                    });\n                    function cleanupLastView() {\n                        if (previousEl) {\n                            core_1.trace.traceUIViewEvent(\"Removing (previous) el\", previousEl.data('$uiView'));\n                            previousEl.remove();\n                            previousEl = null;\n                        }\n                        if (currentScope) {\n                            core_1.trace.traceUIViewEvent(\"Destroying scope\", activeUIView);\n                            currentScope.$destroy();\n                            currentScope = null;\n                        }\n                        if (currentEl) {\n                            var _viewData_1 = currentEl.data('$uiViewAnim');\n                            core_1.trace.traceUIViewEvent(\"Animate out\", _viewData_1);\n                            renderer.leave(currentEl, function () {\n                                _viewData_1.$$animLeave.resolve();\n                                previousEl = null;\n                            });\n                            previousEl = currentEl;\n                            currentEl = null;\n                        }\n                    }\n                    function updateView(config) {\n                        var newScope = scope.$new();\n                        var animEnter = $q.defer(), animLeave = $q.defer();\n                        var $uiViewData = {\n                            $cfg: config,\n                            $uiView: activeUIView,\n                        };\n                        var $uiViewAnim = {\n                            $animEnter: animEnter.promise,\n                            $animLeave: animLeave.promise,\n                            $$animLeave: animLeave\n                        };\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoading\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description\n                         *\n                         * Fired once the view **begins loading**, *before* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         * @param {string} viewName Name of the view.\n                         */\n                        newScope.$emit('$viewContentLoading', name);\n                        var cloned = $transclude(newScope, function (clone) {\n                            clone.data('$uiViewAnim', $uiViewAnim);\n                            clone.data('$uiView', $uiViewData);\n                            renderer.enter(clone, $element, function onUIViewEnter() {\n                                animEnter.resolve();\n                                if (currentScope)\n                                    currentScope.$emit('$viewContentAnimationEnded');\n                                if (core_1.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                                    $uiViewScroll(clone);\n                                }\n                            });\n                            cleanupLastView();\n                        });\n                        currentEl = cloned;\n                        currentScope = newScope;\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoaded\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description           *\n                         * Fired once the view is **loaded**, *after* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         */\n                        currentScope.$emit('$viewContentLoaded', config || viewConfig);\n                        currentScope.$eval(onloadExp);\n                    }\n                };\n            }\n        };\n        return directive;\n    }];\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];\n/** @hidden */\nfunction $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {\n    var getControllerAs = core_1.parse('viewDecl.controllerAs');\n    var getResolveAs = core_1.parse('viewDecl.resolveAs');\n    return {\n        restrict: 'ECA',\n        priority: -400,\n        compile: function (tElement) {\n            var initial = tElement.html();\n            tElement.empty();\n            return function (scope, $element) {\n                var data = $element.data('$uiView');\n                if (!data) {\n                    $element.html(initial);\n                    $compile($element.contents())(scope);\n                    return;\n                }\n                var cfg = data.$cfg || { viewDecl: {}, getTemplate: angular_2.noop };\n                var resolveCtx = cfg.path && new core_1.ResolveContext(cfg.path);\n                $element.html(cfg.getTemplate($element, resolveCtx) || initial);\n                core_1.trace.traceUIViewFill(data.$uiView, $element.html());\n                var link = $compile($element.contents());\n                var controller = cfg.controller;\n                var controllerAs = getControllerAs(cfg);\n                var resolveAs = getResolveAs(cfg);\n                var locals = resolveCtx && services_1.getLocals(resolveCtx);\n                scope[resolveAs] = locals;\n                if (controller) {\n                    var controllerInstance = $controller(controller, core_1.extend({}, locals, { $scope: scope, $element: $element }));\n                    if (controllerAs) {\n                        scope[controllerAs] = controllerInstance;\n                        scope[controllerAs][resolveAs] = locals;\n                    }\n                    // TODO: Use $view service as a central point for registering component-level hooks\n                    // Then, when a component is created, tell the $view service, so it can invoke hooks\n                    // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n                    // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n                    $element.data('$ngControllerController', controllerInstance);\n                    $element.children().data('$ngControllerController', controllerInstance);\n                    registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);\n                }\n                // Wait for the component to appear in the DOM\n                if (core_1.isString(cfg.viewDecl.component)) {\n                    var cmp_1 = cfg.viewDecl.component;\n                    var kebobName = core_1.kebobString(cmp_1);\n                    var tagRegexp_1 = new RegExp(\"^(x-|data-)?\" + kebobName + \"$\", \"i\");\n                    var getComponentController = function () {\n                        var directiveEl = [].slice.call($element[0].children)\n                            .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });\n                        return directiveEl && angular_1.ng.element(directiveEl).data(\"$\" + cmp_1 + \"Controller\");\n                    };\n                    var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {\n                        if (!ctrlInstance)\n                            return;\n                        registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);\n                        deregisterWatch_1();\n                    });\n                }\n                link(scope);\n            };\n        }\n    };\n}\n/** @hidden */\nvar hasComponentImpl = typeof angular_1.ng.module('ui.router')['component'] === 'function';\n/** @hidden incrementing id */\nvar _uiCanExitId = 0;\n/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\nfunction registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {\n    // Call $onInit() ASAP\n    if (core_1.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {\n        controllerInstance.$onInit();\n    }\n    var viewState = core_1.tail(cfg.path).state.self;\n    var hookOptions = { bind: controllerInstance };\n    // Add component-level hook for onParamsChange\n    if (core_1.isFunction(controllerInstance.uiOnParamsChanged)) {\n        var resolveContext = new core_1.ResolveContext(cfg.path);\n        var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;\n        // Fire callback on any successful transition\n        var paramsUpdated = function ($transition$) {\n            // Exit early if the $transition$ is the same as the view was created within.\n            // Exit early if the $transition$ will exit the state the view is for.\n            if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)\n                return;\n            var toParams = $transition$.params(\"to\");\n            var fromParams = $transition$.params(\"from\");\n            var toSchema = $transition$.treeChanges().to.map(function (node) { return node.paramSchema; }).reduce(core_1.unnestR, []);\n            var fromSchema = $transition$.treeChanges().from.map(function (node) { return node.paramSchema; }).reduce(core_1.unnestR, []);\n            // Find the to params that have different values than the from params\n            var changedToParams = toSchema.filter(function (param) {\n                var idx = fromSchema.indexOf(param);\n                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n            });\n            // Only trigger callback if a to param has changed or is new\n            if (changedToParams.length) {\n                var changedKeys_1 = changedToParams.map(function (x) { return x.id; });\n                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n                var newValues = core_1.filter(toParams, function (val, key) { return changedKeys_1.indexOf(key) !== -1; });\n                controllerInstance.uiOnParamsChanged(newValues, $transition$);\n            }\n        };\n        $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));\n    }\n    // Add component-level hook for uiCanExit\n    if (core_1.isFunction(controllerInstance.uiCanExit)) {\n        var id_1 = _uiCanExitId++;\n        var cacheProp_1 = '_uiCanExitIds';\n        // Returns true if a redirect transition already answered truthy\n        var prevTruthyAnswer_1 = function (trans) {\n            return !!trans && (trans[cacheProp_1] && trans[cacheProp_1][id_1] === true || prevTruthyAnswer_1(trans.redirectedFrom()));\n        };\n        // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n        var wrappedHook = function (trans) {\n            var promise, ids = trans[cacheProp_1] = trans[cacheProp_1] || {};\n            if (!prevTruthyAnswer_1(trans)) {\n                promise = $q.when(controllerInstance.uiCanExit(trans));\n                promise.then(function (val) { return ids[id_1] = (val !== false); });\n            }\n            return promise;\n        };\n        var criteria = { exiting: viewState.name };\n        $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));\n    }\n}\nangular_1.ng.module('ui.router.state').directive('uiView', exports.uiView);\nangular_1.ng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n//# sourceMappingURL=viewDirective.js.map\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * # Angular 1 injectable services\n *\n * This is a list of the objects which can be injected using angular's injector.\n *\n * There are three different kind of injectable objects:\n *\n * ## **Provider** objects\n * #### injectable into a `.config()` block during configtime\n *\n * - [[$uiRouterProvider]]: The UI-Router instance\n * - [[$stateProvider]]: State registration\n * - [[$transitionsProvider]]: Transition hooks\n * - [[$urlServiceProvider]]: All URL related public APIs\n *\n * - [[$uiViewScrollProvider]]: Disable ui-router view scrolling\n * - [[$urlRouterProvider]]: (deprecated) Url matching rules\n * - [[$urlMatcherFactoryProvider]]: (deprecated) Url parsing config\n *\n * ## **Service** objects\n * #### injectable globally during runtime\n *\n * - [[$uiRouter]]: The UI-Router instance\n * - [[$trace]]: Enable transition trace/debug\n * - [[$transitions]]: Transition hooks\n * - [[$state]]: Imperative state related APIs\n * - [[$stateRegistry]]: State registration\n * - [[$urlService]]: All URL related public APIs\n * - [[$uiRouterGlobals]]: Global variables\n * - [[$uiViewScroll]]: Scroll an element into view\n *\n * - [[$stateParams]]: (deprecated) Global state param values\n * - [[$urlRouter]]: (deprecated) URL synchronization\n * - [[$urlMatcherFactory]]: (deprecated) URL parsing config\n *\n * ## **Per-Transition** objects\n *\n * - These kind of objects are injectable into:\n *   - Resolves ([[Ng1StateDeclaration.resolve]]),\n *   - Transition Hooks ([[TransitionService.onStart]], etc),\n *   - Routed Controllers ([[Ng1ViewDeclaration.controller]])\n *\n * #### Different instances are injected based on the [[Transition]]\n *\n * - [[$transition$]]: The current Transition object\n * - [[$stateParams]]: State param values for pending Transition (deprecated)\n * - Any resolve data defined using [[Ng1StateDeclaration.resolve]]\n *\n * @ng1api\n * @preferred\n * @module injectables\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The current (or pending) State Parameters\n *\n * An injectable global **Service Object** which holds the state parameters for the latest **SUCCESSFUL** transition.\n *\n * The values are not updated until *after* a `Transition` successfully completes.\n *\n * **Also:** an injectable **Per-Transition Object** object which holds the pending state parameters for the pending `Transition` currently running.\n *\n * ### Deprecation warning:\n *\n * The value injected for `$stateParams` is different depending on where it is injected.\n *\n * - When injected into an angular service, the object injected is the global **Service Object** with the parameter values for the latest successful `Transition`.\n * - When injected into transition hooks, resolves, or view controllers, the object is the **Per-Transition Object** with the parameter values for the running `Transition`.\n *\n * Because of these confusing details, this service is deprecated.\n *\n * ### Instead of using the global `$stateParams` service object,\n * inject [[$uiRouterGlobals]] and use [[UIRouterGlobals.params]]\n *\n * ```js\n * MyService.$inject = ['$uiRouterGlobals'];\n * function MyService($uiRouterGlobals) {\n *   return {\n *     paramValues: function () {\n *       return $uiRouterGlobals.params;\n *     }\n *   }\n * }\n * ```\n *\n * ### Instead of using the per-transition `$stateParams` object,\n * inject the current `Transition` (as [[$transition$]]) and use [[Transition.params]]\n *\n * ```js\n * MyController.$inject = ['$transition$'];\n * function MyController($transition$) {\n *   var username = $transition$.params().username;\n *   // .. do something with username\n * }\n * ```\n *\n * ---\n *\n * This object can be injected into other services.\n *\n * #### Deprecated Example:\n * ```js\n * SomeService.$inject = ['$http', '$stateParams'];\n * function SomeService($http, $stateParams) {\n *   return {\n *     getUser: function() {\n *       return $http.get('/api/users/' + $stateParams.username);\n *     }\n *   }\n * };\n * angular.service('SomeService', SomeService);\n * ```\n * @deprecated\n */\nvar $stateParams;\n/**\n * Global UI-Router variables\n *\n * The router global state as a **Service Object** (injectable during runtime).\n *\n * This object contains globals such as the current state and current parameter values.\n */\nvar $uiRouterGlobals;\n/**\n * The UI-Router instance\n *\n * The [[UIRouter]] singleton (the router instance) as a **Service Object** (injectable during runtime).\n *\n * This object is the UI-Router singleton instance, created by angular dependency injection during application bootstrap.\n * It has references to the other UI-Router services\n *\n * #### Note: This object is also exposed as [[$uiRouterProvider]] for injection during angular config time.\n */\nvar $uiRouter;\n/**\n * The UI-Router instance\n *\n * The [[UIRouter]] singleton (the router instance) as a **Provider Object** (injectable during config phase).\n *\n * This object is the UI-Router singleton instance, created by angular dependency injection during application bootstrap.\n * It has references to the other UI-Router services\n *\n * #### Note: This object is also exposed as [[$uiRouter]] for injection during runtime.\n */\nvar $uiRouterProvider;\n/**\n * Transition debug/tracing\n *\n * The [[Trace]] singleton as a **Service Object** (injectable during runtime).\n *\n * Enables or disables Transition tracing which can help to debug issues.\n */\nvar $trace;\n/**\n * The Transition Service\n *\n * The [[TransitionService]] singleton as a **Service Object** (injectable during runtime).\n *\n * This angular service exposes the [[TransitionService]] singleton, which is primarily\n * used to register global transition hooks.\n *\n * #### Note: This object is also exposed as [[$transitionsProvider]] for injection during the config phase.\n */\nvar $transitions;\n/**\n * The Transition Service\n *\n * The [[TransitionService]] singleton as a **Provider Object** (injectable during config phase)\n *\n * This angular service exposes the [[TransitionService]] singleton, which is primarily\n * used to register global transition hooks.\n *\n * #### Note: This object is also exposed as [[$transitions]] for injection during runtime.\n */\nvar $transitionsProvider;\n/**\n * The current [[Transition]] object\n *\n * The current [[Transition]] object as a **Per-Transition Object** (injectable into Resolve, Hooks, Controllers)\n *\n * This object returns information about the current transition, including:\n *\n * - To/from states\n * - To/from parameters\n * - Transition options\n * - States being entered, exited, and retained\n * - Resolve data\n * - A Promise for the transition\n * - Any transition failure information\n * - An injector for both Service and Per-Transition Objects\n */\nvar $transition$;\n/**\n * The State Service\n *\n * The [[StateService]] singleton as a **Service Object** (injectable during runtime).\n *\n * This service used to manage and query information on registered states.\n * It exposes state related APIs including:\n *\n * - Start a [[Transition]]\n * - Imperatively lazy load states\n * - Check if a state is currently active\n * - Look up states by name\n * - Build URLs for a state+parameters\n * - Configure the global Transition error handler\n *\n * This angular service exposes the [[StateService]] singleton.\n */\nvar $state;\n/**\n * The State Registry\n *\n * The [[StateRegistry]] singleton as a **Service Object** (injectable during runtime).\n *\n * This service is used to register/deregister states.\n * It has state registration related APIs including:\n *\n * - Register/deregister states\n * - Listen for state registration/deregistration\n * - Get states by name\n * - Add state decorators (to customize the state creation process)\n *\n * #### Note: This object is also exposed as [[$stateRegistryProvider]] for injection during the config phase.\n */\nvar $stateRegistry;\n/**\n * The State Registry\n *\n * The [[StateRegistry]] singleton as a **Provider Object** (injectable during config time).\n *\n * This service is used to register/deregister states.\n * It has state registration related APIs including:\n *\n * - Register/deregister states\n * - Listen for state registration/deregistration\n * - Get states by name\n * - Add state decorators (to customize the state creation process)\n *\n * #### Note: This object is also exposed as [[$stateRegistry]] for injection during runtime.\n */\nvar $stateRegistryProvider;\n/**\n * The View Scroll provider\n *\n * The [[UIViewScrollProvider]] as a **Provider Object** (injectable during config time).\n *\n * This angular service exposes the [[UIViewScrollProvider]] singleton and is\n * used to disable UI-Router's scroll behavior.\n */\nvar $uiViewScrollProvider;\n/**\n * The View Scroll function\n *\n * The View Scroll function as a **Service Object** (injectable during runtime).\n *\n * This is a function that scrolls an element into view.\n * The element is scrolled after a `$timeout` so the DOM has time to refresh.\n *\n * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n * this can be enabled by calling [[UIViewScrollProvider.useAnchorScroll]].\n *\n * Note: this function is used by the [[directives.uiView]] when the `autoscroll` expression evaluates to true.\n */\nvar $uiViewScroll;\n/**\n * The StateProvider\n *\n * An angular1-only [[StateProvider]] as a **Provider Object** (injectable during config time).\n *\n * This angular service exposes the [[StateProvider]] singleton.\n *\n * The `StateProvider` is primarily used to register states or add custom state decorators.\n *\n * ##### Note: This provider is a ng1 vestige.\n * It is a passthrough to [[$stateRegistry]] and [[$state]].\n */\nvar $stateProvider;\n/**\n * The URL Service Provider\n *\n * The [[UrlService]] singleton as a **Provider Object** (injectable during the angular config phase).\n *\n * A service used to configure and interact with the URL.\n * It has URL related APIs including:\n *\n * - register custom Parameter types `UrlService.config.type` ([[UrlConfigApi.type]])\n * - add URL rules: `UrlService.rules.when` ([[UrlRulesApi.when]])\n * - configure behavior when no url matches: `UrlService.rules.otherwise` ([[UrlRulesApi.otherwise]])\n * - delay initial URL synchronization [[UrlService.deferIntercept]].\n * - get or set the current url: [[UrlService.url]]\n *\n * ##### Note: This service can also be injected during runtime as [[$urlService]].\n */\nvar $urlServiceProvider;\n/**\n * The URL Service\n *\n * The [[UrlService]] singleton as a **Service Object** (injectable during runtime).\n *\n * Note: This service can also be injected during the config phase as [[$urlServiceProvider]].\n *\n * Used to configure the URL.\n * It has URL related APIs including:\n *\n * - register custom Parameter types `UrlService.config.type` ([[UrlConfigApi.type]])\n * - add URL rules: `UrlService.rules.when` ([[UrlRulesApi.when]])\n * - configure behavior when no url matches: `UrlService.rules.otherwise` ([[UrlRulesApi.otherwise]])\n * - delay initial URL synchronization [[UrlService.deferIntercept]].\n * - get or set the current url: [[UrlService.url]]\n *\n * ##### Note: This service can also be injected during the config phase as [[$urlServiceProvider]].\n */\nvar $urlService;\n/**\n * The URL Router Provider\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlServiceProvider]] instead.\n *\n * The [[UrlRouter]] singleton as a **Provider Object** (injectable during config time).\n *\n * #### Note: This object is also exposed as [[$urlRouter]] for injection during runtime.\n *\n * @deprecated\n */\nvar $urlRouterProvider;\n/**\n * The Url Router\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.\n *\n * The [[UrlRouter]] singleton as a **Service Object** (injectable during runtime).\n *\n * #### Note: This object is also exposed as [[$urlRouterProvider]] for injection during angular config time.\n *\n * @deprecated\n */\nvar $urlRouter;\n/**\n * The URL Matcher Factory\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.\n *\n * The [[UrlMatcherFactory]] singleton as a **Service Object** (injectable during runtime).\n *\n * This service is used to set url mapping options, define custom parameter types, and create [[UrlMatcher]] objects.\n *\n * #### Note: This object is also exposed as [[$urlMatcherFactoryProvider]] for injection during angular config time.\n *\n * @deprecated\n */\nvar $urlMatcherFactory;\n/**\n * The URL Matcher Factory\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.\n *\n * The [[UrlMatcherFactory]] singleton as a **Provider Object** (injectable during config time).\n *\n * This service is used to set url mapping options, define custom parameter types, and create [[UrlMatcher]] objects.\n *\n * #### Note: This object is also exposed as [[$urlMatcherFactory]] for injection during runtime.\n *\n * @deprecated\n */\nvar $urlMatcherFactoryProvider;\n//# sourceMappingURL=injectables.js.map\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(4);\n/**\n * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service\n */\nvar Ng1LocationServices = (function () {\n    function Ng1LocationServices($locationProvider) {\n        // .onChange() registry\n        this._urlListeners = [];\n        this.$locationProvider = $locationProvider;\n        var _lp = core_1.val($locationProvider);\n        core_1.createProxyFunctions(_lp, this, _lp, ['hashPrefix']);\n    }\n    Ng1LocationServices.prototype.dispose = function () { };\n    Ng1LocationServices.prototype.onChange = function (callback) {\n        var _this = this;\n        this._urlListeners.push(callback);\n        return function () { return core_1.removeFrom(_this._urlListeners)(callback); };\n    };\n    Ng1LocationServices.prototype.html5Mode = function () {\n        var html5Mode = this.$locationProvider.html5Mode();\n        html5Mode = core_1.isObject(html5Mode) ? html5Mode.enabled : html5Mode;\n        return html5Mode && this.$sniffer.history;\n    };\n    Ng1LocationServices.prototype.url = function (newUrl, replace, state) {\n        if (replace === void 0) { replace = false; }\n        if (newUrl)\n            this.$location.url(newUrl);\n        if (replace)\n            this.$location.replace();\n        if (state)\n            this.$location.state(state);\n        return this.$location.url();\n    };\n    Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser) {\n        var _this = this;\n        this.$location = $location;\n        this.$sniffer = $sniffer;\n        // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange\n        $rootScope.$on(\"$locationChangeSuccess\", function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });\n        var _loc = core_1.val($location);\n        var _browser = core_1.val($browser);\n        // Bind these LocationService functions to $location\n        core_1.createProxyFunctions(_loc, this, _loc, [\"replace\", \"path\", \"search\", \"hash\"]);\n        // Bind these LocationConfig functions to $location\n        core_1.createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);\n        // Bind these LocationConfig functions to $browser\n        core_1.createProxyFunctions(_browser, this, _browser, ['baseHref']);\n    };\n    /**\n     * Applys ng1-specific path parameter encoding\n     *\n     * The Angular 1 `$location` service is a bit weird.\n     * It doesn't allow slashes to be encoded/decoded bi-directionally.\n     *\n     * See the writeup at https://github.com/angular-ui/ui-router/issues/2598\n     *\n     * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F\n     *\n     * @param router\n     */\n    Ng1LocationServices.monkeyPatchPathParameterType = function (router) {\n        var pathType = router.urlMatcherFactory.type('path');\n        pathType.encode = function (val) {\n            return val != null ? val.toString().replace(/(~|\\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : val;\n        };\n        pathType.decode = function (val) {\n            return val != null ? val.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : val;\n        };\n    };\n    return Ng1LocationServices;\n}());\nexports.Ng1LocationServices = Ng1LocationServices;\n//# sourceMappingURL=locationServices.js.map\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/** @module ng1 */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar angular_1 = __webpack_require__(8);\n/**\n * `isState` Filter: truthy if the current state is the parameter\n *\n * Translates to [[StateService.is]] `$state.is(\"stateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'stateName' | isState\">show if state is 'stateName'</div>\n * ```\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n    var isFilter = function (state, params, options) {\n        return $state.is(state, params, options);\n    };\n    isFilter.$stateful = true;\n    return isFilter;\n}\nexports.$IsStateFilter = $IsStateFilter;\n/**\n * `includedByState` Filter: truthy if the current state includes the parameter\n *\n * Translates to [[StateService.includes]]` $state.is(\"fullOrPartialStateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'fullOrPartialStateName' | includedByState\">show if state includes 'fullOrPartialStateName'</div>\n * ```\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n    var includesFilter = function (state, params, options) {\n        return $state.includes(state, params, options);\n    };\n    includesFilter.$stateful = true;\n    return includesFilter;\n}\nexports.$IncludedByStateFilter = $IncludedByStateFilter;\nangular_1.ng.module('ui.router.state')\n    .filter('isState', $IsStateFilter)\n    .filter('includedByState', $IncludedByStateFilter);\n//# sourceMappingURL=stateFilters.js.map\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module ng1 */ /** */\nvar core_1 = __webpack_require__(4);\nvar services_1 = __webpack_require__(23);\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,\n * `onRetain` callback hooks on a [[Ng1StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * ensures that those hooks are injectable for @uirouter/angularjs (ng1).\n */\nexports.getStateHookBuilder = function (hookName) {\n    return function stateHookBuilder(state, parentFn) {\n        var hook = state[hookName];\n        var pathname = hookName === 'onExit' ? 'from' : 'to';\n        function decoratedNg1Hook(trans, state) {\n            var resolveContext = new core_1.ResolveContext(trans.treeChanges(pathname));\n            var locals = core_1.extend(services_1.getLocals(resolveContext), { $state$: state, $transition$: trans });\n            return core_1.services.$injector.invoke(hook, this, locals);\n        }\n        return hook ? decoratedNg1Hook : undefined;\n    };\n};\n//# sourceMappingURL=onEnterExitRetain.js.map\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module view */\n/** for typedoc */\nvar angular_1 = __webpack_require__(8);\nvar core_1 = __webpack_require__(4);\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\nvar TemplateFactory = (function () {\n    function TemplateFactory() {\n        var _this = this;\n        /** @hidden */ this._useHttp = angular_1.ng.version.minor < 3;\n        /** @hidden */ this.$get = ['$http', '$templateCache', '$injector', function ($http, $templateCache, $injector) {\n                _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n                _this.$http = $http;\n                _this.$templateCache = $templateCache;\n                return _this;\n            }];\n    }\n    /** @hidden */\n    TemplateFactory.prototype.useHttpService = function (value) {\n        this._useHttp = value;\n    };\n    ;\n    /**\n     * Creates a template from a configuration object.\n     *\n     * @param config Configuration object for which to load a template.\n     * The following properties are search in the specified order, and the first one\n     * that is defined is used to create the template:\n     *\n     * @param params  Parameters to pass to the template function.\n     * @param context The resolve context associated with the template's view\n     *\n     * @return {string|object}  The template html as a string, or a promise for\n     * that string,or `null` if no template is configured.\n     */\n    TemplateFactory.prototype.fromConfig = function (config, params, context) {\n        var defaultTemplate = \"<ui-view></ui-view>\";\n        var asTemplate = function (result) { return core_1.services.$q.when(result).then(function (str) { return ({ template: str }); }); };\n        var asComponent = function (result) { return core_1.services.$q.when(result).then(function (str) { return ({ component: str }); }); };\n        return (core_1.isDefined(config.template) ? asTemplate(this.fromString(config.template, params)) :\n            core_1.isDefined(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) :\n                core_1.isDefined(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) :\n                    core_1.isDefined(config.component) ? asComponent(config.component) :\n                        core_1.isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) :\n                            asTemplate(defaultTemplate));\n    };\n    ;\n    /**\n     * Creates a template from a string or a function returning a string.\n     *\n     * @param template html template as a string or function that returns an html template as a string.\n     * @param params Parameters to pass to the template function.\n     *\n     * @return {string|object} The template html as a string, or a promise for that\n     * string.\n     */\n    TemplateFactory.prototype.fromString = function (template, params) {\n        return core_1.isFunction(template) ? template(params) : template;\n    };\n    ;\n    /**\n     * Loads a template from the a URL via `$http` and `$templateCache`.\n     *\n     * @param {string|Function} url url of the template to load, or a function\n     * that returns a url.\n     * @param {Object} params Parameters to pass to the url function.\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromUrl = function (url, params) {\n        if (core_1.isFunction(url))\n            url = url(params);\n        if (url == null)\n            return null;\n        if (this._useHttp) {\n            return this.$http.get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })\n                .then(function (response) {\n                return response.data;\n            });\n        }\n        return this.$templateRequest(url);\n    };\n    ;\n    /**\n     * Creates a template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromProvider = function (provider, params, context) {\n        var deps = core_1.services.$injector.annotate(provider);\n        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;\n        var resolvable = new core_1.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    ;\n    /**\n     * Creates a component's template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {\n        var deps = core_1.services.$injector.annotate(provider);\n        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;\n        var resolvable = new core_1.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    ;\n    /**\n     * Creates a template from a component's name\n     *\n     * This implements route-to-component.\n     * It works by retrieving the component (directive) metadata from the injector.\n     * It analyses the component's bindings, then constructs a template that instantiates the component.\n     * The template wires input and output bindings to resolves or from the parent component.\n     *\n     * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n     * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n     * @param component {string} Component's name in camel case.\n     * @param bindings An object defining the component's bindings: {foo: '<'}\n     * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {\n        bindings = bindings || {};\n        // Bind once prefix\n        var prefix = angular_1.ng.version.minor >= 3 ? \"::\" : \"\";\n        // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n        var kebob = function (camelCase) {\n            var kebobed = core_1.kebobString(camelCase);\n            return /^(x|data)-/.exec(kebobed) ? \"x-\" + kebobed : kebobed;\n        };\n        var attributeTpl = function (input) {\n            var name = input.name, type = input.type;\n            var attrName = kebob(name);\n            // If the ui-view has an attribute which matches a binding on the routed component\n            // then pass that attribute through to the routed component template.\n            // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n            if (uiView.attr(attrName) && !bindings[name])\n                return attrName + \"='\" + uiView.attr(attrName) + \"'\";\n            var resolveName = bindings[name] || name;\n            // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n            // some-attr=\"{{ ::$resolve.someResolveName }}\"\n            if (type === '@')\n                return attrName + \"='{{\" + prefix + \"$resolve.\" + resolveName + \"}}'\";\n            // Wire \"&\" callbacks to resolves that return a callback function\n            // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n            // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n            if (type === '&') {\n                var res = context.getResolvable(resolveName);\n                var fn = res && res.data;\n                var args = fn && core_1.services.$injector.annotate(fn) || [];\n                // account for array style injection, i.e., ['foo', function(foo) {}]\n                var arrayIdxStr = core_1.isArray(fn) ? \"[\" + (fn.length - 1) + \"]\" : '';\n                return attrName + \"='$resolve.\" + resolveName + arrayIdxStr + \"(\" + args.join(\",\") + \")'\";\n            }\n            // some-attr=\"::$resolve.someResolveName\"\n            return attrName + \"='\" + prefix + \"$resolve.\" + resolveName + \"'\";\n        };\n        var attrs = getComponentBindings(component).map(attributeTpl).join(\" \");\n        var kebobName = kebob(component);\n        return \"<\" + kebobName + \" \" + attrs + \"></\" + kebobName + \">\";\n    };\n    ;\n    return TemplateFactory;\n}());\nexports.TemplateFactory = TemplateFactory;\n// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\nfunction getComponentBindings(name) {\n    var cmpDefs = core_1.services.$injector.get(name + \"Directive\"); // could be multiple\n    if (!cmpDefs || !cmpDefs.length)\n        throw new Error(\"Unable to find component named '\" + name + \"'\");\n    return cmpDefs.map(getBindings).reduce(core_1.unnestR, []);\n}\n// Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\nvar getBindings = function (def) {\n    if (core_1.isObject(def.bindToController))\n        return scopeBindings(def.bindToController);\n    return scopeBindings(def.scope);\n};\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\nvar scopeBindings = function (bindingsObj) { return Object.keys(bindingsObj || {})\n    .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })\n    .filter(function (tuple) { return core_1.isDefined(tuple) && core_1.isArray(tuple[1]); })\n    .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); }); };\n//# sourceMappingURL=templateFactory.js.map\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module ng1 */ /** */\nvar angular_1 = __webpack_require__(8);\n/** @hidden */\nfunction $ViewScrollProvider() {\n    var useAnchorScroll = false;\n    this.useAnchorScroll = function () {\n        useAnchorScroll = true;\n    };\n    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n            if (useAnchorScroll) {\n                return $anchorScroll;\n            }\n            return function ($element) {\n                return $timeout(function () {\n                    $element[0].scrollIntoView();\n                }, 0, false);\n            };\n        }];\n}\nangular_1.ng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n//# sourceMappingURL=viewScroll.js.map\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** */\nvar transition_1 = __webpack_require__(19);\nvar router_1 = __webpack_require__(38);\nfunction addCoreResolvables(trans) {\n    trans.addResolvable({ token: router_1.UIRouter, deps: [], resolveFn: function () { return trans.router; }, data: trans.router }, \"\");\n    trans.addResolvable({ token: transition_1.Transition, deps: [], resolveFn: function () { return trans; }, data: trans }, \"\");\n    trans.addResolvable({ token: '$transition$', deps: [], resolveFn: function () { return trans; }, data: trans }, \"\");\n    trans.addResolvable({ token: '$stateParams', deps: [], resolveFn: function () { return trans.params(); }, data: trans.params() }, \"\");\n    trans.entering().forEach(function (state) {\n        trans.addResolvable({ token: '$state$', deps: [], resolveFn: function () { return state; }, data: state }, state);\n    });\n}\nexports.registerAddCoreResolvables = function (transitionService) {\n    return transitionService.onCreate({}, addCoreResolvables);\n};\n//# sourceMappingURL=coreResolvables.js.map\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/** @module hooks */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar trace_1 = __webpack_require__(6);\nvar rejectFactory_1 = __webpack_require__(12);\n/**\n * A [[TransitionHookFn]] that skips a transition if it should be ignored\n *\n * This hook is invoked at the end of the onBefore phase.\n *\n * If the transition should be ignored (because no parameter or states changed)\n * then the transition is ignored and not processed.\n */\nfunction ignoredHook(trans) {\n    var ignoredReason = trans._ignoredReason();\n    if (!ignoredReason)\n        return;\n    trace_1.trace.traceTransitionIgnored(trans);\n    var pending = trans.router.globals.transition;\n    // The user clicked a link going back to the *current state* ('A')\n    // However, there is also a pending transition in flight (to 'B')\n    // Abort the transition to 'B' because the user now wants to be back at 'A'.\n    if (ignoredReason === 'SameAsCurrent' && pending) {\n        pending.abort();\n    }\n    return rejectFactory_1.Rejection.ignored().toPromise();\n}\nexports.registerIgnoredTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, ignoredHook, { priority: -9999 });\n};\n//# sourceMappingURL=ignoredTransition.js.map\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/** @module hooks */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A [[TransitionHookFn]] that rejects the Transition if it is invalid\n *\n * This hook is invoked at the end of the onBefore phase.\n * If the transition is invalid (for example, param values do not validate)\n * then the transition is rejected.\n */\nfunction invalidTransitionHook(trans) {\n    if (!trans.valid()) {\n        throw new Error(trans.error());\n    }\n}\nexports.registerInvalidTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });\n};\n//# sourceMappingURL=invalidTransition.js.map\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A factory which creates an onEnter, onExit or onRetain transition hook function\n *\n * The returned function invokes the (for instance) state.onEnter hook when the\n * state is being entered.\n *\n * @hidden\n */\nfunction makeEnterExitRetainHook(hookName) {\n    return function (transition, state) {\n        var _state = state.$$state();\n        var hookFn = _state[hookName];\n        return hookFn(transition, state);\n    };\n}\n/**\n * The [[TransitionStateHookFn]] for onExit\n *\n * When the state is being exited, the state's .onExit function is invoked.\n *\n * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n *\n * See: [[IHookRegistry.onExit]]\n */\nvar onExitHook = makeEnterExitRetainHook('onExit');\nexports.registerOnExitHook = function (transitionService) {\n    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onRetain\n *\n * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n *\n * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n *\n * See: [[IHookRegistry.onRetain]]\n */\nvar onRetainHook = makeEnterExitRetainHook('onRetain');\nexports.registerOnRetainHook = function (transitionService) {\n    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onEnter\n *\n * When the state is being entered, the state's .onEnter function is invoked.\n *\n * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n *\n * See: [[IHookRegistry.onEnter]]\n */\nvar onEnterHook = makeEnterExitRetainHook('onEnter');\nexports.registerOnEnterHook = function (transitionService) {\n    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n};\n//# sourceMappingURL=onEnterExitRetain.js.map\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** */\nvar predicates_1 = __webpack_require__(1);\nvar coreservices_1 = __webpack_require__(3);\nvar targetState_1 = __webpack_require__(7);\n/**\n * A [[TransitionHookFn]] that redirects to a different state or params\n *\n * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n *\n * See [[StateDeclaration.redirectTo]]\n */\nvar redirectToHook = function (trans) {\n    var redirect = trans.to().redirectTo;\n    if (!redirect)\n        return;\n    var $state = trans.router.stateService;\n    function handleResult(result) {\n        if (!result)\n            return;\n        if (result instanceof targetState_1.TargetState)\n            return result;\n        if (predicates_1.isString(result))\n            return $state.target(result, trans.params(), trans.options());\n        if (result['state'] || result['params'])\n            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n    }\n    if (predicates_1.isFunction(redirect)) {\n        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n    }\n    return handleResult(redirect);\n};\nexports.registerRedirectToHook = function (transitionService) {\n    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n};\n//# sourceMappingURL=redirectTo.js.map\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */\n/** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar resolveContext_1 = __webpack_require__(18);\nvar hof_1 = __webpack_require__(2);\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath);`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar eagerResolvePath = function (trans) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .resolvePath(\"EAGER\", trans)\n        .then(common_1.noop);\n};\nexports.registerEagerResolvePath = function (transitionService) {\n    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar lazyResolveState = function (trans, state) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .subContext(state.$$state())\n        .resolvePath(\"LAZY\", trans)\n        .then(common_1.noop);\n};\nexports.registerLazyResolveState = function (transitionService) {\n    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n};\n//# sourceMappingURL=resolve.js.map\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(0);\n/**\n * A [[TransitionHookFn]] which updates global UI-Router state\n *\n * Registered using `transitionService.onBefore({}, updateGlobalState);`\n *\n * Before a [[Transition]] starts, updates the global value of \"the current transition\" ([[Globals.transition]]).\n * After a successful [[Transition]], updates the global values of \"the current state\"\n * ([[Globals.current]] and [[Globals.$current]]) and \"the current param values\" ([[Globals.params]]).\n *\n * See also the deprecated properties:\n * [[StateService.transition]], [[StateService.current]], [[StateService.params]]\n */\nvar updateGlobalState = function (trans) {\n    var globals = trans.router.globals;\n    var transitionSuccessful = function () {\n        globals.successfulTransitions.enqueue(trans);\n        globals.$current = trans.$to();\n        globals.current = globals.$current.self;\n        common_1.copy(trans.params(), globals.params);\n    };\n    var clearCurrentTransition = function () {\n        // Do not clear globals.transition if a different transition has started in the meantime\n        if (globals.transition === trans)\n            globals.transition = null;\n    };\n    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });\n    trans.promise.then(clearCurrentTransition, clearCurrentTransition);\n};\nexports.registerUpdateGlobalState = function (transitionService) {\n    return transitionService.onCreate({}, updateGlobalState);\n};\n//# sourceMappingURL=updateGlobals.js.map\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nvar updateUrl = function (transition) {\n    var options = transition.options();\n    var $state = transition.router.stateService;\n    var $urlRouter = transition.router.urlRouter;\n    // Dont update the url in these situations:\n    // The transition was triggered by a URL sync (options.source === 'url')\n    // The user doesn't want the url to update (options.location === false)\n    // The destination state, and all parents have no navigable url\n    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n        var urlOptions = { replace: options.location === 'replace' };\n        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n    }\n    $urlRouter.update(true);\n};\nexports.registerUpdateUrl = function (transitionService) {\n    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n};\n//# sourceMappingURL=url.js.map\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar coreservices_1 = __webpack_require__(3);\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nvar loadEnteringViews = function (transition) {\n    var $q = coreservices_1.services.$q;\n    var enteringViews = transition.views(\"entering\");\n    if (!enteringViews.length)\n        return;\n    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n};\nexports.registerLoadEnteringViews = function (transitionService) {\n    return transitionService.onFinish({}, loadEnteringViews);\n};\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nvar activateViews = function (transition) {\n    var enteringViews = transition.views(\"entering\");\n    var exitingViews = transition.views(\"exiting\");\n    if (!enteringViews.length && !exitingViews.length)\n        return;\n    var $view = transition.router.viewService;\n    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n    $view.sync();\n};\nexports.registerActivateViews = function (transitionService) {\n    return transitionService.onSuccess({}, activateViews);\n};\n//# sourceMappingURL=views.js.map\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * # Core classes and interfaces\n *\n * The classes and interfaces that are core to ui-router and do not belong\n * to a more specific subsystem (such as resolve).\n *\n * @coreapi\n * @preferred\n * @module core\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @internalapi */\nvar UIRouterPluginBase = (function () {\n    function UIRouterPluginBase() {\n    }\n    UIRouterPluginBase.prototype.dispose = function (router) { };\n    return UIRouterPluginBase;\n}());\nexports.UIRouterPluginBase = UIRouterPluginBase;\n//# sourceMappingURL=interface.js.map\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(9));\n__export(__webpack_require__(35));\n__export(__webpack_require__(36));\n__export(__webpack_require__(26));\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module path */ /** for typedoc */\n__export(__webpack_require__(27));\n__export(__webpack_require__(17));\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module resolve */ /** for typedoc */\n__export(__webpack_require__(37));\n__export(__webpack_require__(11));\n__export(__webpack_require__(18));\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(39));\n__export(__webpack_require__(28));\n__export(__webpack_require__(40));\n__export(__webpack_require__(41));\n__export(__webpack_require__(42));\n__export(__webpack_require__(43));\n__export(__webpack_require__(7));\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Transition subsystem\n *\n * This module contains APIs related to a Transition.\n *\n * See:\n * - [[TransitionService]]\n * - [[Transition]]\n * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n *\n * @coreapi\n * @preferred\n * @module transition\n */ /** for typedoc */\n__export(__webpack_require__(10));\n__export(__webpack_require__(44));\n__export(__webpack_require__(29));\n__export(__webpack_require__(12));\n__export(__webpack_require__(19));\n__export(__webpack_require__(13));\n__export(__webpack_require__(45));\n__export(__webpack_require__(30));\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(20));\n__export(__webpack_require__(46));\n__export(__webpack_require__(47));\n__export(__webpack_require__(48));\n__export(__webpack_require__(49));\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\n__export(__webpack_require__(86));\n//# sourceMappingURL=vanilla.js.map\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(56));\n__export(__webpack_require__(52));\n__export(__webpack_require__(21));\n__export(__webpack_require__(51));\n__export(__webpack_require__(54));\n__export(__webpack_require__(55));\n__export(__webpack_require__(53));\n__export(__webpack_require__(50));\n__export(__webpack_require__(14));\n__export(__webpack_require__(87));\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar browserLocationConfig_1 = __webpack_require__(50);\nvar hashLocationService_1 = __webpack_require__(51);\nvar utils_1 = __webpack_require__(14);\nvar pushStateLocationService_1 = __webpack_require__(55);\nvar memoryLocationService_1 = __webpack_require__(54);\nvar memoryLocationConfig_1 = __webpack_require__(53);\nvar injector_1 = __webpack_require__(52);\nvar q_1 = __webpack_require__(56);\nvar coreservices_1 = __webpack_require__(3);\nfunction servicesPlugin(router) {\n    coreservices_1.services.$injector = injector_1.$injector;\n    coreservices_1.services.$q = q_1.$q;\n    return { name: \"vanilla.services\", $q: q_1.$q, $injector: injector_1.$injector, dispose: function () { return null; } };\n}\nexports.servicesPlugin = servicesPlugin;\n/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\nexports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\nexports.pushStateLocationPlugin = utils_1.locationPluginFactory(\"vanilla.pushStateLocation\", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\nexports.memoryLocationPlugin = utils_1.locationPluginFactory(\"vanilla.memoryLocation\", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n//# sourceMappingURL=plugins.js.map\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(57));\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sjRouter = undefined;\n\nvar _angular = __webpack_require__(22);\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _angularjs = __webpack_require__(58);\n\nvar _angularjs2 = _interopRequireDefault(_angularjs);\n\nvar _sanjiLoggerUi = __webpack_require__(60);\n\nvar _routerHelper = __webpack_require__(59);\n\nvar _routerHelper2 = _interopRequireDefault(_routerHelper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar sjRouter = _angular2.default.module('sanji.router', [_angularjs2.default, _sanjiLoggerUi.sjLogger]).provider('routerHelper', _routerHelper2.default).name;\nexports.sjRouter = sjRouter;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// sanji-router-ui.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 89);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 30f683dace4f15d1e411","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Random utility functions used in the UI-Router code\n *\n * These functions are exported, but are subject to change without notice.\n *\n * @preferred\n * @module common\n */\n/** for typedoc */\nvar predicates_1 = require(\"./predicates\");\nvar hof_1 = require(\"./hof\");\nvar coreservices_1 = require(\"./coreservices\");\nvar w = typeof window === 'undefined' ? {} : window;\nvar angular = w.angular || {};\nexports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\nexports.toJson = angular.toJson || JSON.stringify.bind(JSON);\nexports.copy = angular.copy || _copy;\nexports.forEach = angular.forEach || _forEach;\nexports.extend = Object.assign || _extend;\nexports.equals = angular.equals || _equals;\nfunction identity(x) { return x; }\nexports.identity = identity;\nfunction noop() { }\nexports.noop = noop;\n/**\n * Builds proxy functions on the `to` object which pass through to the `from` object.\n *\n * For each key in `fnNames`, creates a proxy function on the `to` object.\n * The proxy function calls the real function on the `from` object.\n *\n *\n * #### Example:\n * This example creates an new class instance whose functions are prebound to the new'd object.\n * ```js\n * class Foo {\n *   constructor(data) {\n *     // Binds all functions from Foo.prototype to 'this',\n *     // then copies them to 'this'\n *     bindFunctions(Foo.prototype, this, this);\n *     this.data = data;\n *   }\n *\n *   log() {\n *     console.log(this.data);\n *   }\n * }\n *\n * let myFoo = new Foo([1,2,3]);\n * var logit = myFoo.log;\n * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n * ```\n *\n * #### Example:\n * This example creates a bound version of a service function, and copies it to another object\n * ```\n *\n * var SomeService = {\n *   this.data = [3, 4, 5];\n *   this.log = function() {\n *     console.log(this.data);\n *   }\n * }\n *\n * // Constructor fn\n * function OtherThing() {\n *   // Binds all functions from SomeService to SomeService,\n *   // then copies them to 'this'\n *   bindFunctions(SomeService, this, SomeService);\n * }\n *\n * let myOtherThing = new OtherThing();\n * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n * ```\n *\n * @param source A function that returns the source object which contains the original functions to be bound\n * @param target A function that returns the target object which will receive the bound functions\n * @param bind A function that returns the object which the functions will be bound to\n * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n * @param latebind If true, the binding of the function is delayed until the first time it's invoked\n */\nfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n    if (latebind === void 0) { latebind = false; }\n    var bindFunction = function (fnName) {\n        return source()[fnName].bind(bind());\n    };\n    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n        target[fnName] = bindFunction(fnName);\n        return target[fnName].apply(null, arguments);\n    }; };\n    fnNames = fnNames || Object.keys(source());\n    return fnNames.reduce(function (acc, name) {\n        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n        return acc;\n    }, target);\n}\nexports.createProxyFunctions = createProxyFunctions;\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n */\nexports.inherit = function (parent, extra) {\n    return exports.extend(Object.create(parent), extra);\n};\n/**\n * Given an arguments object, converts the arguments at index idx and above to an array.\n * This is similar to es6 rest parameters.\n *\n * Optionally, the argument at index idx may itself already be an array.\n *\n * For example,\n * given either:\n *        arguments = [ obj, \"foo\", \"bar\" ]\n * or:\n *        arguments = [ obj, [\"foo\", \"bar\"] ]\n * then:\n *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n *\n * This allows functions like pick() to be implemented such that it allows either a bunch\n * of string arguments (like es6 rest parameters), or a single array of strings:\n *\n * given:\n *        var obj = { foo: 1, bar: 2, baz: 3 };\n * then:\n *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n */\nvar restArgs = function (args, idx) {\n    if (idx === void 0) { idx = 0; }\n    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n};\n/** Given an array, returns true if the object is found in the array, (using indexOf) */\nexports.inArray = hof_1.curry(_inArray);\nfunction _inArray(array, obj) {\n    return array.indexOf(obj) !== -1;\n}\nexports._inArray = _inArray;\n/**\n * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n * The same array is returned\n */\nexports.removeFrom = hof_1.curry(_removeFrom);\nfunction _removeFrom(array, obj) {\n    var idx = array.indexOf(obj);\n    if (idx >= 0)\n        array.splice(idx, 1);\n    return array;\n}\nexports._removeFrom = _removeFrom;\n/** pushes a values to an array and returns the value */\nexports.pushTo = hof_1.curry(_pushTo);\nfunction _pushTo(arr, val) {\n    return (arr.push(val), val);\n}\nexports._pushTo = _pushTo;\n/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\nexports.deregAll = function (functions) {\n    return functions.slice().forEach(function (fn) {\n        typeof fn === 'function' && fn();\n        exports.removeFrom(functions, fn);\n    });\n};\n/**\n * Applies a set of defaults to an options object.  The options object is filtered\n * to only those properties of the objects in the defaultsList.\n * Earlier objects in the defaultsList take precedence when applying defaults.\n */\nfunction defaults(opts) {\n    var defaultsList = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defaultsList[_i - 1] = arguments[_i];\n    }\n    var _defaultsList = defaultsList.concat({}).reverse();\n    var defaultVals = exports.extend.apply(null, _defaultsList);\n    return exports.extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));\n}\nexports.defaults = defaults;\n/** Reduce function that merges each element of the list into a single object, using extend */\nexports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n    var path = [];\n    for (var n in first.path) {\n        if (first.path[n] !== second.path[n])\n            break;\n        path.push(first.path[n]);\n    }\n    return path;\n}\nexports.ancestors = ancestors;\n/**\n * Return a copy of the object only containing the whitelisted properties.\n *\n * #### Example:\n * ```\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the whitelisted property names\n */\nfunction pick(obj, propNames) {\n    var objCopy = {};\n    for (var prop_1 in obj) {\n        if (propNames.indexOf(prop_1) !== -1) {\n            objCopy[prop_1] = obj[prop_1];\n        }\n    }\n    return objCopy;\n}\nexports.pick = pick;\n/**\n * Return a copy of the object omitting the blacklisted properties.\n *\n * @example\n * ```\n *\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = omit(foo, ['a', 'b']); // { c: 3 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the blacklisted property names\n */\nfunction omit(obj, propNames) {\n    return Object.keys(obj)\n        .filter(hof_1.not(exports.inArray(propNames)))\n        .reduce(function (acc, key) { return (acc[key] = obj[key], acc); }, {});\n}\nexports.omit = omit;\n/**\n * Maps an array, or object to a property (by name)\n */\nfunction pluck(collection, propName) {\n    return map(collection, hof_1.prop(propName));\n}\nexports.pluck = pluck;\n/** Filters an Array or an Object's properties based on a predicate */\nfunction filter(collection, callback) {\n    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n    exports.forEach(collection, function (item, i) {\n        if (callback(item, i))\n            accept(item, i);\n    });\n    return result;\n}\nexports.filter = filter;\n/** Finds an object from an array, or a property of an object, that matches a predicate */\nfunction find(collection, callback) {\n    var result;\n    exports.forEach(collection, function (item, i) {\n        if (result)\n            return;\n        if (callback(item, i))\n            result = item;\n    });\n    return result;\n}\nexports.find = find;\n/** Given an object, returns a new object, where each property is transformed by the callback function */\nexports.mapObj = map;\n/** Maps an array or object properties using a callback function */\nfunction map(collection, callback) {\n    var result = predicates_1.isArray(collection) ? [] : {};\n    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n    return result;\n}\nexports.map = map;\n/**\n * Given an object, return its enumerable property values\n *\n * @example\n * ```\n *\n * let foo = { a: 1, b: 2, c: 3 }\n * let vals = values(foo); // [ 1, 2, 3 ]\n * ```\n */\nexports.values = function (obj) {\n    return Object.keys(obj).map(function (key) { return obj[key]; });\n};\n/**\n * Reduce function that returns true if all of the values are truthy.\n *\n * @example\n * ```\n *\n * let vals = [ 1, true, {}, \"hello world\"];\n * vals.reduce(allTrueR, true); // true\n *\n * vals.push(0);\n * vals.reduce(allTrueR, true); // false\n * ```\n */\nexports.allTrueR = function (memo, elem) { return memo && elem; };\n/**\n * Reduce function that returns true if any of the values are truthy.\n *\n *  * @example\n * ```\n *\n * let vals = [ 0, null, undefined ];\n * vals.reduce(anyTrueR, true); // false\n *\n * vals.push(\"hello world\");\n * vals.reduce(anyTrueR, true); // true\n * ```\n */\nexports.anyTrueR = function (memo, elem) { return memo || elem; };\n/**\n * Reduce function which un-nests a single level of arrays\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnestR = function (memo, elem) { return memo.concat(elem); };\n/**\n * Reduce function which recursively un-nests all arrays\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flattenR = function (memo, elem) {\n    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n};\n/**\n * Reduce function that pushes an object to an array, then returns the array.\n * Mostly just for [[flattenR]] and [[uniqR]]\n */\nfunction pushR(arr, obj) {\n    arr.push(obj);\n    return arr;\n}\nexports.pushR = pushR;\n/** Reduce function that filters out duplicates */\nexports.uniqR = function (acc, token) {\n    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n};\n/**\n * Return a new array with a single level of arrays unnested.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n/**\n * Return a completely flattened version of an array.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n * ```\n */\nexports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n/**\n * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n * @example\n * ```\n *\n * let isNumber = (obj) => typeof(obj) === 'number';\n * let allNumbers = [ 1, 2, 3, 4, 5 ];\n * allNumbers.filter(assertPredicate(isNumber)); //OK\n *\n * let oneString = [ 1, 2, 3, 4, \"5\" ];\n * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n * ```\n */\nexports.assertPredicate = assertFn;\n/**\n * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n * @example\n * ```\n *\n * var data = { foo: 1, bar: 2 };\n *\n * let keys = [ 'foo', 'bar' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // values is [1, 2]\n *\n * let keys = [ 'foo', 'bar', 'baz' ]\n * let values = keys.map(assertMap(key => data[key], \"Key not found\"));\n * // throws Error(\"Key not found\")\n * ```\n */\nexports.assertMap = assertFn;\nfunction assertFn(predicateOrMap, errMsg) {\n    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n    return function (obj) {\n        var result = predicateOrMap(obj);\n        if (!result) {\n            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n        }\n        return result;\n    };\n}\nexports.assertFn = assertFn;\n/**\n * Like _.pairs: Given an object, returns an array of key/value pairs\n *\n * @example\n * ```\n *\n * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n * ```\n */\nexports.pairs = function (obj) {\n    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n};\n/**\n * Given two or more parallel arrays, returns an array of tuples where\n * each tuple is composed of [ a[i], b[i], ... z[i] ]\n *\n * @example\n * ```\n *\n * let foo = [ 0, 2, 4, 6 ];\n * let bar = [ 1, 3, 5, 7 ];\n * let baz = [ 10, 30, 50, 70 ];\n * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n * ```\n */\nfunction arrayTuples() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 0)\n        return [];\n    var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53 − 1 aka Number.MAX_SAFE_INTEGER\n    var i, result = [];\n    for (i = 0; i < maxArrayLen; i++) {\n        // This is a hot function\n        // Unroll when there are 1-4 arguments\n        switch (args.length) {\n            case 1:\n                result.push([args[0][i]]);\n                break;\n            case 2:\n                result.push([args[0][i], args[1][i]]);\n                break;\n            case 3:\n                result.push([args[0][i], args[1][i], args[2][i]]);\n                break;\n            case 4:\n                result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);\n                break;\n            default:\n                result.push(args.map(function (array) { return array[i]; }));\n                break;\n        }\n    }\n    return result;\n}\nexports.arrayTuples = arrayTuples;\n/**\n * Reduce function which builds an object from an array of [key, value] pairs.\n *\n * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n *\n * Each keyValueTuple should be an array with values [ key: string, value: any ]\n *\n * @example\n * ```\n *\n * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n *\n * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n *\n * // Or, more simply:\n * var pairsToObj = pairs.reduce(applyPairs, {})\n * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n * ```\n */\nfunction applyPairs(memo, keyValTuple) {\n    var key, value;\n    if (predicates_1.isArray(keyValTuple))\n        key = keyValTuple[0], value = keyValTuple[1];\n    if (!predicates_1.isString(key))\n        throw new Error(\"invalid parameters to applyPairs\");\n    memo[key] = value;\n    return memo;\n}\nexports.applyPairs = applyPairs;\n/** Get the last element of an array */\nfunction tail(arr) {\n    return arr.length && arr[arr.length - 1] || undefined;\n}\nexports.tail = tail;\n/**\n * shallow copy from src to dest\n *\n * note: This is a shallow copy, while angular.copy is a deep copy.\n * ui-router uses `copy` only to make copies of state parameters.\n */\nfunction _copy(src, dest) {\n    if (dest)\n        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n    if (!dest)\n        dest = {};\n    return exports.extend(dest, src);\n}\n/** Naive forEach implementation works with Objects or Arrays */\nfunction _forEach(obj, cb, _this) {\n    if (predicates_1.isArray(obj))\n        return obj.forEach(cb, _this);\n    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n}\nfunction _extend(toObj) {\n    for (var i = 1; i < arguments.length; i++) {\n        var obj = arguments[i];\n        if (!obj)\n            continue;\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; j++) {\n            toObj[keys[j]] = obj[keys[j]];\n        }\n    }\n    return toObj;\n}\nexports._extend = _extend;\nfunction _equals(o1, o2) {\n    if (o1 === o2)\n        return true;\n    if (o1 === null || o2 === null)\n        return false;\n    if (o1 !== o1 && o2 !== o2)\n        return true; // NaN === NaN\n    var t1 = typeof o1, t2 = typeof o2;\n    if (t1 !== t2 || t1 !== 'object')\n        return false;\n    var tup = [o1, o2];\n    if (hof_1.all(predicates_1.isArray)(tup))\n        return _arraysEq(o1, o2);\n    if (hof_1.all(predicates_1.isDate)(tup))\n        return o1.getTime() === o2.getTime();\n    if (hof_1.all(predicates_1.isRegExp)(tup))\n        return o1.toString() === o2.toString();\n    if (hof_1.all(predicates_1.isFunction)(tup))\n        return true; // meh\n    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n        return false;\n    var key, keys = {};\n    for (key in o1) {\n        if (!_equals(o1[key], o2[key]))\n            return false;\n        keys[key] = true;\n    }\n    for (key in o2) {\n        if (!keys[key])\n            return false;\n    }\n    return true;\n}\nfunction _arraysEq(a1, a2) {\n    if (a1.length !== a2.length)\n        return false;\n    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n}\n/**\n * Create a sort function\n *\n * Creates a sort function which sorts by a numeric property.\n *\n * The `propFn` should return the property as a number which can be sorted.\n *\n * #### Example:\n * This example returns the `priority` prop.\n * ```js\n * var sortfn = sortBy(obj => obj.priority)\n * // equivalent to:\n * var longhandSortFn = (a, b) => a.priority - b.priority;\n * ```\n *\n * #### Example:\n * This example uses [[prop]]\n * ```js\n * var sortfn = sortBy(prop('priority'))\n * ```\n *\n * The `checkFn` can be used to exclude objects from sorting.\n *\n * #### Example:\n * This example only sorts objects with type === 'FOO'\n * ```js\n * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))\n * ```\n *\n * @param propFn a function that returns the property (as a number)\n * @param checkFn a predicate\n *\n * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`\n */\nexports.sortBy = function (propFn, checkFn) {\n    if (checkFn === void 0) { checkFn = hof_1.val(true); }\n    return function (a, b) {\n        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;\n    };\n};\n/**\n * Composes a list of sort functions\n *\n * Creates a sort function composed of multiple sort functions.\n * Each sort function is invoked in series.\n * The first sort function to return non-zero \"wins\".\n *\n * @param sortFns list of sort functions\n */\nexports.composeSort = function () {\n    var sortFns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sortFns[_i] = arguments[_i];\n    }\n    return function composedSort(a, b) {\n        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);\n    };\n};\n// issue #2676\nexports.silenceUncaughtInPromise = function (promise) {\n    return promise.catch(function (e) { return 0; }) && promise;\n};\nexports.silentRejection = function (error) {\n    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n};\n//# sourceMappingURL=common.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/common/common.js\n// module id = 0\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_predicates\n */\n/** */\nvar hof_1 = require(\"./hof\");\nvar stateObject_1 = require(\"../state/stateObject\");\nvar toStr = Object.prototype.toString;\nvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\nexports.isUndefined = tis('undefined');\nexports.isDefined = hof_1.not(exports.isUndefined);\nexports.isNull = function (o) { return o === null; };\nexports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\nexports.isFunction = tis('function');\nexports.isNumber = tis('number');\nexports.isString = tis('string');\nexports.isObject = function (x) { return x !== null && typeof x === 'object'; };\nexports.isArray = Array.isArray;\nexports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\nexports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\nexports.isState = stateObject_1.StateObject.isState;\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\nfunction isInjectable(val) {\n    if (exports.isArray(val) && val.length) {\n        var head = val.slice(0, -1), tail = val.slice(-1);\n        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n    }\n    return exports.isFunction(val);\n}\nexports.isInjectable = isInjectable;\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\nexports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n//# sourceMappingURL=predicates.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/common/predicates.js\n// module id = 1\n// module chunks = 0","\"use strict\";\n/**\n * Higher order functions\n *\n * These utility functions are exported, but are subject to change without notice.\n *\n * @module common_hof\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n *\n * Given a function with N parameters, returns a new function that supports partial application.\n * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n * accept more parameters until all N parameters have been supplied.\n *\n *\n * This contrived example uses a partially applied function as an predicate, which returns true\n * if an object is found in both arrays.\n * @example\n * ```\n * // returns true if an object is in both of the two arrays\n * function inBoth(array1, array2, object) {\n *   return array1.indexOf(object) !== -1 &&\n *          array2.indexOf(object) !== 1;\n * }\n * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n * let foos = [obj1, obj3]\n * let bars = [obj3, obj4, obj5]\n *\n * // A curried \"copy\" of inBoth\n * let curriedInBoth = curry(inBoth);\n * // Partially apply both the array1 and array2\n * let inFoosAndBars = curriedInBoth(foos, bars);\n *\n * // Supply the final argument; since all arguments are\n * // supplied, the original inBoth function is then called.\n * let obj1InBoth = inFoosAndBars(obj1); // false\n *\n * // Use the inFoosAndBars as a predicate.\n * // Filter, on each iteration, supplies the final argument\n * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n *\n * ```\n *\n * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n *\n * @param fn\n * @returns {*|function(): (*|any)}\n */\nfunction curry(fn) {\n    var initial_args = [].slice.apply(arguments, [1]);\n    var func_args_length = fn.length;\n    function curried(args) {\n        if (args.length >= func_args_length)\n            return fn.apply(null, args);\n        return function () {\n            return curried(args.concat([].slice.apply(arguments)));\n        };\n    }\n    return curried(initial_args);\n}\nexports.curry = curry;\n/**\n * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n * given: f(x), g(x), h(x)\n * let composed = compose(f,g,h)\n * then, composed is: f(g(h(x)))\n */\nfunction compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n        var i = start, result = args[start].apply(this, arguments);\n        while (i--)\n            result = args[i].call(this, result);\n        return result;\n    };\n}\nexports.compose = compose;\n/**\n * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n * given: f(x), g(x), h(x)\n * let piped = pipe(f,g,h);\n * then, piped is: h(g(f(x)))\n */\nfunction pipe() {\n    var funcs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        funcs[_i] = arguments[_i];\n    }\n    return compose.apply(null, [].slice.call(arguments).reverse());\n}\nexports.pipe = pipe;\n/**\n * Given a property name, returns a function that returns that property from an object\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = prop(\"name\");\n * getName(obj) === \"blarg\"\n */\nexports.prop = function (name) {\n    return function (obj) { return obj && obj[name]; };\n};\n/**\n * Given a property name and a value, returns a function that returns a boolean based on whether\n * the passed object has a property that matches the value\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = propEq(\"name\", \"blarg\");\n * getName(obj) === true\n */\nexports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n/**\n * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n * let getName = prop(\"nestedObj.name\");\n * getName(obj) === \"blarg\"\n * let propNotFound = prop(\"this.property.doesnt.exist\");\n * propNotFound(obj) === undefined\n */\nexports.parse = function (name) {\n    return pipe.apply(null, name.split(\".\").map(exports.prop));\n};\n/**\n * Given a function that returns a truthy or falsey value, returns a\n * function that returns the opposite (falsey or truthy) value given the same inputs\n */\nexports.not = function (fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return !fn.apply(null, args);\n    };\n};\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if both functions return truthy for the given arguments\n */\nfunction and(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) && fn2.apply(null, args);\n    };\n}\nexports.and = and;\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if at least one of the functions returns truthy for the given arguments\n */\nfunction or(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) || fn2.apply(null, args);\n    };\n}\nexports.or = or;\n/**\n * Check if all the elements of an array match a predicate function\n *\n * @param fn1 a predicate function `fn1`\n * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n */\nexports.all = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n};\nexports.any = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n};\n/** Given a class, returns a Predicate function that returns true if the object is of that class */\nexports.is = function (ctor) {\n    return function (obj) {\n        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n    };\n};\n/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\nexports.eq = function (val) { return function (other) {\n    return val === other;\n}; };\n/** Given a value, returns a function which returns the value */\nexports.val = function (v) { return function () { return v; }; };\nfunction invoke(fnName, args) {\n    return function (obj) {\n        return obj[fnName].apply(obj, args);\n    };\n}\nexports.invoke = invoke;\n/**\n * Sorta like Pattern Matching (a functional programming conditional construct)\n *\n * See http://c2.com/cgi/wiki?PatternMatching\n *\n * This is a conditional construct which allows a series of predicates and output functions\n * to be checked and then applied.  Each predicate receives the input.  If the predicate\n * returns truthy, then its matching output function (mapping function) is provided with\n * the input and, then the result is returned.\n *\n * Each combination (2-tuple) of predicate + output function should be placed in an array\n * of size 2: [ predicate, mapFn ]\n *\n * These 2-tuples should be put in an outer array.\n *\n * @example\n * ```\n *\n * // Here's a 2-tuple where the first element is the isString predicate\n * // and the second element is a function that returns a description of the input\n * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n *\n * // Second tuple: predicate \"isNumber\", mapfn returns a description\n * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n *\n * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n *\n * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n *\n * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n *\n * console.log(descriptionOf(undefined)); // 'notdefined'\n * console.log(descriptionOf(55)); // '(55) That's a number!'\n * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n * ```\n *\n * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n * with a Predicate and a mapping/output function\n * @returns {function(any): *}\n */\nfunction pattern(struct) {\n    return function (x) {\n        for (var i = 0; i < struct.length; i++) {\n            if (struct[i][0](x))\n                return struct[i][1](x);\n        }\n    };\n}\nexports.pattern = pattern;\n//# sourceMappingURL=hof.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/common/hof.js\n// module id = 2\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.notImplemented = function (fnname) { return function () {\n    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded.\");\n}; };\nvar services = {\n    $q: undefined,\n    $injector: undefined,\n};\nexports.services = services;\n//# sourceMappingURL=coreservices.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/common/coreservices.js\n// module id = 3\n// module chunks = 0","\"use strict\";\n/**\n * @coreapi\n * @module common\n */ /** */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./common/index\"));\n__export(require(\"./params/index\"));\n__export(require(\"./path/index\"));\n__export(require(\"./resolve/index\"));\n__export(require(\"./state/index\"));\n__export(require(\"./transition/index\"));\n__export(require(\"./url/index\"));\n__export(require(\"./view/index\"));\n__export(require(\"./globals\"));\n__export(require(\"./router\"));\n__export(require(\"./vanilla\"));\n__export(require(\"./interface\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/index.js\n// module id = 4\n// module chunks = 0","\"use strict\";\n/**\n * Functions that manipulate strings\n *\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_strings\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar predicates_1 = require(\"./predicates\");\nvar rejectFactory_1 = require(\"../transition/rejectFactory\");\nvar common_1 = require(\"./common\");\nvar hof_1 = require(\"./hof\");\nvar transition_1 = require(\"../transition/transition\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\n/**\n * Returns a string shortened to a maximum length\n *\n * If the string is already less than the `max` length, return the string.\n * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n *\n * @param max the maximum length of the string to return\n * @param str the input string\n */\nfunction maxLength(max, str) {\n    if (str.length <= max)\n        return str;\n    return str.substr(0, max - 3) + \"...\";\n}\nexports.maxLength = maxLength;\n/**\n * Returns a string, with spaces added to the end, up to a desired str length\n *\n * If the string is already longer than the desired length, return the string.\n * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n *\n * @param length the desired length of the string to return\n * @param str the input string\n */\nfunction padString(length, str) {\n    while (str.length < length)\n        str += \" \";\n    return str;\n}\nexports.padString = padString;\nfunction kebobString(camelCase) {\n    return camelCase\n        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n}\nexports.kebobString = kebobString;\nfunction _toJson(obj) {\n    return JSON.stringify(obj);\n}\nfunction _fromJson(json) {\n    return predicates_1.isString(json) ? JSON.parse(json) : json;\n}\nfunction promiseToString(p) {\n    return \"Promise(\" + JSON.stringify(p) + \")\";\n}\nfunction functionToString(fn) {\n    var fnStr = fnToString(fn);\n    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n    var fnName = fn['name'] || \"\";\n    if (fnName && toStr.match(/function \\(/)) {\n        return 'function ' + fnName + toStr.substr(9);\n    }\n    return toStr;\n}\nexports.functionToString = functionToString;\nfunction fnToString(fn) {\n    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n    return _fn && _fn.toString() || \"undefined\";\n}\nexports.fnToString = fnToString;\nvar stringifyPatternFn = null;\nvar stringifyPattern = function (value) {\n    var isRejection = rejectFactory_1.Rejection.isRejectionPromise;\n    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n        [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n        [predicates_1.isNull, hof_1.val(\"null\")],\n        [predicates_1.isPromise, hof_1.val(\"[Promise]\")],\n        [isRejection, function (x) { return x._transitionRejection.toString(); }],\n        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n        [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n        [predicates_1.isInjectable, functionToString],\n        [hof_1.val(true), common_1.identity]\n    ]);\n    return stringifyPatternFn(value);\n};\nfunction stringify(o) {\n    var seen = [];\n    function format(val) {\n        if (predicates_1.isObject(val)) {\n            if (seen.indexOf(val) !== -1)\n                return '[circular ref]';\n            seen.push(val);\n        }\n        return stringifyPattern(val);\n    }\n    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n}\nexports.stringify = stringify;\n/** Returns a function that splits a string on a character or substring */\nexports.beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\n/**\n * Splits on a delimiter, but returns the delimiters in the array\n *\n * #### Example:\n * ```js\n * var splitOnSlashes = splitOnDelim('/');\n * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n * ```\n */\nfunction splitOnDelim(delim) {\n    var re = new RegExp(\"(\" + delim + \")\", \"g\");\n    return function (str) {\n        return str.split(re).filter(common_1.identity);\n    };\n}\nexports.splitOnDelim = splitOnDelim;\n;\n/**\n * Reduce fn that joins neighboring strings\n *\n * Given an array of strings, returns a new array\n * where all neighboring strings have been joined.\n *\n * #### Example:\n * ```js\n * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n * ```\n */\nfunction joinNeighborsR(acc, x) {\n    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n    return common_1.pushR(acc, x);\n}\nexports.joinNeighborsR = joinNeighborsR;\n;\n//# sourceMappingURL=strings.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/common/strings.js\n// module id = 5\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Transition tracing (debug)\n *\n * Enable transition tracing to print transition information to the console,\n * in order to help debug your application.\n * Tracing logs detailed information about each Transition to your console.\n *\n * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n *\n * ### ES6\n * ```js\n * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n * ```\n *\n * ### CJS\n * ```js\n * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n * ```\n *\n * ### Globals\n * ```js\n * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n * trace.enable(); // Trace everything (very verbose)\n * ```\n *\n * ### Angular 1:\n * ```js\n * app.run($trace => $trace.enable());\n * ```\n *\n * @coreapi\n * @module trace\n */ /** for typedoc */\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar strings_1 = require(\"./strings\");\n/** @hidden */\nfunction uiViewString(viewData) {\n    if (!viewData)\n        return 'ui-view (defunct)';\n    return \"[ui-view#\" + viewData.id + \" tag \" +\n        (\"in template from '\" + (viewData.creationContext && viewData.creationContext.name || '(root)') + \"' state]: \") +\n        (\"fqn: '\" + viewData.fqn + \"', \") +\n        (\"name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\");\n}\n/** @hidden */\nvar viewConfigString = function (viewConfig) {\n    return \"[ViewConfig#\" + viewConfig.$id + \" from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\";\n};\n/** @hidden */\nfunction normalizedCat(input) {\n    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n}\n/**\n * Trace categories Enum\n *\n * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n *\n * `trace.enable(Category.TRANSITION)`\n *\n * These can also be provided using a matching string, or position ordinal\n *\n * `trace.enable(\"TRANSITION\")`\n *\n * `trace.enable(1)`\n */\nvar Category;\n(function (Category) {\n    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n    Category[Category[\"UIVIEW\"] = 3] = \"UIVIEW\";\n    Category[Category[\"VIEWCONFIG\"] = 4] = \"VIEWCONFIG\";\n})(Category = exports.Category || (exports.Category = {}));\n/** @hidden */ var _tid = hof_1.parse(\"$id\");\n/** @hidden */ var _rid = hof_1.parse(\"router.$id\");\n/** @hidden */ var transLbl = function (trans) { return \"Transition #\" + _tid(trans) + \"-\" + _rid(trans); };\n/**\n * Prints UI-Router Transition trace information to the console.\n */\nvar Trace = (function () {\n    /** @hidden */\n    function Trace() {\n        /** @hidden */\n        this._enabled = {};\n        this.approximateDigests = 0;\n    }\n    /** @hidden */\n    Trace.prototype._set = function (enabled, categories) {\n        var _this = this;\n        if (!categories.length) {\n            categories = Object.keys(Category)\n                .map(function (k) { return parseInt(k, 10); })\n                .filter(function (k) { return !isNaN(k); })\n                .map(function (key) { return Category[key]; });\n        }\n        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n    };\n    /**\n     * Enables a trace [[Category]]\n     *\n     * ```js\n     * trace.enable(\"TRANSITION\");\n     * ```\n     *\n     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.enable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(true, categories);\n    };\n    /**\n     * Disables a trace [[Category]]\n     *\n     * ```js\n     * trace.disable(\"VIEWCONFIG\");\n     * ```\n     *\n     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n     *        Also takes strings (category name) or ordinal (category position)\n     */\n    Trace.prototype.disable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(false, categories);\n    };\n    /**\n     * Retrieves the enabled stateus of a [[Category]]\n     *\n     * ```js\n     * trace.enabled(\"VIEWCONFIG\"); // true or false\n     * ```\n     *\n     * @returns boolean true if the category is enabled\n     */\n    Trace.prototype.enabled = function (category) {\n        return !!this._enabled[normalizedCat(category)];\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionStart = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": Started  -> \" + strings_1.stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionIgnored = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": Ignored  <> \" + strings_1.stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.registeredHook.callback);\n        console.log(transLbl(trans) + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        console.log(transLbl(trans) + \":   <- Hook returned: \" + strings_1.maxLength(200, strings_1.stringify(hookResult)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvePath = function (path, when, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + \":         Resolving \" + path + \" (\" + when + \")\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + \":               <- Resolved  \" + resolvable + \" to: \" + strings_1.maxLength(200, strings_1.stringify(resolvable.data)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceError = function (reason, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": <- Rejected \" + strings_1.stringify(trans) + \", reason: \" + reason);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceSuccess = function (finalState, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + \": <- Success  \" + strings_1.stringify(trans) + \", final state: \" + finalState.name);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n        if (extra === void 0) { extra = \"\"; }\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewFill = function (viewData, html) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n    };\n    return Trace;\n}());\nexports.Trace = Trace;\n/**\n * The [[Trace]] singleton\n *\n * #### Example:\n * ```js\n * import {trace} from \"angular-ui-router\";\n * trace.enable(1, 5);\n * ```\n */\nvar trace = new Trace();\nexports.trace = trace;\n//# sourceMappingURL=trace.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/common/trace.js\n// module id = 6\n// module chunks = 0","\"use strict\";\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\n/**\n * Encapsulate the target (destination) state/params/options of a [[Transition]].\n *\n * This class is frequently used to redirect a transition to a new destination.\n *\n * See:\n *\n * - [[HookResult]]\n * - [[TransitionHookFn]]\n * - [[TransitionService.onStart]]\n *\n * To create a `TargetState`, use [[StateService.target]].\n *\n * ---\n *\n * This class wraps:\n *\n * 1) an identifier for a state\n * 2) a set of parameters\n * 3) and transition options\n * 4) the registered state object (the [[StateDeclaration]])\n *\n * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).\n * The `TargetState` class normalizes those options.\n *\n * A `TargetState` may be valid (the state being targeted exists in the registry)\n * or invalid (the state being targeted is not registered).\n */\nvar TargetState = (function () {\n    /**\n     * The TargetState constructor\n     *\n     * Note: Do not construct a `TargetState` manually.\n     * To create a `TargetState`, use the [[StateService.target]] factory method.\n     *\n     * @param _identifier An identifier for a state.\n     *    Either a fully-qualified state name, or the object used to define the state.\n     * @param _definition The internal state representation, if exists.\n     * @param _params Parameters for the target state\n     * @param _options Transition options.\n     *\n     * @internalapi\n     */\n    function TargetState(_identifier, _definition, _params, _options) {\n        if (_options === void 0) { _options = {}; }\n        this._identifier = _identifier;\n        this._definition = _definition;\n        this._options = _options;\n        this._params = _params || {};\n    }\n    /** The name of the state this object targets */\n    TargetState.prototype.name = function () {\n        return this._definition && this._definition.name || this._identifier;\n    };\n    /** The identifier used when creating this TargetState */\n    TargetState.prototype.identifier = function () {\n        return this._identifier;\n    };\n    /** The target parameter values */\n    TargetState.prototype.params = function () {\n        return this._params;\n    };\n    /** The internal state object (if it was found) */\n    TargetState.prototype.$state = function () {\n        return this._definition;\n    };\n    /** The internal state declaration (if it was found) */\n    TargetState.prototype.state = function () {\n        return this._definition && this._definition.self;\n    };\n    /** The target options */\n    TargetState.prototype.options = function () {\n        return this._options;\n    };\n    /** True if the target state was found */\n    TargetState.prototype.exists = function () {\n        return !!(this._definition && this._definition.self);\n    };\n    /** True if the object is valid */\n    TargetState.prototype.valid = function () {\n        return !this.error();\n    };\n    /** If the object is invalid, returns the reason why */\n    TargetState.prototype.error = function () {\n        var base = this.options().relative;\n        if (!this._definition && !!base) {\n            var stateName = base.name ? base.name : base;\n            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n        }\n        if (!this._definition)\n            return \"No such state '\" + this.name() + \"'\";\n        if (!this._definition.self)\n            return \"State '\" + this.name() + \"' has an invalid definition\";\n    };\n    TargetState.prototype.toString = function () {\n        return \"'\" + this.name() + \"'\" + common_1.toJson(this.params());\n    };\n    return TargetState;\n}());\n/** Returns true if the object has a state property that might be a state or state name */\nTargetState.isDef = function (obj) {\n    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n};\nexports.TargetState = TargetState;\n//# sourceMappingURL=targetState.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/state/targetState.js\n// module id = 7\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ng_from_import = require(\"angular\");\nvar ng_from_global = angular;\nexports.ng = (ng_from_import && ng_from_import.module) ? ng_from_import : ng_from_global;\n//# sourceMappingURL=angular.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/angular.js\n// module id = 8\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar paramType_1 = require(\"./paramType\");\n/** @hidden */ var hasOwn = Object.prototype.hasOwnProperty;\n/** @hidden */ var isShorthand = function (cfg) {\n    return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0;\n};\n/** @internalapi */\nvar DefType;\n(function (DefType) {\n    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n})(DefType = exports.DefType || (exports.DefType = {}));\n/** @hidden */\nfunction unwrapShorthand(cfg) {\n    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n    getStaticDefaultValue['__cacheable'] = true;\n    function getStaticDefaultValue() {\n        return cfg.value;\n    }\n    return common_1.extend(cfg, {\n        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,\n    });\n}\n/** @hidden */\nfunction getType(cfg, urlType, location, id, paramTypes) {\n    if (cfg.type && urlType && urlType.name !== 'string')\n        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n        return paramTypes.type(cfg.type);\n    if (urlType)\n        return urlType;\n    if (!cfg.type) {\n        var type = location === DefType.CONFIG ? \"any\" :\n            location === DefType.PATH ? \"path\" :\n                location === DefType.SEARCH ? \"query\" : \"string\";\n        return paramTypes.type(type);\n    }\n    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/**\n * @internalapi\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n    var squash = config.squash;\n    if (!isOptional || squash === false)\n        return false;\n    if (!predicates_1.isDefined(squash) || squash == null)\n        return defaultPolicy;\n    if (squash === true || predicates_1.isString(squash))\n        return squash;\n    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n}\n/** @internalapi */\nfunction getReplace(config, arrayMode, isOptional, squash) {\n    var replace, configuredKeys, defaultPolicy = [\n        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") },\n    ];\n    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n    if (predicates_1.isString(squash))\n        replace.push({ from: squash, to: undefined });\n    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n}\n/** @internalapi */\nvar Param = (function () {\n    function Param(id, type, config, location, urlMatcherFactory) {\n        config = unwrapShorthand(config);\n        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n        var arrayMode = getArrayMode();\n        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n        var replace = getReplace(config, arrayMode, isOptional, squash);\n        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n        function getArrayMode() {\n            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n        }\n        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config });\n    }\n    Param.prototype.isDefaultValue = function (value) {\n        return this.isOptional && this.type.equals(this.value(), value);\n    };\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    Param.prototype.value = function (value) {\n        var _this = this;\n        /**\n         * [Internal] Get the default value of a parameter, which may be an injectable function.\n         */\n        var getDefaultValue = function () {\n            if (_this._defaultValueCache)\n                return _this._defaultValueCache.defaultValue;\n            if (!coreservices_1.services.$injector)\n                throw new Error(\"Injectable functions cannot be called at configuration time\");\n            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n            if (_this.config.$$fn['__cacheable']) {\n                _this._defaultValueCache = { defaultValue: defaultValue };\n            }\n            return defaultValue;\n        };\n        var replaceSpecialValues = function (val) {\n            for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {\n                var tuple = _a[_i];\n                if (tuple.from === val)\n                    return tuple.to;\n            }\n            return val;\n        };\n        value = replaceSpecialValues(value);\n        return predicates_1.isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n    };\n    Param.prototype.isSearch = function () {\n        return this.location === DefType.SEARCH;\n    };\n    Param.prototype.validates = function (value) {\n        // There was no parameter value, but the param is optional\n        if ((predicates_1.isUndefined(value) || value === null) && this.isOptional)\n            return true;\n        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n        var normalized = this.type.$normalize(value);\n        if (!this.type.is(normalized))\n            return false;\n        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n        var encoded = this.type.encode(normalized);\n        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n    };\n    Param.prototype.toString = function () {\n        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n    };\n    Param.values = function (params, values) {\n        if (values === void 0) { values = {}; }\n        var paramValues = {};\n        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {\n            var param = params_1[_i];\n            paramValues[param.id] = param.value(values[param.id]);\n        }\n        return paramValues;\n    };\n    /**\n     * Finds [[Param]] objects which have different param values\n     *\n     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n     *\n     * @param params: The list of Param objects to filter\n     * @param values1: The first set of parameter values\n     * @param values2: the second set of parameter values\n     *\n     * @returns any Param objects whose values were different between values1 and values2\n     */\n    Param.changed = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n    };\n    /**\n     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n     *\n     * @param params The list of [[Param]] objects to check\n     * @param values1 The first set of param values\n     * @param values2 The second set of param values\n     *\n     * @returns true if the param values in values1 and values2 are equal\n     */\n    Param.equals = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return Param.changed(params, values1, values2).length === 0;\n    };\n    /** Returns true if a the parameter values are valid, according to the Param definitions */\n    Param.validates = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n    };\n    return Param;\n}());\nexports.Param = Param;\n//# sourceMappingURL=param.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/params/param.js\n// module id = 9\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TransitionHookPhase;\n(function (TransitionHookPhase) {\n    TransitionHookPhase[TransitionHookPhase[\"CREATE\"] = 0] = \"CREATE\";\n    TransitionHookPhase[TransitionHookPhase[\"BEFORE\"] = 1] = \"BEFORE\";\n    TransitionHookPhase[TransitionHookPhase[\"RUN\"] = 2] = \"RUN\";\n    TransitionHookPhase[TransitionHookPhase[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    TransitionHookPhase[TransitionHookPhase[\"ERROR\"] = 4] = \"ERROR\";\n})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\nvar TransitionHookScope;\n(function (TransitionHookScope) {\n    TransitionHookScope[TransitionHookScope[\"TRANSITION\"] = 0] = \"TRANSITION\";\n    TransitionHookScope[TransitionHookScope[\"STATE\"] = 1] = \"STATE\";\n})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/transition/interface.js\n// module id = 10\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module resolve\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar trace_1 = require(\"../common/trace\");\nvar strings_1 = require(\"../common/strings\");\nvar predicates_1 = require(\"../common/predicates\");\n// TODO: explicitly make this user configurable\nexports.defaultResolvePolicy = {\n    when: \"LAZY\",\n    async: \"WAIT\"\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nvar Resolvable = (function () {\n    function Resolvable(arg1, resolveFn, deps, policy, data) {\n        this.resolved = false;\n        this.promise = undefined;\n        if (arg1 instanceof Resolvable) {\n            common_1.extend(this, arg1);\n        }\n        else if (predicates_1.isFunction(resolveFn)) {\n            if (arg1 == null || arg1 == undefined)\n                throw new Error(\"new Resolvable(): token argument is required\");\n            if (!predicates_1.isFunction(resolveFn))\n                throw new Error(\"new Resolvable(): resolveFn argument must be a function\");\n            this.token = arg1;\n            this.policy = policy;\n            this.resolveFn = resolveFn;\n            this.deps = deps || [];\n            this.data = data;\n            this.resolved = data !== undefined;\n            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n        }\n        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n            var literal = arg1;\n            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n        }\n    }\n    Resolvable.prototype.getPolicy = function (state) {\n        var thisPolicy = this.policy || {};\n        var statePolicy = state && state.resolvePolicy || {};\n        return {\n            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n        };\n    };\n    /**\n     * Asynchronously resolve this Resolvable's data\n     *\n     * Given a ResolveContext that this Resolvable is found in:\n     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n     * and update the Resolvable's state\n     */\n    Resolvable.prototype.resolve = function (resolveContext, trans) {\n        var _this = this;\n        var $q = coreservices_1.services.$q;\n        // Gets all dependencies from ResolveContext and wait for them to be resolved\n        var getResolvableDependencies = function () {\n            return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) {\n                return resolvable.get(resolveContext, trans);\n            }));\n        };\n        // Invokes the resolve function passing the resolved dependencies as arguments\n        var invokeResolveFn = function (resolvedDeps) {\n            return _this.resolveFn.apply(null, resolvedDeps);\n        };\n        /**\n         * For RXWAIT policy:\n         *\n         * Given an observable returned from a resolve function:\n         * - enables .cache() mode (this allows multicast subscribers)\n         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n         * - Waits for the promise, then return the cached observable (not the first emitted value).\n         */\n        var waitForRx = function (observable$) {\n            var cached = observable$.cache(1);\n            return cached.take(1).toPromise().then(function () { return cached; });\n        };\n        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n        var node = resolveContext.findNode(this);\n        var state = node && node.state;\n        var maybeWaitForRx = this.getPolicy(state).async === \"RXWAIT\" ? waitForRx : common_1.identity;\n        // After the final value has been resolved, update the state of the Resolvable\n        var applyResolvedValue = function (resolvedValue) {\n            _this.data = resolvedValue;\n            _this.resolved = true;\n            trace_1.trace.traceResolvableResolved(_this, trans);\n            return _this.data;\n        };\n        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n        return this.promise = $q.when()\n            .then(getResolvableDependencies)\n            .then(invokeResolveFn)\n            .then(maybeWaitForRx)\n            .then(applyResolvedValue);\n    };\n    /**\n     * Gets a promise for this Resolvable's data.\n     *\n     * Fetches the data and returns a promise.\n     * Returns the existing promise if it has already been fetched once.\n     */\n    Resolvable.prototype.get = function (resolveContext, trans) {\n        return this.promise || this.resolve(resolveContext, trans);\n    };\n    Resolvable.prototype.toString = function () {\n        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n    };\n    Resolvable.prototype.clone = function () {\n        return new Resolvable(this);\n    };\n    return Resolvable;\n}());\nResolvable.fromData = function (token, data) {\n    return new Resolvable(token, function () { return data; }, null, null, data);\n};\nexports.Resolvable = Resolvable;\n//# sourceMappingURL=resolvable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/resolve/resolvable.js\n// module id = 11\n// module chunks = 0","/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = require(\"../common/common\");\nvar strings_1 = require(\"../common/strings\");\nvar hof_1 = require(\"../common/hof\");\nvar RejectType;\n(function (RejectType) {\n    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n    RejectType[RejectType[\"ERROR\"] = 6] = \"ERROR\";\n})(RejectType = exports.RejectType || (exports.RejectType = {}));\n/** @hidden */ var id = 0;\nvar Rejection = (function () {\n    function Rejection(type, message, detail) {\n        this.$id = id++;\n        this.type = type;\n        this.message = message;\n        this.detail = detail;\n    }\n    Rejection.prototype.toString = function () {\n        var detailString = function (d) {\n            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n        };\n        var detail = detailString(this.detail);\n        var _a = this, $id = _a.$id, type = _a.type, message = _a.message;\n        return \"Transition Rejection($id: \" + $id + \" type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n    };\n    Rejection.prototype.toPromise = function () {\n        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n    };\n    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n    Rejection.isRejectionPromise = function (obj) {\n        return obj && (typeof obj.then === 'function') && hof_1.is(Rejection)(obj._transitionRejection);\n    };\n    /** Returns a Rejection due to transition superseded */\n    Rejection.superseded = function (detail, options) {\n        var message = \"The transition has been superseded by a different transition\";\n        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n        if (options && options.redirected) {\n            rejection.redirected = true;\n        }\n        return rejection;\n    };\n    /** Returns a Rejection due to redirected transition */\n    Rejection.redirected = function (detail) {\n        return Rejection.superseded(detail, { redirected: true });\n    };\n    /** Returns a Rejection due to invalid transition */\n    Rejection.invalid = function (detail) {\n        var message = \"This transition is invalid\";\n        return new Rejection(RejectType.INVALID, message, detail);\n    };\n    /** Returns a Rejection due to ignored transition */\n    Rejection.ignored = function (detail) {\n        var message = \"The transition was ignored\";\n        return new Rejection(RejectType.IGNORED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.aborted = function (detail) {\n        var message = \"The transition has been aborted\";\n        return new Rejection(RejectType.ABORTED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.errored = function (detail) {\n        var message = \"The transition errored\";\n        return new Rejection(RejectType.ERROR, message, detail);\n    };\n    /**\n     * Returns a Rejection\n     *\n     * Normalizes a value as a Rejection.\n     * If the value is already a Rejection, returns it.\n     * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).\n     *\n     * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.\n     */\n    Rejection.normalize = function (detail) {\n        return hof_1.is(Rejection)(detail) ? detail : Rejection.errored(detail);\n    };\n    return Rejection;\n}());\nexports.Rejection = Rejection;\n//# sourceMappingURL=rejectFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/transition/rejectFactory.js\n// module id = 12\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar interface_1 = require(\"./interface\");\nvar common_1 = require(\"../common/common\");\nvar strings_1 = require(\"../common/strings\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar rejectFactory_1 = require(\"./rejectFactory\");\nvar targetState_1 = require(\"../state/targetState\");\nvar defaultOptions = {\n    current: common_1.noop,\n    transition: null,\n    traceData: {},\n    bind: null,\n};\n/** @hidden */\nvar TransitionHook = (function () {\n    function TransitionHook(transition, stateContext, registeredHook, options) {\n        var _this = this;\n        this.transition = transition;\n        this.stateContext = stateContext;\n        this.registeredHook = registeredHook;\n        this.options = options;\n        this.isSuperseded = function () {\n            return _this.type.hookPhase === interface_1.TransitionHookPhase.RUN && !_this.options.transition.isActive();\n        };\n        this.options = common_1.defaults(options, defaultOptions);\n        this.type = registeredHook.eventType;\n    }\n    TransitionHook.prototype.logError = function (err) {\n        this.transition.router.stateService.defaultErrorHandler()(err);\n    };\n    TransitionHook.prototype.invokeHook = function () {\n        var _this = this;\n        var hook = this.registeredHook;\n        if (hook._deregistered)\n            return;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        var options = this.options;\n        trace_1.trace.traceHookInvocation(this, this.transition, options);\n        var invokeCallback = function () {\n            return hook.callback.call(options.bind, _this.transition, _this.stateContext);\n        };\n        var normalizeErr = function (err) {\n            return rejectFactory_1.Rejection.normalize(err).toPromise();\n        };\n        var handleError = function (err) {\n            return hook.eventType.getErrorHandler(_this)(err);\n        };\n        var handleResult = function (result) {\n            return hook.eventType.getResultHandler(_this)(result);\n        };\n        try {\n            var result = invokeCallback();\n            if (!this.type.synchronous && predicates_1.isPromise(result)) {\n                return result.catch(normalizeErr)\n                    .then(handleResult, handleError);\n            }\n            else {\n                return handleResult(result);\n            }\n        }\n        catch (err) {\n            // If callback throws (synchronously)\n            return handleError(rejectFactory_1.Rejection.normalize(err));\n        }\n    };\n    /**\n     * This method handles the return value of a Transition Hook.\n     *\n     * A hook can return false (cancel), a TargetState (redirect),\n     * or a promise (which may later resolve to false or a redirect)\n     *\n     * This also handles \"transition superseded\" -- when a new transition\n     * was started while the hook was still running\n     */\n    TransitionHook.prototype.handleHookResult = function (result) {\n        var _this = this;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        // Hook returned a promise\n        if (predicates_1.isPromise(result)) {\n            // Wait for the promise, then reprocess with the resulting value\n            return result.then(function (val) { return _this.handleHookResult(val); });\n        }\n        trace_1.trace.traceHookResult(result, this.transition, this.options);\n        // Hook returned false\n        if (result === false) {\n            // Abort this Transition\n            return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise();\n        }\n        var isTargetState = hof_1.is(targetState_1.TargetState);\n        // hook returned a TargetState\n        if (isTargetState(result)) {\n            // Halt the current Transition and redirect (a new Transition) to the TargetState.\n            return rejectFactory_1.Rejection.redirected(result).toPromise();\n        }\n    };\n    /**\n     * Return a Rejection promise if the transition is no longer current due\n     * to a stopped router (disposed), or a new transition has started and superseded this one.\n     */\n    TransitionHook.prototype.getNotCurrentRejection = function () {\n        var router = this.transition.router;\n        // The router is stopped\n        if (router._disposed) {\n            return rejectFactory_1.Rejection.aborted(\"UIRouter instance #\" + router.$id + \" has been stopped (disposed)\").toPromise();\n        }\n        if (this.transition._aborted) {\n            return rejectFactory_1.Rejection.aborted().toPromise();\n        }\n        // This transition is no longer current.\n        // Another transition started while this hook was still running.\n        if (this.isSuperseded()) {\n            // Abort this transition\n            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n        }\n    };\n    TransitionHook.prototype.toString = function () {\n        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(registeredHook.callback);\n        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n    };\n    /**\n     * Chains together an array of TransitionHooks.\n     *\n     * Given a list of [[TransitionHook]] objects, chains them together.\n     * Each hook is invoked after the previous one completes.\n     *\n     * #### Example:\n     * ```js\n     * var hooks: TransitionHook[] = getHooks();\n     * let promise: Promise<any> = TransitionHook.chain(hooks);\n     *\n     * promise.then(handleSuccess, handleError);\n     * ```\n     *\n     * @param hooks the list of hooks to chain together\n     * @param waitFor if provided, the chain is `.then()`'ed off this promise\n     * @returns a `Promise` for sequentially invoking the hooks (in order)\n     */\n    TransitionHook.chain = function (hooks, waitFor) {\n        // Chain the next hook off the previous\n        var createHookChainR = function (prev, nextHook) {\n            return prev.then(function () { return nextHook.invokeHook(); });\n        };\n        return hooks.reduce(createHookChainR, waitFor || coreservices_1.services.$q.when());\n    };\n    /**\n     * Invokes all the provided TransitionHooks, in order.\n     * Each hook's return value is checked.\n     * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n     * If no hook returns a promise, then all hooks are processed synchronously.\n     *\n     * @param hooks the list of TransitionHooks to invoke\n     * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n     *\n     * @returns a promise for the async result, or the result of the callback\n     */\n    TransitionHook.invokeHooks = function (hooks, doneCallback) {\n        for (var idx = 0; idx < hooks.length; idx++) {\n            var hookResult = hooks[idx].invokeHook();\n            if (predicates_1.isPromise(hookResult)) {\n                var remainingHooks = hooks.slice(idx + 1);\n                return TransitionHook.chain(remainingHooks, hookResult)\n                    .then(doneCallback);\n            }\n        }\n        return doneCallback();\n    };\n    /**\n     * Run all TransitionHooks, ignoring their return value.\n     */\n    TransitionHook.runAllHooks = function (hooks) {\n        hooks.forEach(function (hook) { return hook.invokeHook(); });\n    };\n    return TransitionHook;\n}());\n/**\n * These GetResultHandler(s) are used by [[invokeHook]] below\n * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n */\nTransitionHook.HANDLE_RESULT = function (hook) { return function (result) {\n    return hook.handleHookResult(result);\n}; };\n/**\n * If the result is a promise rejection, log it.\n * Otherwise, ignore the result.\n */\nTransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {\n    predicates_1.isPromise(result) && result.catch(function (err) {\n        return hook.logError(rejectFactory_1.Rejection.normalize(err));\n    });\n    return undefined;\n}; };\n/**\n * These GetErrorHandler(s) are used by [[invokeHook]] below\n * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n */\nTransitionHook.LOG_ERROR = function (hook) { return function (error) {\n    return hook.logError(error);\n}; };\nTransitionHook.REJECT_ERROR = function (hook) { return function (error) {\n    return common_1.silentRejection(error);\n}; };\nTransitionHook.THROW_ERROR = function (hook) { return function (error) {\n    throw error;\n}; };\nexports.TransitionHook = TransitionHook;\n//# sourceMappingURL=transitionHook.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/transition/transitionHook.js\n// module id = 13\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\nvar common_1 = require(\"../common/common\");\nvar beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return [\"\", \"\"];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, \"\"];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\nexports.splitHash = beforeAfterSubstr(\"#\");\nexports.splitQuery = beforeAfterSubstr(\"?\");\nexports.splitEqual = beforeAfterSubstr(\"=\");\nexports.trimHashVal = function (str) { return str ? str.replace(/^#/, \"\") : \"\"; };\nexports.keyValsToObjectR = function (accum, _a) {\n    var key = _a[0], val = _a[1];\n    if (!accum.hasOwnProperty(key)) {\n        accum[key] = val;\n    }\n    else if (index_1.isArray(accum[key])) {\n        accum[key].push(val);\n    }\n    else {\n        accum[key] = [accum[key], val];\n    }\n    return accum;\n};\nexports.getParams = function (queryString) {\n    return queryString.split(\"&\").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});\n};\nfunction parseUrl(url) {\n    var orEmptyString = function (x) { return x || \"\"; };\n    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n    return { path: path, search: search, hash: hash, url: url };\n}\nexports.parseUrl = parseUrl;\nexports.buildUrl = function (loc) {\n    var path = loc.path();\n    var searchObject = loc.search();\n    var hash = loc.hash();\n    var search = Object.keys(searchObject).map(function (key) {\n        var param = searchObject[key];\n        var vals = index_1.isArray(param) ? param : [param];\n        return vals.map(function (val) { return key + \"=\" + val; });\n    }).reduce(common_1.unnestR, []).join(\"&\");\n    return path + (search ? \"?\" + search : \"\") + (hash ? \"#\" + hash : \"\");\n};\nfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n    return function (router) {\n        var service = router.locationService = new serviceClass(router);\n        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n        function dispose(router) {\n            router.dispose(service);\n            router.dispose(configuration);\n        }\n        return { name: name, service: service, configuration: configuration, dispose: dispose };\n    };\n}\nexports.locationPluginFactory = locationPluginFactory;\n//# sourceMappingURL=utils.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla/utils.js\n// module id = 14\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */\n/**\n * Matches state names using glob-like pattern strings.\n *\n * Globs can be used in specific APIs including:\n *\n * - [[StateService.is]]\n * - [[StateService.includes]]\n * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n *\n * A `Glob` string is a pattern which matches state names.\n * Nested state names are split into segments (separated by a dot) when processing.\n * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n *\n * Globs work according to the following rules:\n *\n * ### Exact match:\n *\n * The glob `'A.B'` matches the state named exactly `'A.B'`.\n *\n * | Glob        |Matches states named|Does not match state named|\n * |:------------|:--------------------|:---------------------|\n * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n *\n * ### Single star (`*`)\n *\n * A single star (`*`) is a wildcard that matches exactly one segment.\n *\n * | Glob        |Matches states named  |Does not match state named |\n * |:------------|:---------------------|:--------------------------|\n * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n *\n * ### Double star (`**`)\n *\n * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n *\n * | Glob        |Matches states named                           |Does not match state named         |\n * |:------------|:----------------------------------------------|:----------------------------------|\n * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n *\n */\nvar Glob = (function () {\n    function Glob(text) {\n        this.text = text;\n        this.glob = text.split('.');\n        var regexpString = this.text.split('.')\n            .map(function (seg) {\n            if (seg === '**')\n                return '(?:|(?:\\\\.[^.]*)*)';\n            if (seg === '*')\n                return '\\\\.[^.]*';\n            return '\\\\.' + seg;\n        }).join('');\n        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n    }\n    Glob.prototype.matches = function (name) {\n        return this.regexp.test('.' + name);\n    };\n    /** Returns true if the string has glob-like characters in it */\n    Glob.is = function (text) {\n        return !!/[!,*]+/.exec(text);\n    };\n    /** Returns a glob from the string, or null if the string isn't Glob-like */\n    Glob.fromString = function (text) {\n        return Glob.is(text) ? new Glob(text) : null;\n    };\n    return Glob;\n}());\nexports.Glob = Glob;\n//# sourceMappingURL=glob.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/common/glob.js\n// module id = 15\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module common */ /** for typedoc */\n__export(require(\"./common\"));\n__export(require(\"./coreservices\"));\n__export(require(\"./glob\"));\n__export(require(\"./hof\"));\n__export(require(\"./predicates\"));\n__export(require(\"./queue\"));\n__export(require(\"./strings\"));\n__export(require(\"./trace\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/common/index.js\n// module id = 16\n// module chunks = 0","\"use strict\";\n/** @module path */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar targetState_1 = require(\"../state/targetState\");\nvar pathNode_1 = require(\"./pathNode\");\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nvar PathUtils = (function () {\n    function PathUtils() {\n    }\n    /** Given a PathNode[], create an TargetState */\n    PathUtils.makeTargetState = function (path) {\n        var state = common_1.tail(path).state;\n        return new targetState_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    PathUtils.buildPath = function (targetState) {\n        var toParams = targetState.params();\n        return targetState.$state().path.map(function (state) { return new pathNode_1.PathNode(state).applyRawParams(toParams); });\n    };\n    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n    PathUtils.buildToPath = function (fromPath, targetState) {\n        var toPath = PathUtils.buildPath(targetState);\n        if (targetState.options().inherit) {\n            return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n        }\n        return toPath;\n    };\n    /**\n     * Creates ViewConfig objects and adds to nodes.\n     *\n     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n     */\n    PathUtils.applyViewConfigs = function ($view, path, states) {\n        // Only apply the viewConfigs to the nodes for the given states\n        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n            var viewDecls = common_1.values(node.state.views || {});\n            var subPath = PathUtils.subPath(path, function (n) { return n === node; });\n            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n            node.views = viewConfigs.reduce(common_1.unnestR, []);\n        });\n    };\n    /**\n     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n     *\n     * For a parameter in a node to be inherited from the from path:\n     * - The toPath's node must have a matching node in the fromPath (by state).\n     * - The parameter name must not be found in the toKeys parameter array.\n     *\n     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n     * it is not inherited from the fromPath.\n     */\n    PathUtils.inheritParams = function (fromPath, toPath, toKeys) {\n        if (toKeys === void 0) { toKeys = []; }\n        function nodeParamVals(path, state) {\n            var node = common_1.find(path, hof_1.propEq('state', state));\n            return common_1.extend({}, node && node.paramValues);\n        }\n        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (param) { return !param.inherit; })\n            .map(hof_1.prop('id'));\n        /**\n         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n         */\n        function makeInheritedParamsNode(toNode) {\n            // All param values for the node (may include default key/vals, when key was not found in toParams)\n            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n            // limited to only those keys found in toParams\n            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n            toParamVals = common_1.omit(toParamVals, toKeys);\n            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n            return new pathNode_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n        }\n        // The param keys specified by the incoming toParams\n        return toPath.map(makeInheritedParamsNode);\n    };\n    /**\n     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n     */\n    PathUtils.treeChanges = function (fromPath, toPath, reloadState) {\n        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n        var nodesMatch = function (node1, node2) {\n            return node1.equals(node2, PathUtils.nonDynamicParams);\n        };\n        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n            keep++;\n        }\n        /** Given a retained node, return a new node which uses the to node's param values */\n        function applyToParams(retainedNode, idx) {\n            var cloned = pathNode_1.PathNode.clone(retainedNode);\n            cloned.paramValues = toPath[idx].paramValues;\n            return cloned;\n        }\n        var from, retained, exiting, entering, to;\n        from = fromPath;\n        retained = from.slice(0, keep);\n        exiting = from.slice(keep);\n        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n        var retainedWithToParams = retained.map(applyToParams);\n        entering = toPath.slice(keep);\n        to = (retainedWithToParams).concat(entering);\n        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n    };\n    /**\n     * Returns a new path which is: the subpath of the first path which matches the second path.\n     *\n     * The new path starts from root and contains any nodes that match the nodes in the second path.\n     * It stops before the first non-matching node.\n     *\n     * Nodes are compared using their state property and their parameter values.\n     * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n     *\n     * @param pathA the first path\n     * @param pathB the second path\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     *\n     * @returns an array of PathNodes from the first path which match the nodes in the second path\n     */\n    PathUtils.matching = function (pathA, pathB, paramsFn) {\n        var done = false;\n        var tuples = common_1.arrayTuples(pathA, pathB);\n        return tuples.reduce(function (matching, _a) {\n            var nodeA = _a[0], nodeB = _a[1];\n            done = done || !nodeA.equals(nodeB, paramsFn);\n            return done ? matching : matching.concat(nodeA);\n        }, []);\n    };\n    /**\n     * Returns true if two paths are identical.\n     *\n     * @param pathA\n     * @param pathB\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     * @returns true if the the states and parameter values for both paths are identical\n     */\n    PathUtils.equals = function (pathA, pathB, paramsFn) {\n        return pathA.length === pathB.length &&\n            PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n    };\n    /**\n     * Return a subpath of a path, which stops at the first matching node\n     *\n     * Given an array of nodes, returns a subset of the array starting from the first node,\n     * stopping when the first node matches the predicate.\n     *\n     * @param path a path of [[PathNode]]s\n     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n     * @returns a subpath up to the matching node, or undefined if no match is found\n     */\n    PathUtils.subPath = function (path, predicate) {\n        var node = common_1.find(path, predicate);\n        var elementIdx = path.indexOf(node);\n        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n    };\n    return PathUtils;\n}());\nPathUtils.nonDynamicParams = function (node) {\n    return node.state.parameters({ inherit: false })\n        .filter(function (param) { return !param.dynamic; });\n};\n/** Gets the raw parameter values from a path */\nPathUtils.paramValues = function (path) {\n    return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {});\n};\nexports.PathUtils = PathUtils;\n//# sourceMappingURL=pathFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/path/pathFactory.js\n// module id = 17\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module resolve */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar interface_1 = require(\"./interface\");\nvar resolvable_1 = require(\"./resolvable\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar strings_1 = require(\"../common/strings\");\nvar when = interface_1.resolvePolicies.when;\nvar ALL_WHENS = [when.EAGER, when.LAZY];\nvar EAGER_WHENS = [when.EAGER];\nexports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nvar ResolveContext = (function () {\n    function ResolveContext(_path) {\n        this._path = _path;\n    }\n    /** Gets all the tokens found in the resolve context, de-duplicated */\n    ResolveContext.prototype.getTokens = function () {\n        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n    };\n    /**\n     * Gets the Resolvable that matches the token\n     *\n     * Gets the last Resolvable that matches the token in this context, or undefined.\n     * Throws an error if it doesn't exist in the ResolveContext\n     */\n    ResolveContext.prototype.getResolvable = function (token) {\n        var matching = this._path.map(function (node) { return node.resolvables; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (r) { return r.token === token; });\n        return common_1.tail(matching);\n    };\n    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n    ResolveContext.prototype.getPolicy = function (resolvable) {\n        var node = this.findNode(resolvable);\n        return resolvable.getPolicy(node.state);\n    };\n    /**\n     * Returns a ResolveContext that includes a portion of this one\n     *\n     * Given a state, this method creates a new ResolveContext from this one.\n     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n     *\n     * #### Why\n     *\n     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n     * This method is used to create a narrower context when injecting ancestor nodes.\n     *\n     * @example\n     * `let ABCD = new ResolveContext([A, B, C, D]);`\n     *\n     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n     * However, `B` should only be able to access resolvables from `A`, `B`.\n     *\n     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n     * `let AB = ABCD.subcontext(a)`\n     */\n    ResolveContext.prototype.subContext = function (state) {\n        return new ResolveContext(pathFactory_1.PathUtils.subPath(this._path, function (node) { return node.state === state; }));\n    };\n    /**\n     * Adds Resolvables to the node that matches the state\n     *\n     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n     * The resolvable is added to the node matching the `state` parameter.\n     *\n     * These new resolvables are not automatically fetched.\n     * The calling code should either fetch them, fetch something that depends on them,\n     * or rely on [[resolvePath]] being called when some state is being entered.\n     *\n     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n     *\n     * @param newResolvables the new Resolvables\n     * @param state Used to find the node to put the resolvable on\n     */\n    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n        var node = common_1.find(this._path, hof_1.propEq('state', state));\n        var keys = newResolvables.map(function (r) { return r.token; });\n        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n    };\n    /**\n     * Returns a promise for an array of resolved path Element promises\n     *\n     * @param when\n     * @param trans\n     * @returns {Promise<any>|any}\n     */\n    ResolveContext.prototype.resolvePath = function (when, trans) {\n        var _this = this;\n        if (when === void 0) { when = \"LAZY\"; }\n        // This option determines which 'when' policy Resolvables we are about to fetch.\n        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n        // get the subpath to the state argument, if provided\n        trace_1.trace.traceResolvePath(this._path, when, trans);\n        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n            return function (resolvable) {\n                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n            };\n        };\n        // Trigger all the (matching) Resolvables in the path\n        // Reduce all the \"WAIT\" Resolvables into an array\n        var promises = this._path.reduce(function (acc, node) {\n            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n            // For the matching Resolvables, start their async fetch process.\n            var subContext = _this.subContext(node.state);\n            var getResult = function (r) { return r.get(subContext, trans)\n                .then(function (value) { return ({ token: r.token, value: value }); }); };\n            nowait.forEach(getResult);\n            return acc.concat(wait.map(getResult));\n        }, []);\n        // Wait for all the \"WAIT\" resolvables\n        return coreservices_1.services.$q.all(promises);\n    };\n    ResolveContext.prototype.injector = function () {\n        return this._injector || (this._injector = new UIInjectorImpl(this));\n    };\n    ResolveContext.prototype.findNode = function (resolvable) {\n        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n    };\n    /**\n     * Gets the async dependencies of a Resolvable\n     *\n     * Given a Resolvable, returns its dependencies as a Resolvable[]\n     */\n    ResolveContext.prototype.getDependencies = function (resolvable) {\n        var _this = this;\n        var node = this.findNode(resolvable);\n        // Find which other resolvables are \"visible\" to the `resolvable` argument\n        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n        var subPath = pathFactory_1.PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;\n        var availableResolvables = subPath\n            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables\n            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n        var getDependency = function (token) {\n            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n            if (matching.length)\n                return common_1.tail(matching);\n            var fromInjector = _this.injector().getNative(token);\n            if (!fromInjector) {\n                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n            }\n            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n        };\n        return resolvable.deps.map(getDependency);\n    };\n    return ResolveContext;\n}());\nexports.ResolveContext = ResolveContext;\nvar UIInjectorImpl = (function () {\n    function UIInjectorImpl(context) {\n        this.context = context;\n        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n    }\n    UIInjectorImpl.prototype.get = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable) {\n            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n                return resolvable.get(this.context);\n            }\n            if (!resolvable.resolved) {\n                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n            }\n            return resolvable.data;\n        }\n        return this.native && this.native.get(token);\n    };\n    UIInjectorImpl.prototype.getAsync = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable)\n            return resolvable.get(this.context);\n        return coreservices_1.services.$q.when(this.native.get(token));\n    };\n    UIInjectorImpl.prototype.getNative = function (token) {\n        return this.native && this.native.get(token);\n    };\n    return UIInjectorImpl;\n}());\n//# sourceMappingURL=resolveContext.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/resolve/resolveContext.js\n// module id = 18\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar trace_1 = require(\"../common/trace\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar interface_1 = require(\"./interface\"); // has or is using\nvar transitionHook_1 = require(\"./transitionHook\");\nvar hookRegistry_1 = require(\"./hookRegistry\");\nvar hookBuilder_1 = require(\"./hookBuilder\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar targetState_1 = require(\"../state/targetState\");\nvar param_1 = require(\"../params/param\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\n/** @hidden */\nvar stateSelf = hof_1.prop(\"self\");\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nvar Transition = (function () {\n    /**\n     * Creates a new Transition object.\n     *\n     * If the target state is not valid, an error is thrown.\n     *\n     * @internalapi\n     *\n     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n     *        encapsulates the \"from state\".\n     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n     * @param router The [[UIRouter]] instance\n     */\n    function Transition(fromPath, targetState, router) {\n        var _this = this;\n        /** @hidden */\n        this._deferred = coreservices_1.services.$q.defer();\n        /**\n         * This promise is resolved or rejected based on the outcome of the Transition.\n         *\n         * When the transition is successful, the promise is resolved\n         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n         */\n        this.promise = this._deferred.promise;\n        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n        this._registeredHooks = {};\n        /** @hidden */\n        this._hookBuilder = new hookBuilder_1.HookBuilder(this);\n        /** Checks if this transition is currently active/running. */\n        this.isActive = function () {\n            return _this.router.globals.transition === _this;\n        };\n        this.router = router;\n        this._targetState = targetState;\n        if (!targetState.valid()) {\n            throw new Error(targetState.error());\n        }\n        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n        this.$id = router.transitionService._transitionCount++;\n        var toPath = pathFactory_1.PathUtils.buildToPath(fromPath, targetState);\n        this._treeChanges = pathFactory_1.PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n        this.createTransitionHookRegFns();\n        var onCreateHooks = this._hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n        transitionHook_1.TransitionHook.invokeHooks(onCreateHooks, function () { return null; });\n        this.applyViewConfigs(router);\n    }\n    /** @hidden */\n    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onError = function (criteria, callback, options) { return; };\n    /** @hidden\n     * Creates the transition-level hook registration functions\n     * (which can then be used to register hooks)\n     */\n    Transition.prototype.createTransitionHookRegFns = function () {\n        var _this = this;\n        this.router.transitionService._pluginapi._getEvents()\n            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n    };\n    /** @internalapi */\n    Transition.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    Transition.prototype.applyViewConfigs = function (router) {\n        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n        pathFactory_1.PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal from [State] object\n     */\n    Transition.prototype.$from = function () {\n        return common_1.tail(this._treeChanges.from).state;\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal to [State] object\n     */\n    Transition.prototype.$to = function () {\n        return common_1.tail(this._treeChanges.to).state;\n    };\n    /**\n     * Returns the \"from state\"\n     *\n     * Returns the state that the transition is coming *from*.\n     *\n     * @returns The state declaration object for the Transition's (\"from state\").\n     */\n    Transition.prototype.from = function () {\n        return this.$from().self;\n    };\n    /**\n     * Returns the \"to state\"\n     *\n     * Returns the state that the transition is going *to*.\n     *\n     * @returns The state declaration object for the Transition's target state (\"to state\").\n     */\n    Transition.prototype.to = function () {\n        return this.$to().self;\n    };\n    /**\n     * Gets the Target State\n     *\n     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n     *\n     * @returns the [[TargetState]] of this Transition\n     */\n    Transition.prototype.targetState = function () {\n        return this._targetState;\n    };\n    /**\n     * Determines whether two transitions are equivalent.\n     * @deprecated\n     */\n    Transition.prototype.is = function (compare) {\n        if (compare instanceof Transition) {\n            // TODO: Also compare parameters\n            return this.is({ to: compare.$to().name, from: compare.$from().name });\n        }\n        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n    };\n    Transition.prototype.params = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    /**\n     * Creates a [[UIInjector]] Dependency Injector\n     *\n     * Returns a Dependency Injector for the Transition's target state (to state).\n     * The injector provides resolve values which the target state has access to.\n     *\n     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n     *\n     * #### Example:\n     * ```js\n     * .onEnter({ entering: 'myState' }, trans => {\n     *   var myResolveValue = trans.injector().get('myResolve');\n     *   // Inject a global service from the global/native injector (if it exists)\n     *   var MyService = trans.injector().get('MyService');\n     * })\n     * ```\n     *\n     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n     * #### Example:\n     * ```js\n     * .onBefore({}, trans => {\n     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n     *     return myResolveValue !== 'ABORT';\n     *   });\n     * });\n     * ```\n     *\n     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n     * #### Example:\n     * ```js\n     * .onEnter({ to: 'foo.bar' }, trans => {\n     *   // returns result of `foo` state's `data` resolve\n     *   // even though `foo.bar` also has a `data` resolve\n     *   var fooData = trans.injector('foo').get('data');\n     * });\n     * ```\n     *\n     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n     * The resolve data from the `from` path will be returned.\n     * #### Example:\n     * ```js\n     * .onExit({ exiting: 'foo.bar' }, trans => {\n     *   // Gets the resolve value of `data` from the exiting state.\n     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n     * });\n     * ```\n     *\n     *\n     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n     *\n     * @returns a [[UIInjector]]\n     */\n    Transition.prototype.injector = function (state, pathName) {\n        if (pathName === void 0) { pathName = \"to\"; }\n        var path = this._treeChanges[pathName];\n        if (state)\n            path = pathFactory_1.PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n        return new resolveContext_1.ResolveContext(path).injector();\n    };\n    /**\n     * Gets all available resolve tokens (keys)\n     *\n     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n     * available to the Transition.\n     *\n     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n     * in the Transition's [[TreeChanges.to]] path.\n     *\n     * #### Example:\n     * This example logs all resolve values\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n     * ```\n     *\n     * #### Example:\n     * This example creates promises for each resolve value.\n     * This triggers fetches of resolves (if any have not yet been fetched).\n     * When all promises have all settled, it logs the resolve values.\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * let promise = tokens.map(token => trans.injector().getAsync(token));\n     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n     * ```\n     *\n     * Note: Angular 1 users whould use `$q.all()`\n     *\n     * @param pathname resolve context's path name (e.g., `to` or `from`)\n     *\n     * @returns an array of resolve tokens (keys)\n     */\n    Transition.prototype.getResolveTokens = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n    };\n    /**\n     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n     *\n     * #### Example:\n     * ```js\n     * transitionService.onBefore({}, transition => {\n     *   transition.addResolvable({\n     *     token: 'myResolve',\n     *     deps: ['MyService'],\n     *     resolveFn: myService => myService.getData()\n     *   });\n     * });\n     * ```\n     *\n     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n     */\n    Transition.prototype.addResolvable = function (resolvable, state) {\n        if (state === void 0) { state = \"\"; }\n        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n        var stateName = (typeof state === \"string\") ? state : state.name;\n        var topath = this._treeChanges.to;\n        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n        var resolveContext = new resolveContext_1.ResolveContext(topath);\n        resolveContext.addResolvables([resolvable], targetNode.state);\n    };\n    /**\n     * Gets the transition from which this transition was redirected.\n     *\n     * If the current transition is a redirect, this method returns the transition that was redirected.\n     *\n     * #### Example:\n     * ```js\n     * let transitionA = $state.go('A').transition\n     * transitionA.onStart({}, () => $state.target('B'));\n     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n     *   trans.to().name === 'B'; // true\n     *   trans.redirectedFrom() === transitionA; // true\n     * });\n     * ```\n     *\n     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n     */\n    Transition.prototype.redirectedFrom = function () {\n        return this._options.redirectedFrom || null;\n    };\n    /**\n     * Gets the original transition in a redirect chain\n     *\n     * A transition might belong to a long chain of multiple redirects.\n     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n     *\n     * #### Example:\n     * ```js\n     * // states\n     * registry.register({ name: 'A', redirectTo: 'B' });\n     * registry.register({ name: 'B', redirectTo: 'C' });\n     * registry.register({ name: 'C', redirectTo: 'D' });\n     * registry.register({ name: 'D' });\n     *\n     * let transitionA = $state.go('A').transition\n     *\n     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n     *   trans.to().name === 'D'; // true\n     *   trans.redirectedFrom().to().name === 'C'; // true\n     *   trans.originalTransition() === transitionA; // true\n     *   trans.originalTransition().to().name === 'A'; // true\n     * });\n     * ```\n     *\n     * @returns The original Transition that started a redirect chain\n     */\n    Transition.prototype.originalTransition = function () {\n        var rf = this.redirectedFrom();\n        return (rf && rf.originalTransition()) || this;\n    };\n    /**\n     * Get the transition options\n     *\n     * @returns the options for this Transition.\n     */\n    Transition.prototype.options = function () {\n        return this._options;\n    };\n    /**\n     * Gets the states being entered.\n     *\n     * @returns an array of states that will be entered during this transition.\n     */\n    Transition.prototype.entering = function () {\n        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Gets the states being exited.\n     *\n     * @returns an array of states that will be exited during this transition.\n     */\n    Transition.prototype.exiting = function () {\n        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n    };\n    /**\n     * Gets the states being retained.\n     *\n     * @returns an array of states that are already entered from a previous Transition, that will not be\n     *    exited during this Transition\n     */\n    Transition.prototype.retained = function () {\n        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Get the [[ViewConfig]]s associated with this Transition\n     *\n     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n     *\n     * @param pathname the name of the path to fetch views for:\n     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n     *\n     * @returns a list of ViewConfig objects for the given path.\n     */\n    Transition.prototype.views = function (pathname, state) {\n        if (pathname === void 0) { pathname = \"entering\"; }\n        var path = this._treeChanges[pathname];\n        path = !state ? path : path.filter(hof_1.propEq('state', state));\n        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n    };\n    Transition.prototype.treeChanges = function (pathname) {\n        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n    };\n    /**\n     * Creates a new transition that is a redirection of the current one.\n     *\n     * This transition can be returned from a [[TransitionService]] hook to\n     * redirect a transition to a new state and/or set of parameters.\n     *\n     * @internalapi\n     *\n     * @returns Returns a new [[Transition]] instance.\n     */\n    Transition.prototype.redirect = function (targetState) {\n        var redirects = 1, trans = this;\n        while ((trans = trans.redirectedFrom()) != null) {\n            if (++redirects > 20)\n                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n        }\n        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n        // If the original transition was caused by URL sync, then use { location: 'replace' }\n        // on the new transition (unless the target state explicitly specifies location: false).\n        // This causes the original url to be replaced with the url for the redirect target\n        // so the original url disappears from the browser history.\n        if (this.options().source === 'url' && targetState.options().location !== false) {\n            redirectOpts.location = 'replace';\n        }\n        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n        var originalEnteringNodes = this._treeChanges.entering;\n        var redirectEnteringNodes = newTransition._treeChanges.entering;\n        // --- Re-use resolve data from original transition ---\n        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n        // redirected transition.\n        //\n        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n        // You can wait for the resolve, then redirect to a child state based on the result.\n        // The redirected transition does not have to re-fetch the resolve.\n        // ---------------------------------------------------------\n        var nodeIsReloading = function (reloadState) { return function (node) {\n            return reloadState && node.state.includes[reloadState.name];\n        }; };\n        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n        var matchingEnteringNodes = pathFactory_1.PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, pathFactory_1.PathUtils.nonDynamicParams)\n            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n        matchingEnteringNodes.forEach(function (node, idx) {\n            node.resolvables = originalEnteringNodes[idx].resolvables;\n        });\n        return newTransition;\n    };\n    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n    Transition.prototype._changedParams = function () {\n        var tc = this._treeChanges;\n        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n        // If user explicitly wants a reload\n        if (this._options.reload)\n            return undefined;\n        // If any states are exiting or entering\n        if (tc.exiting.length || tc.entering.length)\n            return undefined;\n        // If to/from path lengths differ\n        if (tc.to.length !== tc.from.length)\n            return undefined;\n        // If the to/from paths are different\n        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n            .reduce(common_1.anyTrueR, false);\n        if (pathsDiffer)\n            return undefined;\n        // Find any parameter values that differ\n        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n        return tuples.map(function (_a) {\n            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n            return param_1.Param.changed(schema, toVals, fromVals);\n        }).reduce(common_1.unnestR, []);\n    };\n    /**\n     * Returns true if the transition is dynamic.\n     *\n     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n     *\n     * @returns true if the Transition is dynamic\n     */\n    Transition.prototype.dynamic = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n    };\n    /**\n     * Returns true if the transition is ignored.\n     *\n     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n     *\n     * @returns true if the Transition is ignored.\n     */\n    Transition.prototype.ignored = function () {\n        return !!this._ignoredReason();\n    };\n    /** @hidden */\n    Transition.prototype._ignoredReason = function () {\n        var pending = this.router.globals.transition;\n        var reloadState = this._options.reloadState;\n        var same = function (pathA, pathB) {\n            if (pathA.length !== pathB.length)\n                return false;\n            var matching = pathFactory_1.PathUtils.matching(pathA, pathB);\n            return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;\n        };\n        var newTC = this.treeChanges();\n        var pendTC = pending && pending.treeChanges();\n        if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))\n            return \"SameAsPending\";\n        if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))\n            return \"SameAsCurrent\";\n    };\n    /**\n     * Runs the transition\n     *\n     * This method is generally called from the [[StateService.transitionTo]]\n     *\n     * @internalapi\n     *\n     * @returns a promise for a successful transition.\n     */\n    Transition.prototype.run = function () {\n        var _this = this;\n        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n        // Gets transition hooks array for the given phase\n        var getHooksFor = function (phase) {\n            return _this._hookBuilder.buildHooksForPhase(phase);\n        };\n        // When the chain is complete, then resolve or reject the deferred\n        var transitionSuccess = function () {\n            trace_1.trace.traceSuccess(_this.$to(), _this);\n            _this.success = true;\n            _this._deferred.resolve(_this.to());\n            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.SUCCESS));\n        };\n        var transitionError = function (reason) {\n            trace_1.trace.traceError(reason, _this);\n            _this.success = false;\n            _this._deferred.reject(reason);\n            _this._error = reason;\n            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.ERROR));\n        };\n        var runTransition = function () {\n            // Wait to build the RUN hook chain until the BEFORE hooks are done\n            // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n            var allRunHooks = getHooksFor(interface_1.TransitionHookPhase.RUN);\n            var done = function () { return coreservices_1.services.$q.when(undefined); };\n            return transitionHook_1.TransitionHook.invokeHooks(allRunHooks, done);\n        };\n        var startTransition = function () {\n            var globals = _this.router.globals;\n            globals.lastStartedTransitionId = _this.$id;\n            globals.transition = _this;\n            globals.transitionHistory.enqueue(_this);\n            trace_1.trace.traceTransitionStart(_this);\n            return coreservices_1.services.$q.when(undefined);\n        };\n        var allBeforeHooks = getHooksFor(interface_1.TransitionHookPhase.BEFORE);\n        transitionHook_1.TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n            .then(runTransition)\n            .then(transitionSuccess, transitionError);\n        return this.promise;\n    };\n    /**\n     * Checks if the Transition is valid\n     *\n     * @returns true if the Transition is valid\n     */\n    Transition.prototype.valid = function () {\n        return !this.error() || this.success !== undefined;\n    };\n    /**\n     * Aborts this transition\n     *\n     * Imperative API to abort a Transition.\n     * This only applies to Transitions that are not yet complete.\n     */\n    Transition.prototype.abort = function () {\n        // Do not set flag if the transition is already complete\n        if (predicates_1.isUndefined(this.success)) {\n            this._aborted = true;\n        }\n    };\n    /**\n     * The Transition error reason.\n     *\n     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n     *\n     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n     */\n    Transition.prototype.error = function () {\n        var state = this.$to();\n        if (state.self.abstract)\n            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n        if (!param_1.Param.validates(state.parameters(), this.params()))\n            return \"Param values not valid for state '\" + state.name + \"'\";\n        if (this.success === false)\n            return this._error;\n    };\n    /**\n     * A string representation of the Transition\n     *\n     * @returns A string representation of the Transition\n     */\n    Transition.prototype.toString = function () {\n        var fromStateOrName = this.from();\n        var toStateOrName = this.to();\n        var avoidEmptyHash = function (params) {\n            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, [\"#\"]);\n        };\n        // (X) means the to state is invalid.\n        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n    };\n    return Transition;\n}());\n/** @hidden */\nTransition.diToken = Transition;\nexports.Transition = Transition;\n//# sourceMappingURL=transition.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/transition/transition.js\n// module id = 19\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar param_1 = require(\"../params/param\");\nvar strings_1 = require(\"../common/strings\");\n/** @hidden */\nfunction quoteRegExp(string, param) {\n    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!param)\n        return result;\n    switch (param.squash) {\n        case false:\n            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n            break;\n        case true:\n            result = result.replace(/\\/$/, '');\n            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n            break;\n        default:\n            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n            break;\n    }\n    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n/** @hidden */\nvar memoizeTo = function (obj, prop, fn) {\n    return obj[prop] = obj[prop] || fn();\n};\n/** @hidden */\nvar splitOnSlash = strings_1.splitOnDelim('/');\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nvar UrlMatcher = (function () {\n    /**\n     * @param pattern The pattern to compile into a matcher.\n     * @param paramTypes The [[ParamTypes]] registry\n     * @param config  A configuration object\n     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n     */\n    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n        var _this = this;\n        this.config = config;\n        /** @hidden */\n        this._cache = { path: [this] };\n        /** @hidden */\n        this._children = [];\n        /** @hidden */\n        this._params = [];\n        /** @hidden */\n        this._segments = [];\n        /** @hidden */\n        this._compiled = [];\n        this.pattern = pattern;\n        this.config = common_1.defaults(this.config, {\n            params: {},\n            strict: true,\n            caseInsensitive: false,\n            paramMap: common_1.identity\n        });\n        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n        //   '*' name\n        //   ':' name\n        //   '{' name '}'\n        //   '{' name ':' regexp '}'\n        // The regular expression is somewhat complicated due to the need to allow curly braces\n        // inside the regular expression. The placeholder regexp breaks down as follows:\n        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n        //    \\\\.                            - a backslash escape\n        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n        var checkParamErrors = function (id) {\n            if (!UrlMatcher.nameValidator.test(id))\n                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n        };\n        // Split into static segments separated by path parameter placeholders.\n        // The number of segments is always 1 more than the number of parameters.\n        var matchDetails = function (m, isSearch) {\n            // IE[78] returns '' for unmatched groups instead of null\n            var id = m[2] || m[3];\n            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n            }); };\n            return {\n                id: id,\n                regexp: regexp,\n                cfg: _this.config.params[id],\n                segment: pattern.substring(last, m.index),\n                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n            };\n        };\n        var p, segment;\n        while ((m = placeholder.exec(pattern))) {\n            p = matchDetails(m, false);\n            if (p.segment.indexOf('?') >= 0)\n                break; // we're into the search part\n            checkParamErrors(p.id);\n            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n            this._segments.push(p.segment);\n            patterns.push([p.segment, common_1.tail(this._params)]);\n            last = placeholder.lastIndex;\n        }\n        segment = pattern.substring(last);\n        // Find any search parameter names and remove them from the last segment\n        var i = segment.indexOf('?');\n        if (i >= 0) {\n            var search = segment.substring(i);\n            segment = segment.substring(0, i);\n            if (search.length > 0) {\n                last = 0;\n                while ((m = searchPlaceholder.exec(search))) {\n                    p = matchDetails(m, true);\n                    checkParamErrors(p.id);\n                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n                    last = placeholder.lastIndex;\n                    // check if ?&\n                }\n            }\n        }\n        this._segments.push(segment);\n        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n    }\n    /**\n     * Creates a new concatenated UrlMatcher\n     *\n     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n     *\n     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n     */\n    UrlMatcher.prototype.append = function (url) {\n        this._children.push(url);\n        url._cache = {\n            path: this._cache.path.concat(url),\n            parent: this,\n            pattern: null,\n        };\n        return url;\n    };\n    /** @hidden */\n    UrlMatcher.prototype.isRoot = function () {\n        return this._cache.path[0] === this;\n    };\n    /** Returns the input pattern string */\n    UrlMatcher.prototype.toString = function () {\n        return this.pattern;\n    };\n    /**\n     * Tests the specified url/path against this matcher.\n     *\n     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n     * parameter values.  Returns null if the path does not match.\n     *\n     * The returned object contains the values\n     * of any search parameters that are mentioned in the pattern, but their value may be null if\n     * they are not present in `search`. This means that search parameters are always treated\n     * as optional.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n     *   x: '1', q: 'hello'\n     * });\n     * // returns { id: 'bob', q: 'hello', r: null }\n     * ```\n     *\n     * @param path    The URL path to match, e.g. `$location.path()`.\n     * @param search  URL search parameters, e.g. `$location.search()`.\n     * @param hash    URL hash e.g. `$location.hash()`.\n     * @param options\n     *\n     * @returns The captured parameter values.\n     */\n    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n        var _this = this;\n        if (search === void 0) { search = {}; }\n        if (options === void 0) { options = {}; }\n        var match = memoizeTo(this._cache, 'pattern', function () {\n            return new RegExp([\n                '^',\n                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n                _this.config.strict === false ? '\\/?' : '',\n                '$'\n            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n        }).exec(path);\n        if (!match)\n            return null;\n        //options = defaults(options, { isolate: false });\n        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n        if (nPathSegments !== match.length - 1)\n            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n        function decodePathArray(string) {\n            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n            var split = reverseString(string).split(/-(?!\\\\)/);\n            var allReversed = common_1.map(split, reverseString);\n            return common_1.map(allReversed, unquoteDashes).reverse();\n        }\n        for (var i = 0; i < nPathSegments; i++) {\n            var param = pathParams[i];\n            var value = match[i + 1];\n            // if the param value matches a pre-replace pair, replace the value before decoding.\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (value && param.array === true)\n                value = decodePathArray(value);\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        }\n        searchParams.forEach(function (param) {\n            var value = search[param.id];\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        });\n        if (hash)\n            values[\"#\"] = hash;\n        return values;\n    };\n    /**\n     * @hidden\n     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n     *\n     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n     *    pattern has no parameters, an empty array is returned.\n     */\n    UrlMatcher.prototype.parameters = function (opts) {\n        if (opts === void 0) { opts = {}; }\n        if (opts.inherit === false)\n            return this._params;\n        return common_1.unnest(this._cache.path.map(function (matcher) { return matcher._params; }));\n    };\n    /**\n     * @hidden\n     * Returns a single parameter from this UrlMatcher by id\n     *\n     * @param id\n     * @param opts\n     * @returns {T|Param|any|boolean|UrlMatcher|null}\n     */\n    UrlMatcher.prototype.parameter = function (id, opts) {\n        var _this = this;\n        if (opts === void 0) { opts = {}; }\n        var findParam = function () {\n            for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {\n                var param = _a[_i];\n                if (param.id === id)\n                    return param;\n            }\n        };\n        var parent = this._cache.parent;\n        return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;\n    };\n    /**\n     * Validates the input parameter values against this UrlMatcher\n     *\n     * Checks an object hash of parameters to validate their correctness according to the parameter\n     * types of this `UrlMatcher`.\n     *\n     * @param params The object hash of parameters to validate.\n     * @returns Returns `true` if `params` validates, otherwise `false`.\n     */\n    UrlMatcher.prototype.validates = function (params) {\n        var validParamVal = function (param, val) {\n            return !param || param.validates(val);\n        };\n        params = params || {};\n        // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher\n        var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });\n        return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(common_1.allTrueR, true);\n    };\n    /**\n     * Given a set of parameter values, creates a URL from this UrlMatcher.\n     *\n     * Creates a URL that matches this pattern by substituting the specified values\n     * for the path and search parameters.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n     * // returns '/user/bob?q=yes'\n     * ```\n     *\n     * @param values  the values to substitute for the parameters in this pattern.\n     * @returns the formatted URL (path and optionally search part).\n     */\n    UrlMatcher.prototype.format = function (values) {\n        if (values === void 0) { values = {}; }\n        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n        var urlMatchers = this._cache.path;\n        // Extract all the static segments and Params (processed as ParamDetails)\n        // into an ordered array\n        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams)\n            .reduce(common_1.unnestR, [])\n            .map(function (x) { return predicates_1.isString(x) ? x : getDetails(x); });\n        // Extract the query params into a separate array\n        var queryParams = urlMatchers.map(UrlMatcher.queryParams)\n            .reduce(common_1.unnestR, [])\n            .map(getDetails);\n        var isInvalid = function (param) { return param.isValid === false; };\n        if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {\n            return null;\n        }\n        /**\n         * Given a Param, applies the parameter value, then returns detailed information about it\n         */\n        function getDetails(param) {\n            // Normalize to typed value\n            var value = param.value(values[param.id]);\n            var isValid = param.validates(value);\n            var isDefaultValue = param.isDefaultValue(value);\n            // Check if we're in squash mode for the parameter\n            var squash = isDefaultValue ? param.squash : false;\n            // Allow the Parameter's Type to encode the value\n            var encoded = param.type.encode(value);\n            return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n        }\n        // Build up the path-portion from the list of static segments and parameters\n        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n            // The element is a static segment (a raw string); just append it\n            if (predicates_1.isString(x))\n                return acc + x;\n            // Otherwise, it's a ParamDetails.\n            var squash = x.squash, encoded = x.encoded, param = x.param;\n            // If squash is === true, try to remove a slash from the path\n            if (squash === true)\n                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n            // If squash is a string, use the string for the param value\n            if (predicates_1.isString(squash))\n                return acc + squash;\n            if (squash !== false)\n                return acc; // ?\n            if (encoded == null)\n                return acc;\n            // If this parameter value is an array, encode the value using encodeDashes\n            if (predicates_1.isArray(encoded))\n                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n            // If the parameter type is \"raw\", then do not encodeURIComponent\n            if (param.raw)\n                return acc + encoded;\n            // Encode the value\n            return acc + encodeURIComponent(encoded);\n        }, \"\");\n        // Build the query string by applying parameter values (array or regular)\n        // then mapping to key=value, then flattening and joining using \"&\"\n        var queryString = queryParams.map(function (paramDetails) {\n            var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;\n            if (encoded == null || (isDefaultValue && squash !== false))\n                return;\n            if (!predicates_1.isArray(encoded))\n                encoded = [encoded];\n            if (encoded.length === 0)\n                return;\n            if (!param.raw)\n                encoded = common_1.map(encoded, encodeURIComponent);\n            return encoded.map(function (val) { return param.id + \"=\" + val; });\n        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n    };\n    /** @hidden */\n    UrlMatcher.encodeDashes = function (str) {\n        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n        var staticSegments = matcher._segments;\n        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n            .reduce(common_1.unnestR, [])\n            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's query params */\n    UrlMatcher.queryParams = function (matcher) {\n        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n    };\n    /**\n     * Compare two UrlMatchers\n     *\n     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n     * Each static path segment is a static string between a path separator (slash character).\n     * Each dynamic segment is a path parameter.\n     *\n     * The comparison function sorts static segments before dynamic ones.\n     */\n    UrlMatcher.compare = function (a, b) {\n        /**\n         * Turn a UrlMatcher and all its parent matchers into an array\n         * of slash literals '/', string literals, and Param objects\n         *\n         * This example matcher matches strings like \"/foo/:param/tail\":\n         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n         *\n         * Caches the result as `matcher._cache.segments`\n         */\n        var segments = function (matcher) {\n            return matcher._cache.segments = matcher._cache.segments ||\n                matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n                    .reduce(common_1.unnestR, [])\n                    .reduce(strings_1.joinNeighborsR, [])\n                    .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n                    .reduce(common_1.unnestR, []);\n        };\n        /**\n         * Gets the sort weight for each segment of a UrlMatcher\n         *\n         * Caches the result as `matcher._cache.weights`\n         */\n        var weights = function (matcher) {\n            return matcher._cache.weights = matcher._cache.weights ||\n                segments(matcher).map(function (segment) {\n                    // Sort slashes first, then static strings, the Params\n                    if (segment === '/')\n                        return 1;\n                    if (predicates_1.isString(segment))\n                        return 2;\n                    if (segment instanceof param_1.Param)\n                        return 3;\n                });\n        };\n        var cmp, i, pairs = common_1.arrayTuples(weights(a), weights(b));\n        for (i = 0; i < pairs.length; i++) {\n            cmp = pairs[i][0] - pairs[i][1];\n            if (cmp !== 0)\n                return cmp;\n        }\n        return 0;\n    };\n    return UrlMatcher;\n}());\n/** @hidden */\nUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\nexports.UrlMatcher = UrlMatcher;\n//# sourceMappingURL=urlMatcher.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/url/urlMatcher.js\n// module id = 20\n// module chunks = 0","\"use strict\";\n/**\n * @internalapi\n * @module vanilla\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"./utils\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\n/** A base `LocationServices` */\nvar BaseLocationServices = (function () {\n    function BaseLocationServices(router, fireAfterUpdate) {\n        var _this = this;\n        this.fireAfterUpdate = fireAfterUpdate;\n        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n        this._listeners = [];\n        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n        this._location = window && window.location;\n        this._history = window && window.history;\n    }\n    BaseLocationServices.prototype.url = function (url, replace) {\n        if (replace === void 0) { replace = true; }\n        if (predicates_1.isDefined(url) && url !== this._get()) {\n            this._set(null, null, url, replace);\n            if (this.fireAfterUpdate) {\n                var evt_1 = common_1.extend(new Event(\"locationchange\"), { url: url });\n                this._listeners.forEach(function (cb) { return cb(evt_1); });\n            }\n        }\n        return utils_1.buildUrl(this);\n    };\n    BaseLocationServices.prototype.onChange = function (cb) {\n        var _this = this;\n        this._listeners.push(cb);\n        return function () { return common_1.removeFrom(_this._listeners, cb); };\n    };\n    BaseLocationServices.prototype.dispose = function (router) {\n        common_1.deregAll(this._listeners);\n    };\n    return BaseLocationServices;\n}());\nexports.BaseLocationServices = BaseLocationServices;\n//# sourceMappingURL=baseLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla/baseLocationService.js\n// module id = 21\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"angular\",\"commonjs2\":\"angular\",\"commonjs\":\"angular\",\"amd\":\"angular\"}\n// module id = 22\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Angular 1 types\n *\n * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.\n * The customizations to the core types for Angular UI-Router are documented here.\n *\n * The optional [[$resolve]] service is also documented here.\n *\n * @module ng1\n * @preferred\n */\n/** for typedoc */\nvar angular_1 = require(\"./angular\");\nvar core_1 = require(\"@uirouter/core\");\nvar views_1 = require(\"./statebuilders/views\");\nvar templateFactory_1 = require(\"./templateFactory\");\nvar stateProvider_1 = require(\"./stateProvider\");\nvar onEnterExitRetain_1 = require(\"./statebuilders/onEnterExitRetain\");\nvar locationServices_1 = require(\"./locationServices\");\nvar urlRouterProvider_1 = require(\"./urlRouterProvider\");\nangular_1.ng.module(\"ui.router.angular1\", []);\nvar mod_init = angular_1.ng.module('ui.router.init', []);\nvar mod_util = angular_1.ng.module('ui.router.util', ['ng', 'ui.router.init']);\nvar mod_rtr = angular_1.ng.module('ui.router.router', ['ui.router.util']);\nvar mod_state = angular_1.ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);\nvar mod_main = angular_1.ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);\nvar mod_cmpt = angular_1.ng.module('ui.router.compat', ['ui.router']); // tslint:disable-line\nvar router = null;\n$uiRouter.$inject = ['$locationProvider'];\n/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */\nfunction $uiRouter($locationProvider) {\n    // Create a new instance of the Router when the $uiRouterProvider is initialized\n    router = this.router = new core_1.UIRouter();\n    router.stateProvider = new stateProvider_1.StateProvider(router.stateRegistry, router.stateService);\n    // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties\n    router.stateRegistry.decorator(\"views\", views_1.ng1ViewsBuilder);\n    router.stateRegistry.decorator(\"onExit\", onEnterExitRetain_1.getStateHookBuilder(\"onExit\"));\n    router.stateRegistry.decorator(\"onRetain\", onEnterExitRetain_1.getStateHookBuilder(\"onRetain\"));\n    router.stateRegistry.decorator(\"onEnter\", onEnterExitRetain_1.getStateHookBuilder(\"onEnter\"));\n    router.viewService._pluginapi._viewConfigFactory('ng1', views_1.getNg1ViewConfigFactory());\n    var ng1LocationService = router.locationService = router.locationConfig = new locationServices_1.Ng1LocationServices($locationProvider);\n    locationServices_1.Ng1LocationServices.monkeyPatchPathParameterType(router);\n    // backwards compat: also expose router instance as $uiRouterProvider.router\n    router['router'] = router;\n    router['$get'] = $get;\n    $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];\n    function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {\n        ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);\n        delete router['router'];\n        delete router['$get'];\n        return router;\n    }\n    return router;\n}\nvar getProviderFor = function (serviceName) { return ['$uiRouterProvider', function ($urp) {\n        var service = $urp.router[serviceName];\n        service[\"$get\"] = function () { return service; };\n        return service;\n    }]; };\n// This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)\nrunBlock.$inject = ['$injector', '$q', '$uiRouter'];\nfunction runBlock($injector, $q, $uiRouter) {\n    core_1.services.$injector = $injector;\n    core_1.services.$q = $q;\n    // The $injector is now available.\n    // Find any resolvables that had dependency annotation deferred\n    $uiRouter.stateRegistry.get()\n        .map(function (x) { return x.$$state().resolvables; })\n        .reduce(core_1.unnestR, [])\n        .filter(function (x) { return x.deps === \"deferred\"; })\n        .forEach(function (resolvable) { return resolvable.deps = $injector.annotate(resolvable.resolveFn); });\n}\n// $urlRouter service and $urlRouterProvider\nvar getUrlRouterProvider = function (uiRouter) {\n    return uiRouter.urlRouterProvider = new urlRouterProvider_1.UrlRouterProvider(uiRouter);\n};\n// $state service and $stateProvider\n// $urlRouter service and $urlRouterProvider\nvar getStateProvider = function () {\n    return core_1.extend(router.stateProvider, { $get: function () { return router.stateService; } });\n};\nwatchDigests.$inject = ['$rootScope'];\nfunction watchDigests($rootScope) {\n    $rootScope.$watch(function () { core_1.trace.approximateDigests++; });\n}\nexports.watchDigests = watchDigests;\nmod_init.provider(\"$uiRouter\", $uiRouter);\nmod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);\nmod_util.provider('$urlService', getProviderFor('urlService'));\nmod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);\nmod_util.provider('$templateFactory', function () { return new templateFactory_1.TemplateFactory(); });\nmod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));\nmod_state.provider('$uiRouterGlobals', getProviderFor('globals'));\nmod_state.provider('$transitions', getProviderFor('transitionService'));\nmod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);\nmod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);\nmod_main.factory('$view', function () { return router.viewService; });\nmod_main.service(\"$trace\", function () { return core_1.trace; });\nmod_main.run(watchDigests);\nmod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);\nmod_state.run(['$state', function ($state) { }]);\nmod_rtr.run(['$urlRouter', function ($urlRouter) { }]);\nmod_init.run(runBlock);\n/** @hidden TODO: find a place to move this */\nexports.getLocals = function (ctx) {\n    var tokens = ctx.getTokens().filter(core_1.isString);\n    var tuples = tokens.map(function (key) {\n        var resolvable = ctx.getResolvable(key);\n        var waitPolicy = ctx.getPolicy(resolvable).async;\n        return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];\n    });\n    return tuples.reduce(core_1.applyPairs, {});\n};\n//# sourceMappingURL=services.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/services.js\n// module id = 23\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@uirouter/core\");\nfunction getNg1ViewConfigFactory() {\n    var templateFactory = null;\n    return function (path, view) {\n        templateFactory = templateFactory || core_1.services.$injector.get(\"$templateFactory\");\n        return [new Ng1ViewConfig(path, view, templateFactory)];\n    };\n}\nexports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;\nvar hasAnyKey = function (keys, obj) {\n    return keys.reduce(function (acc, key) { return acc || core_1.isDefined(obj[key]); }, false);\n};\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `views`.\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * handles the `views` property with logic specific to @uirouter/angularjs (ng1).\n *\n * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n * and applies the state-level configuration to a view named `$default`.\n */\nfunction ng1ViewsBuilder(state) {\n    // Do not process root state\n    if (!state.parent)\n        return {};\n    var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);\n    // Do not allow a state to have both state-level props and also a `views: {}` property.\n    // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.\n    // However, the `$default` approach should not be mixed with a separate `views: ` block.\n    if (core_1.isDefined(state.views) && hasAnyKey(allViewKeys, state)) {\n        throw new Error(\"State '\" + state.name + \"' has a 'views' object. \" +\n            \"It cannot also have \\\"view properties\\\" at the state level.  \" +\n            \"Move the following properties into a view (in the 'views' object): \" +\n            (\" \" + allViewKeys.filter(function (key) { return core_1.isDefined(state[key]); }).join(\", \")));\n    }\n    var views = {}, viewsObject = state.views || { \"$default\": core_1.pick(state, allViewKeys) };\n    core_1.forEach(viewsObject, function (config, name) {\n        // Account for views: { \"\": { template... } }\n        name = name || \"$default\";\n        // Account for views: { header: \"headerComponent\" }\n        if (core_1.isString(config))\n            config = { component: config };\n        // Make a shallow copy of the config object\n        config = core_1.extend({}, config);\n        // Do not allow a view to mix props for component-style view with props for template/controller-style view\n        if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {\n            throw new Error(\"Cannot combine: \" + compKeys.join(\"|\") + \" with: \" + nonCompKeys.join(\"|\") + \" in stateview: '\" + name + \"@\" + state.name + \"'\");\n        }\n        config.resolveAs = config.resolveAs || '$resolve';\n        config.$type = \"ng1\";\n        config.$context = state;\n        config.$name = name;\n        var normalized = core_1.ViewService.normalizeUIViewTarget(config.$context, config.$name);\n        config.$uiViewName = normalized.uiViewName;\n        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n        views[name] = config;\n    });\n    return views;\n}\nexports.ng1ViewsBuilder = ng1ViewsBuilder;\nvar id = 0;\nvar Ng1ViewConfig = (function () {\n    function Ng1ViewConfig(path, viewDecl, factory) {\n        var _this = this;\n        this.path = path;\n        this.viewDecl = viewDecl;\n        this.factory = factory;\n        this.$id = id++;\n        this.loaded = false;\n        this.getTemplate = function (uiView, context) {\n            return _this.component ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings) : _this.template;\n        };\n    }\n    Ng1ViewConfig.prototype.load = function () {\n        var _this = this;\n        var $q = core_1.services.$q;\n        var context = new core_1.ResolveContext(this.path);\n        var params = this.path.reduce(function (acc, node) { return core_1.extend(acc, node.paramValues); }, {});\n        var promises = {\n            template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),\n            controller: $q.when(this.getController(context))\n        };\n        return $q.all(promises).then(function (results) {\n            core_1.trace.traceViewServiceEvent(\"Loaded\", _this);\n            _this.controller = results.controller;\n            core_1.extend(_this, results.template); // Either { template: \"tpl\" } or { component: \"cmpName\" }\n            return _this;\n        });\n    };\n    /**\n     * Gets the controller for a view configuration.\n     *\n     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.\n     */\n    Ng1ViewConfig.prototype.getController = function (context) {\n        var provider = this.viewDecl.controllerProvider;\n        if (!core_1.isInjectable(provider))\n            return this.viewDecl.controller;\n        var deps = core_1.services.$injector.annotate(provider);\n        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;\n        var resolvable = new core_1.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    return Ng1ViewConfig;\n}());\nexports.Ng1ViewConfig = Ng1ViewConfig;\n//# sourceMappingURL=views.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/statebuilders/views.js\n// module id = 24\n// module chunks = 0","\"use strict\";\n/**\n * @module common\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Queue = (function () {\n    function Queue(_items, _limit) {\n        if (_items === void 0) { _items = []; }\n        if (_limit === void 0) { _limit = null; }\n        this._items = _items;\n        this._limit = _limit;\n    }\n    Queue.prototype.enqueue = function (item) {\n        var items = this._items;\n        items.push(item);\n        if (this._limit && items.length > this._limit)\n            items.shift();\n        return item;\n    };\n    Queue.prototype.dequeue = function () {\n        if (this.size())\n            return this._items.splice(0, 1)[0];\n    };\n    Queue.prototype.clear = function () {\n        var current = this._items;\n        this._items = [];\n        return current;\n    };\n    Queue.prototype.size = function () {\n        return this._items.length;\n    };\n    Queue.prototype.remove = function (item) {\n        var idx = this._items.indexOf(item);\n        return idx > -1 && this._items.splice(idx, 1)[0];\n    };\n    Queue.prototype.peekTail = function () {\n        return this._items[this._items.length - 1];\n    };\n    Queue.prototype.peekHead = function () {\n        if (this.size())\n            return this._items[0];\n    };\n    return Queue;\n}());\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/common/queue.js\n// module id = 25\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\nvar ParamType = (function () {\n    /**\n     * @param def  A configuration object which contains the custom type definition.  The object's\n     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n     * @returns a new ParamType object\n     */\n    function ParamType(def) {\n        /** @inheritdoc */\n        this.pattern = /.*/;\n        /** @inheritdoc */\n        this.inherit = true;\n        common_1.extend(this, def);\n    }\n    // consider these four methods to be \"abstract methods\" that should be overridden\n    /** @inheritdoc */\n    ParamType.prototype.is = function (val, key) { return true; };\n    /** @inheritdoc */\n    ParamType.prototype.encode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.decode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.equals = function (a, b) { return a == b; };\n    ParamType.prototype.$subPattern = function () {\n        var sub = this.pattern.toString();\n        return sub.substr(1, sub.length - 2);\n    };\n    ParamType.prototype.toString = function () {\n        return \"{ParamType:\" + this.name + \"}\";\n    };\n    /** Given an encoded string, or a decoded object, returns a decoded object */\n    ParamType.prototype.$normalize = function (val) {\n        return this.is(val) ? val : this.decode(val);\n    };\n    /**\n     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n     * e.g.:\n     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n     * - url: \"/path?queryParam=1&queryParam=2\n     * - $stateParams.queryParam will be [1, 2]\n     * if `mode` is \"auto\", then\n     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n     */\n    ParamType.prototype.$asArray = function (mode, isSearch) {\n        if (!mode)\n            return this;\n        if (mode === \"auto\" && !isSearch)\n            throw new Error(\"'auto' array mode is for query parameters only\");\n        return new ArrayType(this, mode);\n    };\n    return ParamType;\n}());\nexports.ParamType = ParamType;\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\nfunction ArrayType(type, mode) {\n    var _this = this;\n    // Wrap non-array value as array\n    function arrayWrap(val) {\n        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n    }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n        switch (val.length) {\n            case 0: return undefined;\n            case 1: return mode === \"auto\" ? val[0] : val;\n            default: return val;\n        }\n    }\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n        return function handleArray(val) {\n            if (predicates_1.isArray(val) && val.length === 0)\n                return val;\n            var arr = arrayWrap(val);\n            var result = common_1.map(arr, callback);\n            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n        };\n    }\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n        return function handleArray(val1, val2) {\n            var left = arrayWrap(val1), right = arrayWrap(val2);\n            if (left.length !== right.length)\n                return false;\n            for (var i = 0; i < left.length; i++) {\n                if (!callback(left[i], right[i]))\n                    return false;\n            }\n            return true;\n        };\n    }\n    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n        var paramTypeFn = type[name].bind(type);\n        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n        _this[name] = wrapperFn(paramTypeFn);\n    });\n    common_1.extend(this, {\n        dynamic: type.dynamic,\n        name: type.name,\n        pattern: type.pattern,\n        inherit: type.inherit,\n        is: arrayHandler(type.is.bind(type), true),\n        $arrayMode: mode\n    });\n}\n//# sourceMappingURL=paramType.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/params/paramType.js\n// module id = 26\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module path */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar param_1 = require(\"../params/param\");\n/**\n * @internalapi\n *\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nvar PathNode = (function () {\n    function PathNode(stateOrNode) {\n        if (stateOrNode instanceof PathNode) {\n            var node = stateOrNode;\n            this.state = node.state;\n            this.paramSchema = node.paramSchema.slice();\n            this.paramValues = common_1.extend({}, node.paramValues);\n            this.resolvables = node.resolvables.slice();\n            this.views = node.views && node.views.slice();\n        }\n        else {\n            var state = stateOrNode;\n            this.state = state;\n            this.paramSchema = state.parameters({ inherit: false });\n            this.paramValues = {};\n            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n        }\n    }\n    /** Sets [[paramValues]] for the node, from the values of an object hash */\n    PathNode.prototype.applyRawParams = function (params) {\n        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n        return this;\n    };\n    /** Gets a specific [[Param]] metadata that belongs to the node */\n    PathNode.prototype.parameter = function (name) {\n        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n    };\n    /**\n     * @returns true if the state and parameter values for another PathNode are\n     * equal to the state and param values for this PathNode\n     */\n    PathNode.prototype.equals = function (node, paramsFn) {\n        var diff = this.diff(node, paramsFn);\n        return diff && diff.length === 0;\n    };\n    /**\n     * Finds Params with different parameter values on another PathNode.\n     *\n     * Given another node (of the same state), finds the parameter values which differ.\n     * Returns the [[Param]] (schema objects) whose parameter values differ.\n     *\n     * Given another node for a different state, returns `false`\n     *\n     * @param node The node to compare to\n     * @param paramsFn A function that returns which parameters should be compared.\n     * @returns The [[Param]]s which differ, or null if the two nodes are for different states\n     */\n    PathNode.prototype.diff = function (node, paramsFn) {\n        if (this.state !== node.state)\n            return false;\n        var params = paramsFn ? paramsFn(this) : this.paramSchema;\n        return param_1.Param.changed(params, this.paramValues, node.paramValues);\n    };\n    /** Returns a clone of the PathNode */\n    PathNode.clone = function (node) {\n        return new PathNode(node);\n    };\n    return PathNode;\n}());\nexports.PathNode = PathNode;\n//# sourceMappingURL=pathNode.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/path/pathNode.js\n// module id = 27\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar glob_1 = require(\"../common/glob\");\nvar predicates_1 = require(\"../common/predicates\");\n/**\n * Internal representation of a UI-Router state.\n *\n * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n *\n * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.\n *\n * This class prototypally inherits from the corresponding [[StateDeclaration]].\n * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n */\nvar StateObject = (function () {\n    /** @deprecated use State.create() */\n    function StateObject(config) {\n        return StateObject.create(config || {});\n    }\n    /**\n     * Create a state object to put the private/internal implementation details onto.\n     * The object's prototype chain looks like:\n     * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)\n     *\n     * @param stateDecl the user-supplied State Declaration\n     * @returns {StateObject} an internal State object\n     */\n    StateObject.create = function (stateDecl) {\n        stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;\n        var state = common_1.inherit(common_1.inherit(stateDecl, StateObject.prototype));\n        stateDecl.$$state = function () { return state; };\n        state.self = stateDecl;\n        state.__stateObjectCache = {\n            nameGlob: glob_1.Glob.fromString(state.name) // might return null\n        };\n        return state;\n    };\n    /**\n     * Returns true if the provided parameter is the same state.\n     *\n     * Compares the identity of the state against the passed value, which is either an object\n     * reference to the actual `State` instance, the original definition object passed to\n     * `$stateProvider.state()`, or the fully-qualified name.\n     *\n     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n     * @returns Returns `true` if `ref` matches the current `State` instance.\n     */\n    StateObject.prototype.is = function (ref) {\n        return this === ref || this.self === ref || this.fqn() === ref;\n    };\n    /**\n     * @deprecated this does not properly handle dot notation\n     * @returns Returns a dot-separated name of the state.\n     */\n    StateObject.prototype.fqn = function () {\n        if (!this.parent || !(this.parent instanceof this.constructor))\n            return this.name;\n        var name = this.parent.fqn();\n        return name ? name + \".\" + this.name : this.name;\n    };\n    /**\n     * Returns the root node of this state's tree.\n     *\n     * @returns The root of this state's tree.\n     */\n    StateObject.prototype.root = function () {\n        return this.parent && this.parent.root() || this;\n    };\n    /**\n     * Gets the state's `Param` objects\n     *\n     * Gets the list of [[Param]] objects owned by the state.\n     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.\n     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n     *\n     * @param opts options\n     */\n    StateObject.prototype.parameters = function (opts) {\n        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n        return inherited.concat(common_1.values(this.params))\n            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n    };\n    /**\n     * Returns a single [[Param]] that is owned by the state\n     *\n     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.\n     * @param id the name of the [[Param]] to return\n     * @param opts options\n     */\n    StateObject.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        return (this.url && this.url.parameter(id, opts) ||\n            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n            opts.inherit && this.parent && this.parent.parameter(id));\n    };\n    StateObject.prototype.toString = function () {\n        return this.fqn();\n    };\n    return StateObject;\n}());\n/** Predicate which returns true if the object is an class with @State() decorator */\nStateObject.isStateClass = function (stateDecl) {\n    return predicates_1.isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;\n};\n/** Predicate which returns true if the object is an internal [[StateObject]] object */\nStateObject.isState = function (obj) {\n    return predicates_1.isObject(obj['__stateObjectCache']);\n};\nexports.StateObject = StateObject;\n//# sourceMappingURL=stateObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/state/stateObject.js\n// module id = 28\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar interface_1 = require(\"./interface\"); // has or is using\nvar glob_1 = require(\"../common/glob\");\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @returns {boolean}\n */\nfunction matchState(state, criterion) {\n    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n    function matchGlobs(_state) {\n        var globStrings = toMatch;\n        for (var i = 0; i < globStrings.length; i++) {\n            var glob = new glob_1.Glob(globStrings[i]);\n            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n    return !!matchFn(state);\n}\nexports.matchState = matchState;\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nvar RegisteredHook = (function () {\n    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {\n        if (options === void 0) { options = {}; }\n        this.tranSvc = tranSvc;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.matchCriteria = matchCriteria;\n        this.priority = options.priority || 0;\n        this.bind = options.bind || null;\n        this._deregistered = false;\n    }\n    /**\n     * Gets the matching [[PathNode]]s\n     *\n     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n     *\n     * Returning `null` is significant to distinguish between the default\n     * \"match-all criterion value\" of `true` compared to a `() => true` function,\n     * when the nodes is an empty array.\n     *\n     * This is useful to allow a transition match criteria of `entering: true`\n     * to still match a transition, even when `entering === []`.  Contrast that\n     * with `entering: (state) => true` which only matches when a state is actually\n     * being entered.\n     */\n    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n        if (criterion === true)\n            return nodes;\n        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n        return matching.length ? matching : null;\n    };\n    /**\n     * Gets the default match criteria (all `true`)\n     *\n     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n     *\n     * ```js\n     * {\n     *   to: true,\n     *   from: true,\n     *   entering: true,\n     *   exiting: true,\n     *   retained: true,\n     * }\n     */\n    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n    };\n    /**\n     * Gets matching nodes as [[IMatchingNodes]]\n     *\n     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n     *\n     * ```js\n     * let matches: IMatchingNodes = {\n     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n     * };\n     * ```\n     */\n    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n        var _this = this;\n        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n        return paths.reduce(function (mn, pathtype) {\n            // STATE scope criteria matches against every node in the path.\n            // TRANSITION scope criteria matches against only the last node in the path\n            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n            var path = treeChanges[pathtype.name] || [];\n            var nodes = isStateHook ? path : [common_1.tail(path)];\n            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n            return mn;\n        }, {});\n    };\n    /**\n     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n     *\n     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n     */\n    RegisteredHook.prototype.matches = function (treeChanges) {\n        var matches = this._getMatchingNodes(treeChanges);\n        // Check if all the criteria matched the TreeChanges object\n        var allMatched = common_1.values(matches).every(common_1.identity);\n        return allMatched ? matches : null;\n    };\n    return RegisteredHook;\n}());\nexports.RegisteredHook = RegisteredHook;\n/** @hidden Return a registration function of the requested type. */\nfunction makeEvent(registry, transitionService, eventType) {\n    // Create the object which holds the registered transition hooks.\n    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n    var hooks = _registeredHooks[eventType.name] = [];\n    // Create hook registration function on the IHookRegistry for the event\n    registry[eventType.name] = hookRegistrationFn;\n    function hookRegistrationFn(matchObject, callback, options) {\n        if (options === void 0) { options = {}; }\n        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);\n        hooks.push(registeredHook);\n        return function deregisterEventHook() {\n            registeredHook._deregistered = true;\n            common_1.removeFrom(hooks)(registeredHook);\n        };\n    }\n    return hookRegistrationFn;\n}\nexports.makeEvent = makeEvent;\n//# sourceMappingURL=hookRegistry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/transition/hookRegistry.js\n// module id = 29\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar interface_1 = require(\"./interface\");\nvar transition_1 = require(\"./transition\");\nvar hookRegistry_1 = require(\"./hookRegistry\");\nvar coreResolvables_1 = require(\"../hooks/coreResolvables\");\nvar redirectTo_1 = require(\"../hooks/redirectTo\");\nvar onEnterExitRetain_1 = require(\"../hooks/onEnterExitRetain\");\nvar resolve_1 = require(\"../hooks/resolve\");\nvar views_1 = require(\"../hooks/views\");\nvar updateGlobals_1 = require(\"../hooks/updateGlobals\");\nvar url_1 = require(\"../hooks/url\");\nvar lazyLoad_1 = require(\"../hooks/lazyLoad\");\nvar transitionEventType_1 = require(\"./transitionEventType\");\nvar transitionHook_1 = require(\"./transitionHook\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar ignoredTransition_1 = require(\"../hooks/ignoredTransition\");\nvar invalidTransition_1 = require(\"../hooks/invalidTransition\");\n/**\n * The default [[Transition]] options.\n *\n * Include this object when applying custom defaults:\n * let reloadOpts = { reload: true, notify: true }\n * let options = defaults(theirOpts, customDefaults, defaultOptions);\n */\nexports.defaultTransOpts = {\n    location: true,\n    relative: null,\n    inherit: false,\n    notify: true,\n    reload: false,\n    custom: {},\n    current: function () { return null; },\n    source: \"unknown\"\n};\n/**\n * This class provides services related to Transitions.\n *\n * - Most importantly, it allows global Transition Hooks to be registered.\n * - It allows the default transition error handler to be set.\n * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n *\n * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n */\nvar TransitionService = (function () {\n    /** @hidden */\n    function TransitionService(_router) {\n        /** @hidden */\n        this._transitionCount = 0;\n        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n        this._eventTypes = [];\n        /** @hidden The registered transition hooks */\n        this._registeredHooks = {};\n        /** @hidden The  paths on a criteria object */\n        this._criteriaPaths = {};\n        this._router = _router;\n        this.$view = _router.viewService;\n        this._deregisterHookFns = {};\n        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n            '_definePathType',\n            '_defineEvent',\n            '_getPathTypes',\n            '_getEvents',\n            'getHooks',\n        ]);\n        this._defineCorePaths();\n        this._defineCoreEvents();\n        this._registerCoreTransitionHooks();\n    }\n    /**\n     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n     *\n     * Registers a transition lifecycle hook, which is invoked during transition construction.\n     *\n     * This low level hook should only be used by plugins.\n     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n     * The Sticky States plugin uses this hook to modify the treechanges.\n     *\n     * ### Lifecycle\n     *\n     * `onCreate` hooks are invoked *while a transition is being constructed*.\n     *\n     * ### Return value\n     *\n     * The hook's return value is ignored\n     *\n     * @internalapi\n     * @param criteria defines which Transitions the Hook should be invoked for.\n     * @param callback the hook function which will be invoked.\n     * @param options the registration options\n     * @returns a function which deregisters the hook.\n     */\n    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n    /**\n     * dispose\n     * @internalapi\n     */\n    TransitionService.prototype.dispose = function (router) {\n        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n            hook._deregistered = true;\n            common_1.removeFrom(hooksArray, hook);\n        }); });\n    };\n    /**\n     * Creates a new [[Transition]] object\n     *\n     * This is a factory function for creating new Transition objects.\n     * It is used internally by the [[StateService]] and should generally not be called by application code.\n     *\n     * @param fromPath the path to the current state (the from state)\n     * @param targetState the target state (destination)\n     * @returns a Transition\n     */\n    TransitionService.prototype.create = function (fromPath, targetState) {\n        return new transition_1.Transition(fromPath, targetState, this._router);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCoreEvents = function () {\n        var Phase = interface_1.TransitionHookPhase;\n        var TH = transitionHook_1.TransitionHook;\n        var paths = this._criteriaPaths;\n        var NORMAL_SORT = false, REVERSE_SORT = true;\n        var ASYNCHRONOUS = false, SYNCHRONOUS = true;\n        this._defineEvent(\"onCreate\", Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);\n        this._defineEvent(\"onBefore\", Phase.BEFORE, 0, paths.to);\n        this._defineEvent(\"onStart\", Phase.RUN, 0, paths.to);\n        this._defineEvent(\"onExit\", Phase.RUN, 100, paths.exiting, REVERSE_SORT);\n        this._defineEvent(\"onRetain\", Phase.RUN, 200, paths.retained);\n        this._defineEvent(\"onEnter\", Phase.RUN, 300, paths.entering);\n        this._defineEvent(\"onFinish\", Phase.RUN, 400, paths.to);\n        this._defineEvent(\"onSuccess\", Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n        this._defineEvent(\"onError\", Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCorePaths = function () {\n        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n        this._definePathType(\"to\", TRANSITION);\n        this._definePathType(\"from\", TRANSITION);\n        this._definePathType(\"exiting\", STATE);\n        this._definePathType(\"retained\", STATE);\n        this._definePathType(\"entering\", STATE);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);\n        this._eventTypes.push(eventType);\n        hookRegistry_1.makeEvent(this, this, eventType);\n    };\n    ;\n    /** @hidden */\n    TransitionService.prototype._getEvents = function (phase) {\n        var transitionHookTypes = predicates_1.isDefined(phase) ?\n            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n            this._eventTypes.slice();\n        return transitionHookTypes.sort(function (l, r) {\n            var cmpByPhase = l.hookPhase - r.hookPhase;\n            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n        });\n    };\n    /**\n     * Adds a Path to be used as a criterion against a TreeChanges path\n     *\n     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n     *\n     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n     *\n     * @hidden\n     */\n    TransitionService.prototype._definePathType = function (name, hookScope) {\n        this._criteriaPaths[name] = { name: name, scope: hookScope };\n    };\n    /** * @hidden */\n    TransitionService.prototype._getPathTypes = function () {\n        return this._criteriaPaths;\n    };\n    /** @hidden */\n    TransitionService.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    /** @hidden */\n    TransitionService.prototype._registerCoreTransitionHooks = function () {\n        var fns = this._deregisterHookFns;\n        fns.addCoreResolves = coreResolvables_1.registerAddCoreResolvables(this);\n        fns.ignored = ignoredTransition_1.registerIgnoredTransitionHook(this);\n        fns.invalid = invalidTransition_1.registerInvalidTransitionHook(this);\n        // Wire up redirectTo hook\n        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n        // Wire up onExit/Retain/Enter state hooks\n        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n        // Wire up Resolve hooks\n        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n        // Wire up the View management hooks\n        fns.loadViews = views_1.registerLoadEnteringViews(this);\n        fns.activateViews = views_1.registerActivateViews(this);\n        // Updates global state after a transition\n        fns.updateGlobals = updateGlobals_1.registerUpdateGlobalState(this);\n        // After globals.current is updated at priority: 10000\n        fns.updateUrl = url_1.registerUpdateUrl(this);\n        // Lazy load state trees\n        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n    };\n    return TransitionService;\n}());\nexports.TransitionService = TransitionService;\n//# sourceMappingURL=transitionService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/transition/transitionService.js\n// module id = 30\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module ng1 */ /** for typedoc */\nvar core_1 = require(\"@uirouter/core\");\n/**\n * The Angular 1 `StateProvider`\n *\n * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\nvar StateProvider = (function () {\n    function StateProvider(stateRegistry, stateService) {\n        this.stateRegistry = stateRegistry;\n        this.stateService = stateService;\n        core_1.createProxyFunctions(core_1.val(StateProvider.prototype), this, core_1.val(this));\n    }\n    /**\n     * Decorates states when they are registered\n     *\n     * Allows you to extend (carefully) or override (at your own peril) the\n     * `stateBuilder` object used internally by [[StateRegistry]].\n     * This can be used to add custom functionality to ui-router,\n     * for example inferring templateUrl based on the state name.\n     *\n     * When passing only a name, it returns the current (original or decorated) builder\n     * function that matches `name`.\n     *\n     * The builder functions that can be decorated are listed below. Though not all\n     * necessarily have a good use case for decoration, that is up to you to decide.\n     *\n     * In addition, users can attach custom decorators, which will generate new\n     * properties within the state's internal definition. There is currently no clear\n     * use-case for this beyond accessing internal states (i.e. $state.$current),\n     * however, expect this to become increasingly relevant as we introduce additional\n     * meta-programming features.\n     *\n     * **Warning**: Decorators should not be interdependent because the order of\n     * execution of the builder functions in non-deterministic. Builder functions\n     * should only be dependent on the state definition object and super function.\n     *\n     *\n     * Existing builder functions and current return values:\n     *\n     * - **parent** `{object}` - returns the parent state object.\n     * - **data** `{object}` - returns state data, including any inherited data that is not\n     *   overridden by own values (if any).\n     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n     *   or `null`.\n     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n     *   navigable).\n     * - **params** `{object}` - returns an array of state params that are ensured to\n     *   be a super-set of parent's params.\n     * - **views** `{object}` - returns a views object where each key is an absolute view\n     *   name (i.e. \"viewName@stateName\") and each value is the config object\n     *   (template, controller) for the view. Even when you don't use the views object\n     *   explicitly on a state config, one is still created for you internally.\n     *   So by decorating this builder function you have access to decorating template\n     *   and controller properties.\n     * - **ownParams** `{object}` - returns an array of params that belong to the state,\n     *   not including any params defined by ancestor states.\n     * - **path** `{string}` - returns the full path from the root down to this state.\n     *   Needed for state activation.\n     * - **includes** `{object}` - returns an object that includes every state that\n     *   would pass a `$state.includes()` test.\n     *\n     * #### Example:\n     * Override the internal 'views' builder with a function that takes the state\n     * definition, and a reference to the internal function being overridden:\n     * ```js\n     * $stateProvider.decorator('views', function (state, parent) {\n     *   let result = {},\n     *       views = parent(state);\n     *\n     *   angular.forEach(views, function (config, name) {\n     *     let autoName = (state.name + '.' + name).replace('.', '/');\n     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n     *     result[name] = config;\n     *   });\n     *   return result;\n     * });\n     *\n     * $stateProvider.state('home', {\n     *   views: {\n     *     'contact.list': { controller: 'ListController' },\n     *     'contact.item': { controller: 'ItemController' }\n     *   }\n     * });\n     * ```\n     *\n     *\n     * ```js\n     * // Auto-populates list and item views with /partials/home/contact/list.html,\n     * // and /partials/home/contact/item.html, respectively.\n     * $state.go('home');\n     * ```\n     *\n     * @param {string} name The name of the builder function to decorate.\n     * @param {object} func A function that is responsible for decorating the original\n     * builder function. The function receives two parameters:\n     *\n     *   - `{object}` - state - The state config object.\n     *   - `{object}` - super - The original builder function.\n     *\n     * @return {object} $stateProvider - $stateProvider instance\n     */\n    StateProvider.prototype.decorator = function (name, func) {\n        return this.stateRegistry.decorator(name, func) || this;\n    };\n    StateProvider.prototype.state = function (name, definition) {\n        if (core_1.isObject(name)) {\n            definition = name;\n        }\n        else {\n            definition.name = name;\n        }\n        this.stateRegistry.register(definition);\n        return this;\n    };\n    /**\n     * Registers an invalid state handler\n     *\n     * This is a passthrough to [[StateService.onInvalid]] for ng1.\n     */\n    StateProvider.prototype.onInvalid = function (callback) {\n        return this.stateService.onInvalid(callback);\n    };\n    return StateProvider;\n}());\nexports.StateProvider = StateProvider;\n//# sourceMappingURL=stateProvider.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/stateProvider.js\n// module id = 31\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module url */ /** */\nvar core_1 = require(\"@uirouter/core\");\nvar core_2 = require(\"@uirouter/core\");\n/**\n * Manages rules for client-side URL\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class manages the router rules for what to do when the URL changes.\n *\n * This provider remains for backwards compatibility.\n *\n * @deprecated\n */\nvar UrlRouterProvider = (function () {\n    /** @hidden */\n    function UrlRouterProvider(router) {\n        this._router = router;\n        this._urlRouter = router.urlRouter;\n    }\n    /** @hidden */\n    UrlRouterProvider.prototype.$get = function () {\n        var urlRouter = this._urlRouter;\n        urlRouter.update(true);\n        if (!urlRouter.interceptDeferred)\n            urlRouter.listen();\n        return urlRouter;\n    };\n    /**\n     * Registers a url handler function.\n     *\n     * Registers a low level url handler (a `rule`).\n     * A rule detects specific URL patterns and returns a redirect, or performs some action.\n     *\n     * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Here's an example of how you might allow case insensitive urls\n     *   $urlRouterProvider.rule(function ($injector, $location) {\n     *     var path = $location.path(),\n     *         normalized = path.toLowerCase();\n     *\n     *     if (path !== normalized) {\n     *       return normalized;\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param ruleFn\n     * Handler function that takes `$injector` and `$location` services as arguments.\n     * You can use them to detect a url and return a different url as a string.\n     *\n     * @return [[UrlRouterProvider]] (`this`)\n     */\n    UrlRouterProvider.prototype.rule = function (ruleFn) {\n        var _this = this;\n        if (!core_2.isFunction(ruleFn))\n            throw new Error(\"'rule' must be a function\");\n        var match = function () {\n            return ruleFn(core_2.services.$injector, _this._router.locationService);\n        };\n        var rule = new core_1.BaseUrlRule(match, core_2.identity);\n        this._urlRouter.rule(rule);\n        return this;\n    };\n    ;\n    /**\n     * Defines the path or behavior to use when no url can be matched.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // if the path doesn't match any of the urls you configured\n     *   // otherwise will take care of routing the user to the\n     *   // specified url\n     *   $urlRouterProvider.otherwise('/index');\n     *\n     *   // Example of using function rule as param\n     *   $urlRouterProvider.otherwise(function ($injector, $location) {\n     *     return '/a/valid/url';\n     *   });\n     * });\n     * ```\n     *\n     * @param rule\n     * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.\n     * The function version is passed two params: `$injector` and `$location` services, and should return a url string.\n     *\n     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n     */\n    UrlRouterProvider.prototype.otherwise = function (rule) {\n        var _this = this;\n        var urlRouter = this._urlRouter;\n        if (core_2.isString(rule)) {\n            urlRouter.otherwise(rule);\n        }\n        else if (core_2.isFunction(rule)) {\n            urlRouter.otherwise(function () { return rule(core_2.services.$injector, _this._router.locationService); });\n        }\n        else {\n            throw new Error(\"'rule' must be a string or function\");\n        }\n        return this;\n    };\n    ;\n    /**\n     * Registers a handler for a given url matching.\n     *\n     * If the handler is a string, it is\n     * treated as a redirect, and is interpolated according to the syntax of match\n     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n     *\n     * If the handler is a function, it is injectable.\n     * It gets invoked if `$location` matches.\n     * You have the option of inject the match object as `$match`.\n     *\n     * The handler can return\n     *\n     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n     *   will continue trying to find another one that matches.\n     * - **string** which is treated as a redirect and passed to `$location.url()`\n     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n     *     if ($state.$current.navigable !== state ||\n     *         !equalForKeys($match, $stateParams) {\n     *      $state.transitionTo(state, $match, false);\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param what A pattern string to match, compiled as a [[UrlMatcher]].\n     * @param handler The path (or function that returns a path) that you want to redirect your user to.\n     * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]\n     *\n     * Note: the handler may also invoke arbitrary code, such as `$state.go()`\n     */\n    UrlRouterProvider.prototype.when = function (what, handler) {\n        if (core_2.isArray(handler) || core_2.isFunction(handler)) {\n            handler = UrlRouterProvider.injectableHandler(this._router, handler);\n        }\n        this._urlRouter.when(what, handler);\n        return this;\n    };\n    ;\n    UrlRouterProvider.injectableHandler = function (router, handler) {\n        return function (match) {\n            return core_2.services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params });\n        };\n    };\n    /**\n     * Disables monitoring of the URL.\n     *\n     * Call this method before UI-Router has bootstrapped.\n     * It will stop UI-Router from performing the initial url sync.\n     *\n     * This can be useful to perform some asynchronous initialization before the router starts.\n     * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Prevent $urlRouter from automatically intercepting URL changes;\n     *   $urlRouterProvider.deferIntercept();\n     * })\n     *\n     * app.run(function (MyService, $urlRouter, $http) {\n     *   $http.get(\"/stuff\").then(function(resp) {\n     *     MyService.doStuff(resp.data);\n     *     $urlRouter.listen();\n     *     $urlRouter.sync();\n     *   });\n     * });\n     * ```\n     *\n     * @param defer Indicates whether to defer location change interception.\n     *        Passing no parameter is equivalent to `true`.\n     */\n    UrlRouterProvider.prototype.deferIntercept = function (defer) {\n        this._urlRouter.deferIntercept(defer);\n    };\n    ;\n    return UrlRouterProvider;\n}());\nexports.UrlRouterProvider = UrlRouterProvider;\n//# sourceMappingURL=urlRouterProvider.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/urlRouterProvider.js\n// module id = 32\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */ /** */\nvar stateParams_1 = require(\"./params/stateParams\");\nvar queue_1 = require(\"./common/queue\");\n/**\n * Global router state\n *\n * This is where we hold the global mutable state such as current state, current\n * params, current transition, etc.\n */\nvar UIRouterGlobals = (function () {\n    function UIRouterGlobals() {\n        /**\n         * Current parameter values\n         *\n         * The parameter values from the latest successful transition\n         */\n        this.params = new stateParams_1.StateParams();\n        /** @internalapi */\n        this.lastStartedTransitionId = -1;\n        /** @internalapi */\n        this.transitionHistory = new queue_1.Queue([], 1);\n        /** @internalapi */\n        this.successfulTransitions = new queue_1.Queue([], 1);\n    }\n    UIRouterGlobals.prototype.dispose = function () {\n        this.transitionHistory.clear();\n        this.successfulTransitions.clear();\n        this.transition = null;\n    };\n    return UIRouterGlobals;\n}());\nexports.UIRouterGlobals = UIRouterGlobals;\n//# sourceMappingURL=globals.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/globals.js\n// module id = 33\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar coreservices_1 = require(\"../common/coreservices\");\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => System.import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nvar lazyLoadHook = function (transition) {\n    var router = transition.router;\n    function retryTransition() {\n        if (transition.originalTransition().options().source !== 'url') {\n            // The original transition was not triggered via url sync\n            // The lazy state should be loaded now, so re-try the original transition\n            var orig = transition.targetState();\n            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n        }\n        // The original transition was triggered via url sync\n        // Run the URL rules and find the best match\n        var $url = router.urlService;\n        var result = $url.match($url.parts());\n        var rule = result && result.rule;\n        // If the best match is a state, redirect the transition (instead\n        // of calling sync() which supersedes the current transition)\n        if (rule && rule.type === \"STATE\") {\n            var state = rule.state;\n            var params = result.match;\n            return router.stateService.target(state, params, transition.options());\n        }\n        // No matching state found, so let .sync() choose the best non-state match/otherwise\n        router.urlService.sync();\n    }\n    var promises = transition.entering()\n        .filter(function (state) { return !!state.$$state().lazyLoad; })\n        .map(function (state) { return lazyLoadState(transition, state); });\n    return coreservices_1.services.$q.all(promises).then(retryTransition);\n};\nexports.registerLazyLoadHook = function (transitionService) {\n    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nfunction lazyLoadState(transition, state) {\n    var lazyLoadFn = state.$$state().lazyLoad;\n    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n    var promise = lazyLoadFn['_promise'];\n    if (!promise) {\n        var success = function (result) {\n            delete state.lazyLoad;\n            delete state.$$state().lazyLoad;\n            delete lazyLoadFn['_promise'];\n            return result;\n        };\n        var error = function (err) {\n            delete lazyLoadFn['_promise'];\n            return coreservices_1.services.$q.reject(err);\n        };\n        promise = lazyLoadFn['_promise'] =\n            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n                .then(updateStateRegistry)\n                .then(success, error);\n    }\n    /** Register any lazy loaded state definitions */\n    function updateStateRegistry(result) {\n        if (result && Array.isArray(result.states)) {\n            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n        }\n        return result;\n    }\n    return promise;\n}\nexports.lazyLoadState = lazyLoadState;\n//# sourceMappingURL=lazyLoad.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/hooks/lazyLoad.js\n// module id = 34\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar hof_1 = require(\"../common/hof\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar paramType_1 = require(\"./paramType\");\n/**\n * A registry for parameter types.\n *\n * This registry manages the built-in (and custom) parameter types.\n *\n * The built-in parameter types are:\n *\n * - [[string]]\n * - [[path]]\n * - [[query]]\n * - [[hash]]\n * - [[int]]\n * - [[bool]]\n * - [[date]]\n * - [[json]]\n * - [[any]]\n */\nvar ParamTypes = (function () {\n    /** @internalapi */\n    function ParamTypes() {\n        /** @hidden */\n        this.enqueue = true;\n        /** @hidden */\n        this.typeQueue = [];\n        /** @internalapi */\n        this.defaultTypes = common_1.pick(ParamTypes.prototype, [\"hash\", \"string\", \"query\", \"path\", \"int\", \"bool\", \"date\", \"json\", \"any\"]);\n        // Register default types. Store them in the prototype of this.types.\n        var makeType = function (definition, name) {\n            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        };\n        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n    }\n    /** @internalapi */\n    ParamTypes.prototype.dispose = function () {\n        this.types = {};\n    };\n    /**\n     * Registers a parameter type\n     *\n     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n     */\n    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n        if (!predicates_1.isDefined(definition))\n            return this.types[name];\n        if (this.types.hasOwnProperty(name))\n            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        if (definitionFn) {\n            this.typeQueue.push({ name: name, def: definitionFn });\n            if (!this.enqueue)\n                this._flushTypeQueue();\n        }\n        return this;\n    };\n    /** @internalapi */\n    ParamTypes.prototype._flushTypeQueue = function () {\n        while (this.typeQueue.length) {\n            var type = this.typeQueue.shift();\n            if (type.pattern)\n                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n        }\n    };\n    return ParamTypes;\n}());\nexports.ParamTypes = ParamTypes;\n/** @hidden */\nfunction initDefaultTypes() {\n    var makeDefaultType = function (def) {\n        var valToString = function (val) {\n            return val != null ? val.toString() : val;\n        };\n        var defaultTypeBase = {\n            encode: valToString,\n            decode: valToString,\n            is: hof_1.is(String),\n            pattern: /.*/,\n            equals: function (a, b) { return a == b; },\n        };\n        return common_1.extend({}, defaultTypeBase, def);\n    };\n    // Default Parameter Type Definitions\n    common_1.extend(ParamTypes.prototype, {\n        string: makeDefaultType({}),\n        path: makeDefaultType({\n            pattern: /[^/]*/,\n        }),\n        query: makeDefaultType({}),\n        hash: makeDefaultType({\n            inherit: false,\n        }),\n        int: makeDefaultType({\n            decode: function (val) { return parseInt(val, 10); },\n            is: function (val) {\n                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n            },\n            pattern: /-?\\d+/,\n        }),\n        bool: makeDefaultType({\n            encode: function (val) { return val && 1 || 0; },\n            decode: function (val) { return parseInt(val, 10) !== 0; },\n            is: hof_1.is(Boolean),\n            pattern: /0|1/\n        }),\n        date: makeDefaultType({\n            encode: function (val) {\n                return !this.is(val) ? undefined : [\n                    val.getFullYear(),\n                    ('0' + (val.getMonth() + 1)).slice(-2),\n                    ('0' + val.getDate()).slice(-2)\n                ].join(\"-\");\n            },\n            decode: function (val) {\n                if (this.is(val))\n                    return val;\n                var match = this.capture.exec(val);\n                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n            },\n            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n            equals: function (l, r) {\n                return ['getFullYear', 'getMonth', 'getDate']\n                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n            },\n            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n        }),\n        json: makeDefaultType({\n            encode: common_1.toJson,\n            decode: common_1.fromJson,\n            is: hof_1.is(Object),\n            equals: common_1.equals,\n            pattern: /[^/]*/\n        }),\n        // does not encode/decode\n        any: makeDefaultType({\n            encode: common_1.identity,\n            decode: common_1.identity,\n            is: function () { return true; },\n            equals: common_1.equals,\n        }),\n    });\n}\ninitDefaultTypes();\n//# sourceMappingURL=paramTypes.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/params/paramTypes.js\n// module id = 35\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = require(\"../common/common\");\n/** @internalapi */\nvar StateParams = (function () {\n    function StateParams(params) {\n        if (params === void 0) { params = {}; }\n        common_1.extend(this, params);\n    }\n    /**\n     * Merges a set of parameters with all parameters inherited between the common parents of the\n     * current state and a given destination state.\n     *\n     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n     * @param {Object} $current Internal definition of object representing the current state.\n     * @param {Object} $to Internal definition of object representing state to transition to.\n     */\n    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n        for (var i in parents) {\n            if (!parents[i] || !parents[i].params)\n                continue;\n            parentParams = Object.keys(parents[i].params);\n            if (!parentParams.length)\n                continue;\n            for (var j in parentParams) {\n                if (inheritList.indexOf(parentParams[j]) >= 0)\n                    continue;\n                inheritList.push(parentParams[j]);\n                inherited[parentParams[j]] = this[parentParams[j]];\n            }\n        }\n        return common_1.extend({}, inherited, newParams);\n    };\n    ;\n    return StateParams;\n}());\nexports.StateParams = StateParams;\n//# sourceMappingURL=stateParams.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/params/stateParams.js\n// module id = 36\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @internalapi */\nexports.resolvePolicies = {\n    when: {\n        LAZY: \"LAZY\",\n        EAGER: \"EAGER\"\n    },\n    async: {\n        WAIT: \"WAIT\",\n        NOWAIT: \"NOWAIT\",\n        RXWAIT: \"RXWAIT\"\n    }\n};\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/resolve/interface.js\n// module id = 37\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */ /** */\nvar urlMatcherFactory_1 = require(\"./url/urlMatcherFactory\");\nvar urlRouter_1 = require(\"./url/urlRouter\");\nvar transitionService_1 = require(\"./transition/transitionService\");\nvar view_1 = require(\"./view/view\");\nvar stateRegistry_1 = require(\"./state/stateRegistry\");\nvar stateService_1 = require(\"./state/stateService\");\nvar globals_1 = require(\"./globals\");\nvar common_1 = require(\"./common/common\");\nvar predicates_1 = require(\"./common/predicates\");\nvar urlService_1 = require(\"./url/urlService\");\nvar trace_1 = require(\"./common/trace\");\n/** @hidden */\nvar _routerInstance = 0;\n/**\n * The master class used to instantiate an instance of UI-Router.\n *\n * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n * This class instantiates and wires the UI-Router services together.\n *\n * After a new instance of the UIRouter class is created, it should be configured for your app.\n * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n *\n * ---\n *\n * Normally the framework code will bootstrap UI-Router.\n * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n * [[UrlService.listen]] then [[UrlService.sync]].\n */\nvar UIRouter = (function () {\n    /**\n     * Creates a new `UIRouter` object\n     *\n     * @param locationService a [[LocationServices]] implementation\n     * @param locationConfig a [[LocationConfig]] implementation\n     * @internalapi\n     */\n    function UIRouter(locationService, locationConfig) {\n        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n        this.locationService = locationService;\n        this.locationConfig = locationConfig;\n        /** @hidden */ this.$id = _routerInstance++;\n        /** @hidden */ this._disposed = false;\n        /** @hidden */ this._disposables = [];\n        /** Provides trace information to the console */\n        this.trace = trace_1.trace;\n        /** Provides services related to ui-view synchronization */\n        this.viewService = new view_1.ViewService();\n        /** Provides services related to Transitions */\n        this.transitionService = new transitionService_1.TransitionService(this);\n        /** Global router state */\n        this.globals = new globals_1.UIRouterGlobals();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlRouter = new urlRouter_1.UrlRouter(this);\n        /** Provides a registry for states, and related registration services */\n        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n        /** Provides services related to states */\n        this.stateService = new stateService_1.StateService(this);\n        /** Provides services related to the URL */\n        this.urlService = new urlService_1.UrlService(this);\n        /** @hidden */\n        this._plugins = {};\n        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n        this.globals.$current = this.stateRegistry.root();\n        this.globals.current = this.globals.$current.self;\n        this.disposable(this.globals);\n        this.disposable(this.stateService);\n        this.disposable(this.stateRegistry);\n        this.disposable(this.transitionService);\n        this.disposable(this.urlRouter);\n        this.disposable(locationService);\n        this.disposable(locationConfig);\n    }\n    /** Registers an object to be notified when the router is disposed */\n    UIRouter.prototype.disposable = function (disposable) {\n        this._disposables.push(disposable);\n    };\n    /**\n     * Disposes this router instance\n     *\n     * When called, clears resources retained by the router by calling `dispose(this)` on all\n     * registered [[disposable]] objects.\n     *\n     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n     *\n     * @param disposable (optional) the disposable to dispose\n     */\n    UIRouter.prototype.dispose = function (disposable) {\n        var _this = this;\n        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n            disposable.dispose(this);\n            return undefined;\n        }\n        this._disposed = true;\n        this._disposables.slice().forEach(function (d) {\n            try {\n                typeof d.dispose === 'function' && d.dispose(_this);\n                common_1.removeFrom(_this._disposables, d);\n            }\n            catch (ignored) { }\n        });\n    };\n    /**\n     * Adds a plugin to UI-Router\n     *\n     * This method adds a UI-Router Plugin.\n     * A plugin can enhance or change UI-Router behavior using any public API.\n     *\n     * #### Example:\n     * ```js\n     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n     *\n     * var plugin = router.addPlugin(MyCoolPlugin);\n     * ```\n     *\n     * ### Plugin authoring\n     *\n     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n     *\n     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n     * For example, it may configure router options or add a Transition Hook.\n     *\n     * The plugin can then be published as a separate module.\n     *\n     * #### Example:\n     * ```js\n     * export class MyAuthPlugin implements UIRouterPlugin {\n     *   constructor(router: UIRouter, options: any) {\n     *     this.name = \"MyAuthPlugin\";\n     *     let $transitions = router.transitionService;\n     *     let $state = router.stateService;\n     *\n     *     let authCriteria = {\n     *       to: (state) => state.data && state.data.requiresAuth\n     *     };\n     *\n     *     function authHook(transition: Transition) {\n     *       let authService = transition.injector().get('AuthService');\n     *       if (!authService.isAuthenticated()) {\n     *         return $state.target('login');\n     *       }\n     *     }\n     *\n     *     $transitions.onStart(authCriteria, authHook);\n     *   }\n     * }\n     * ```\n     *\n     * @param plugin one of:\n     *        - a plugin class which implements [[UIRouterPlugin]]\n     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n     * @param options options to pass to the plugin class/factory\n     * @returns the registered plugin instance\n     */\n    UIRouter.prototype.plugin = function (plugin, options) {\n        if (options === void 0) { options = {}; }\n        var pluginInstance = new plugin(this, options);\n        if (!pluginInstance.name)\n            throw new Error(\"Required property `name` missing on plugin: \" + pluginInstance);\n        this._disposables.push(pluginInstance);\n        return this._plugins[pluginInstance.name] = pluginInstance;\n    };\n    UIRouter.prototype.getPlugin = function (pluginName) {\n        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n    };\n    return UIRouter;\n}());\nexports.UIRouter = UIRouter;\n//# sourceMappingURL=router.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/router.js\n// module id = 38\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar strings_1 = require(\"../common/strings\");\nvar hof_1 = require(\"../common/hof\");\nvar resolvable_1 = require(\"../resolve/resolvable\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar parseUrl = function (url) {\n    if (!predicates_1.isString(url))\n        return false;\n    var root = url.charAt(0) === '^';\n    return { val: root ? url.substring(1) : url, root: root };\n};\nfunction nameBuilder(state) {\n    return state.name;\n}\nfunction selfBuilder(state) {\n    state.self.$$state = function () { return state; };\n    return state.self;\n}\nfunction dataBuilder(state) {\n    if (state.parent && state.parent.data) {\n        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n    }\n    return state.data;\n}\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n    return function urlBuilder(state) {\n        var stateDec = state;\n        // For future states, i.e., states whose name ends with `.**`,\n        // match anything that starts with the url prefix\n        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n            stateDec.url += \"{remainder:any}\"; // match any path (.*)\n        }\n        var parsed = parseUrl(stateDec.url), parent = state.parent;\n        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n            params: state.params || {},\n            paramMap: function (paramConfig, isSearch) {\n                if (stateDec.reloadOnSearch === false && isSearch)\n                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n                return paramConfig;\n            }\n        });\n        if (!url)\n            return null;\n        if (!$urlMatcherFactoryProvider.isMatcher(url))\n            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n    };\n};\nvar getNavigableBuilder = function (isRoot) {\n    return function navigableBuilder(state) {\n        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n    };\n};\nvar getParamsBuilder = function (paramFactory) {\n    return function paramsBuilder(state) {\n        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n    };\n};\nfunction pathBuilder(state) {\n    return state.parent ? state.parent.path.concat(state) : [state];\n}\nfunction includesBuilder(state) {\n    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n    includes[state.name] = true;\n    return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\nfunction resolvablesBuilder(state) {\n    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n    var objects2Tuples = function (resolveObj, resolvePolicies) {\n        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n    };\n    /** fetch DI annotations from a function or ng1-style array */\n    var annotate = function (fn) {\n        var $injector = coreservices_1.services.$injector;\n        // ng1 doesn't have an $injector until runtime.\n        // If the $injector doesn't exist, use \"deferred\" literal as a\n        // marker indicating they should be annotated when runtime starts\n        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || \"deferred\";\n    };\n    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n    /** true if the object looks like a provide literal, or a ng2 Provider */\n    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n    /** true if the object looks like a tuple from obj2Tuples */\n    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n    /** extracts the token from a Provider or provide literal */\n    var token = function (p) { return p.provide || p.token; };\n    /** Given a literal resolve or provider object, returns a Resolvable */\n    var literal2Resolvable = hof_1.pattern([\n        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n    ]);\n    var tuple2Resolvable = hof_1.pattern([\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n        [hof_1.pipe(hof_1.prop(\"val\"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n    ]);\n    var item2Resolvable = hof_1.pattern([\n        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n        [isResolveLiteral, literal2Resolvable],\n        [isLikeNg2Provider, literal2Resolvable],\n        [isTupleFromObj, tuple2Resolvable],\n        [hof_1.val(true), function (obj) { throw new Error(\"Invalid resolve value: \" + strings_1.stringify(obj)); }]\n    ]);\n    // If resolveBlock is already an array, use it as-is.\n    // Otherwise, assume it's an object and convert to an Array of tuples\n    var decl = state.resolve;\n    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n    return items.map(item2Resolvable);\n}\nexports.resolvablesBuilder = resolvablesBuilder;\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[StateObject]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[StateObject]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n * using the [[builder]] method.\n */\nvar StateBuilder = (function () {\n    function StateBuilder(matcher, urlMatcherFactory) {\n        this.matcher = matcher;\n        var self = this;\n        var root = function () { return matcher.find(\"\"); };\n        var isRoot = function (state) { return state.name === \"\"; };\n        function parentBuilder(state) {\n            if (isRoot(state))\n                return null;\n            return matcher.find(self.parentName(state)) || root();\n        }\n        this.builders = {\n            name: [nameBuilder],\n            self: [selfBuilder],\n            parent: [parentBuilder],\n            data: [dataBuilder],\n            // Build a URLMatcher if necessary, either via a relative or absolute URL\n            url: [getUrlBuilder(urlMatcherFactory, root)],\n            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n            navigable: [getNavigableBuilder(isRoot)],\n            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n            // Each framework-specific ui-router implementation should define its own `views` builder\n            // e.g., src/ng1/statebuilders/views.ts\n            views: [],\n            // Keep a full path from the root down to this state as this is needed for state activation.\n            path: [pathBuilder],\n            // Speed up $state.includes() as it's used a lot\n            includes: [includesBuilder],\n            resolvables: [resolvablesBuilder]\n        };\n    }\n    /**\n     * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n     * More than one BuilderFunction can be registered for a given property.\n     *\n     * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n     *\n     * @param name The name of the State property being registered for.\n     * @param fn The BuilderFunction which will be used to build the State property\n     * @returns a function which deregisters the BuilderFunction\n     */\n    StateBuilder.prototype.builder = function (name, fn) {\n        var builders = this.builders;\n        var array = builders[name] || [];\n        // Backwards compat: if only one builder exists, return it, else return whole arary.\n        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n            return array.length > 1 ? array : array[0];\n        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n            return;\n        builders[name] = array;\n        builders[name].push(fn);\n        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n    };\n    /**\n     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n     * properties and API built.\n     *\n     * @param state an uninitialized State object\n     * @returns the built State object\n     */\n    StateBuilder.prototype.build = function (state) {\n        var _a = this, matcher = _a.matcher, builders = _a.builders;\n        var parent = this.parentName(state);\n        if (parent && !matcher.find(parent, undefined, false)) {\n            return null;\n        }\n        for (var key in builders) {\n            if (!builders.hasOwnProperty(key))\n                continue;\n            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n            state[key] = chain(state);\n        }\n        return state;\n    };\n    StateBuilder.prototype.parentName = function (state) {\n        var name = state.name || \"\";\n        var segments = name.split('.');\n        if (segments.length > 1) {\n            if (state.parent) {\n                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n            }\n            var lastSegment = segments.pop();\n            if (lastSegment === '**')\n                segments.pop();\n            return segments.join(\".\");\n        }\n        if (!state.parent)\n            return \"\";\n        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n    };\n    StateBuilder.prototype.name = function (state) {\n        var name = state.name;\n        if (name.indexOf('.') !== -1 || !state.parent)\n            return name;\n        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n        return parentName ? parentName + \".\" + name : name;\n    };\n    return StateBuilder;\n}());\nexports.StateBuilder = StateBuilder;\n//# sourceMappingURL=stateBuilder.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/state/stateBuilder.js\n// module id = 39\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\nvar StateMatcher = (function () {\n    function StateMatcher(_states) {\n        this._states = _states;\n    }\n    StateMatcher.prototype.isRelative = function (stateName) {\n        stateName = stateName || \"\";\n        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n    };\n    StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {\n        if (matchGlob === void 0) { matchGlob = true; }\n        if (!stateOrName && stateOrName !== \"\")\n            return undefined;\n        var isStr = predicates_1.isString(stateOrName);\n        var name = isStr ? stateOrName : stateOrName.name;\n        if (this.isRelative(name))\n            name = this.resolvePath(name, base);\n        var state = this._states[name];\n        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n            return state;\n        }\n        else if (isStr && matchGlob) {\n            var _states = common_1.values(this._states);\n            var matches = _states.filter(function (state) {\n                return state.__stateObjectCache.nameGlob &&\n                    state.__stateObjectCache.nameGlob.matches(name);\n            });\n            if (matches.length > 1) {\n                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n            }\n            return matches[0];\n        }\n        return undefined;\n    };\n    StateMatcher.prototype.resolvePath = function (name, base) {\n        if (!base)\n            throw new Error(\"No reference point given for path '\" + name + \"'\");\n        var baseState = this.find(base);\n        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n        for (; i < pathLength; i++) {\n            if (splitName[i] === \"\" && i === 0) {\n                current = baseState;\n                continue;\n            }\n            if (splitName[i] === \"^\") {\n                if (!current.parent)\n                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n                current = current.parent;\n                continue;\n            }\n            break;\n        }\n        var relName = splitName.slice(i).join(\".\");\n        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n    };\n    return StateMatcher;\n}());\nexports.StateMatcher = StateMatcher;\n//# sourceMappingURL=stateMatcher.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/state/stateMatcher.js\n// module id = 40\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar stateObject_1 = require(\"./stateObject\");\nvar hof_1 = require(\"../common/hof\");\n/** @internalapi */\nvar StateQueueManager = (function () {\n    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n        this.$registry = $registry;\n        this.$urlRouter = $urlRouter;\n        this.states = states;\n        this.builder = builder;\n        this.listeners = listeners;\n        this.queue = [];\n        this.matcher = $registry.matcher;\n    }\n    /** @internalapi */\n    StateQueueManager.prototype.dispose = function () {\n        this.queue = [];\n    };\n    StateQueueManager.prototype.register = function (stateDecl) {\n        var queue = this.queue;\n        var state = stateObject_1.StateObject.create(stateDecl);\n        var name = state.name;\n        if (!predicates_1.isString(name))\n            throw new Error(\"State must have a valid name\");\n        if (this.states.hasOwnProperty(name) || common_1.inArray(queue.map(hof_1.prop('name')), name))\n            throw new Error(\"State '\" + name + \"' is already defined\");\n        queue.push(state);\n        this.flush();\n        return state;\n    };\n    StateQueueManager.prototype.flush = function () {\n        var _this = this;\n        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n        var registered = [], // states that got registered\n        orphans = [], // states that don't yet have a parent registered\n        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n        var getState = function (name) {\n            return _this.states.hasOwnProperty(name) && _this.states[name];\n        };\n        while (queue.length > 0) {\n            var state = queue.shift();\n            var name_1 = state.name;\n            var result = builder.build(state);\n            var orphanIdx = orphans.indexOf(state);\n            if (result) {\n                var existingState = getState(name_1);\n                if (existingState && existingState.name === name_1) {\n                    throw new Error(\"State '\" + name_1 + \"' is already defined\");\n                }\n                var existingFutureState = getState(name_1 + \".**\");\n                if (existingFutureState) {\n                    // Remove future state of the same name\n                    this.$registry.deregister(existingFutureState);\n                }\n                states[name_1] = state;\n                this.attachRoute(state);\n                if (orphanIdx >= 0)\n                    orphans.splice(orphanIdx, 1);\n                registered.push(state);\n                continue;\n            }\n            var prev = previousQueueLength[name_1];\n            previousQueueLength[name_1] = queue.length;\n            if (orphanIdx >= 0 && prev === queue.length) {\n                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n                // throw new Error(`Cannot register orphaned state '${name}'`);\n                queue.push(state);\n                return states;\n            }\n            else if (orphanIdx < 0) {\n                orphans.push(state);\n            }\n            queue.push(state);\n        }\n        if (registered.length) {\n            this.listeners.forEach(function (listener) { return listener(\"registered\", registered.map(function (s) { return s.self; })); });\n        }\n        return states;\n    };\n    StateQueueManager.prototype.attachRoute = function (state) {\n        if (state.abstract || !state.url)\n            return;\n        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n    };\n    return StateQueueManager;\n}());\nexports.StateQueueManager = StateQueueManager;\n//# sourceMappingURL=stateQueueManager.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/state/stateQueueManager.js\n// module id = 41\n// module chunks = 0","\"use strict\";\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar stateMatcher_1 = require(\"./stateMatcher\");\nvar stateBuilder_1 = require(\"./stateBuilder\");\nvar stateQueueManager_1 = require(\"./stateQueueManager\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar StateRegistry = (function () {\n    /** @internalapi */\n    function StateRegistry(_router) {\n        this._router = _router;\n        this.states = {};\n        this.listeners = [];\n        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n        this._registerRoot();\n    }\n    /** @internalapi */\n    StateRegistry.prototype._registerRoot = function () {\n        var rootStateDef = {\n            name: '',\n            url: '^',\n            views: null,\n            params: {\n                '#': { value: null, type: 'hash', dynamic: true }\n            },\n            abstract: true\n        };\n        var _root = this._root = this.stateQueue.register(rootStateDef);\n        _root.navigable = null;\n    };\n    /** @internalapi */\n    StateRegistry.prototype.dispose = function () {\n        var _this = this;\n        this.stateQueue.dispose();\n        this.listeners = [];\n        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n    };\n    /**\n     * Listen for a State Registry events\n     *\n     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n     *\n     * #### Example:\n     * ```js\n     * let allStates = registry.get();\n     *\n     * // Later, invoke deregisterFn() to remove the listener\n     * let deregisterFn = registry.onStatesChanged((event, states) => {\n     *   switch(event) {\n     *     case: 'registered':\n     *       states.forEach(state => allStates.push(state));\n     *       break;\n     *     case: 'deregistered':\n     *       states.forEach(state => {\n     *         let idx = allStates.indexOf(state);\n     *         if (idx !== -1) allStates.splice(idx, 1);\n     *       });\n     *       break;\n     *   }\n     * });\n     * ```\n     *\n     * @param listener a callback function invoked when the registered states changes.\n     *        The function receives two parameters, `event` and `state`.\n     *        See [[StateRegistryListener]]\n     * @return a function that deregisters the listener\n     */\n    StateRegistry.prototype.onStatesChanged = function (listener) {\n        this.listeners.push(listener);\n        return function deregisterListener() {\n            common_1.removeFrom(this.listeners)(listener);\n        }.bind(this);\n    };\n    /**\n     * Gets the implicit root state\n     *\n     * Gets the root of the state tree.\n     * The root state is implicitly created by UI-Router.\n     * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]\n     *\n     * @return the root [[StateObject]]\n     */\n    StateRegistry.prototype.root = function () {\n        return this._root;\n    };\n    /**\n     * Adds a state to the registry\n     *\n     * Registers a [[StateDeclaration]] or queues it for registration.\n     *\n     * Note: a state will be queued if the state's parent isn't yet registered.\n     *\n     * @param stateDefinition the definition of the state to register.\n     * @returns the internal [[StateObject]] object.\n     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n     *          If the state was only queued, then the object is not fully built.\n     */\n    StateRegistry.prototype.register = function (stateDefinition) {\n        return this.stateQueue.register(stateDefinition);\n    };\n    /** @hidden */\n    StateRegistry.prototype._deregisterTree = function (state) {\n        var _this = this;\n        var all = this.get().map(function (s) { return s.$$state(); });\n        var getChildren = function (states) {\n            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n            return children.length === 0 ? children : children.concat(getChildren(children));\n        };\n        var children = getChildren([state]);\n        var deregistered = [state].concat(children).reverse();\n        deregistered.forEach(function (state) {\n            var $ur = _this._router.urlRouter;\n            // Remove URL rule\n            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n            // Remove state from registry\n            delete _this.states[state.name];\n        });\n        return deregistered;\n    };\n    /**\n     * Removes a state from the registry\n     *\n     * This removes a state from the registry.\n     * If the state has children, they are are also removed from the registry.\n     *\n     * @param stateOrName the state's name or object representation\n     * @returns {StateObject[]} a list of removed states\n     */\n    StateRegistry.prototype.deregister = function (stateOrName) {\n        var _state = this.get(stateOrName);\n        if (!_state)\n            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n        var deregisteredStates = this._deregisterTree(_state.$$state());\n        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n        return deregisteredStates;\n    };\n    StateRegistry.prototype.get = function (stateOrName, base) {\n        var _this = this;\n        if (arguments.length === 0)\n            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n        var found = this.matcher.find(stateOrName, base);\n        return found && found.self || null;\n    };\n    StateRegistry.prototype.decorator = function (name, func) {\n        return this.builder.builder(name, func);\n    };\n    return StateRegistry;\n}());\nexports.StateRegistry = StateRegistry;\n//# sourceMappingURL=stateRegistry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/state/stateRegistry.js\n// module id = 42\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module state\n */\n/** */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar queue_1 = require(\"../common/queue\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar pathFactory_1 = require(\"../path/pathFactory\");\nvar pathNode_1 = require(\"../path/pathNode\");\nvar transitionService_1 = require(\"../transition/transitionService\");\nvar rejectFactory_1 = require(\"../transition/rejectFactory\");\nvar targetState_1 = require(\"./targetState\");\nvar param_1 = require(\"../params/param\");\nvar glob_1 = require(\"../common/glob\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar lazyLoad_1 = require(\"../hooks/lazyLoad\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\nvar StateService = (function () {\n    /** @internalapi */\n    function StateService(router) {\n        this.router = router;\n        /** @internalapi */\n        this.invalidCallbacks = [];\n        /** @hidden */\n        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n            if ($error$ instanceof Error && $error$.stack) {\n                console.error($error$);\n                console.error($error$.stack);\n            }\n            else if ($error$ instanceof rejectFactory_1.Rejection) {\n                console.error($error$.toString());\n                if ($error$.detail && $error$.detail.stack)\n                    console.error($error$.detail.stack);\n            }\n            else {\n                console.error($error$);\n            }\n        };\n        var getters = ['current', '$current', 'params', 'transition'];\n        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n    }\n    Object.defineProperty(StateService.prototype, \"transition\", {\n        /**\n         * The [[Transition]] currently in progress (or null)\n         *\n         * This is a passthrough through to [[UIRouterGlobals.transition]]\n         */\n        get: function () { return this.router.globals.transition; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"params\", {\n        /**\n         * The latest successful state parameters\n         *\n         * This is a passthrough through to [[UIRouterGlobals.params]]\n         */\n        get: function () { return this.router.globals.params; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"current\", {\n        /**\n         * The current [[StateDeclaration]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.current]]\n         */\n        get: function () { return this.router.globals.current; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"$current\", {\n        /**\n         * The current [[StateObject]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.$current]]\n         */\n        get: function () { return this.router.globals.$current; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internalapi */\n    StateService.prototype.dispose = function () {\n        this.defaultErrorHandler(common_1.noop);\n        this.invalidCallbacks = [];\n    };\n    /**\n     * Handler for when [[transitionTo]] is called with an invalid state.\n     *\n     * Invokes the [[onInvalid]] callbacks, in natural order.\n     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n     *\n     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n     *\n     * @internalapi\n     */\n    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n        var _this = this;\n        var fromState = pathFactory_1.PathUtils.makeTargetState(fromPath);\n        var globals = this.router.globals;\n        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n        var latest = latestThing();\n        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n        var checkForRedirect = function (result) {\n            if (!(result instanceof targetState_1.TargetState)) {\n                return;\n            }\n            var target = result;\n            // Recreate the TargetState, in case the state is now defined.\n            target = _this.target(target.identifier(), target.params(), target.options());\n            if (!target.valid()) {\n                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n            }\n            if (latestThing() !== latest) {\n                return rejectFactory_1.Rejection.superseded().toPromise();\n            }\n            return _this.transitionTo(target.identifier(), target.params(), target.options());\n        };\n        function invokeNextCallback() {\n            var nextCallback = callbackQueue.dequeue();\n            if (nextCallback === undefined)\n                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n        }\n        return invokeNextCallback();\n    };\n    /**\n     * Registers an Invalid State handler\n     *\n     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n     * has been called with an invalid state reference parameter\n     *\n     * Example:\n     * ```js\n     * stateService.onInvalid(function(to, from, injector) {\n     *   if (to.name() === 'foo') {\n     *     let lazyLoader = injector.get('LazyLoadService');\n     *     return lazyLoader.load('foo')\n     *         .then(() => stateService.target('foo'));\n     *   }\n     * });\n     * ```\n     *\n     * @param {function} callback invoked when the toState is invalid\n     *   This function receives the (invalid) toState, the fromState, and an injector.\n     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n     *   If one is returned, it is treated as a redirect.\n     *\n     * @returns a function which deregisters the callback\n     */\n    StateService.prototype.onInvalid = function (callback) {\n        this.invalidCallbacks.push(callback);\n        return function deregisterListener() {\n            common_1.removeFrom(this.invalidCallbacks)(callback);\n        }.bind(this);\n    };\n    /**\n     * Reloads the current state\n     *\n     * A method that force reloads the current state, or a partial state hierarchy.\n     * All resolves are re-resolved, and components reinstantiated.\n     *\n     * #### Example:\n     * ```js\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * ```\n     *\n     * Note: `reload()` is just an alias for:\n     *\n     * ```js\n     * $state.transitionTo($state.current, $state.params, {\n     *   reload: true, inherit: false\n     * });\n     * ```\n     *\n     * @param reloadState A state name or a state object.\n     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n     *\n     * #### Example:\n     * ```js\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n     * //and current state is 'contacts.detail.item'\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * ```\n     *\n     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n     */\n    StateService.prototype.reload = function (reloadState) {\n        return this.transitionTo(this.current, this.params, {\n            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n            inherit: false,\n            notify: false,\n        });\n    };\n    ;\n    /**\n     * Transition to a different state and/or parameters\n     *\n     * Convenience method for transitioning to a new state.\n     *\n     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n     * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.\n     * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).\n     * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters\n     * inherit from the current parameter values (because of `inherit: true`).\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to Absolute state name, state object, or relative state path (relative to current state).\n     *\n     * Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to the parent state\n     * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state\n     * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state\n     *\n     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n     *\n     *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).\n     *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.\n     *\n     * @param options Transition options\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     */\n    StateService.prototype.go = function (to, params, options) {\n        var defautGoOpts = { relative: this.$current, inherit: true };\n        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n        return this.transitionTo(to, params, transOpts);\n    };\n    ;\n    /**\n     * Creates a [[TargetState]]\n     *\n     * This is a factory method for creating a TargetState\n     *\n     * This may be returned from a Transition Hook to redirect a transition, for example.\n     */\n    StateService.prototype.target = function (identifier, params, options) {\n        if (options === void 0) { options = {}; }\n        // If we're reloading, find the state object to reload from\n        if (predicates_1.isObject(options.reload) && !options.reload.name)\n            throw new Error('Invalid reload state object');\n        var reg = this.router.stateRegistry;\n        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n        if (options.reload && !options.reloadState)\n            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        var stateDefinition = reg.matcher.find(identifier, options.relative);\n        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n    };\n    ;\n    StateService.prototype.getCurrentPath = function () {\n        var _this = this;\n        var globals = this.router.globals;\n        var latestSuccess = globals.successfulTransitions.peekTail();\n        var rootPath = function () { return [new pathNode_1.PathNode(_this.router.stateRegistry.root())]; };\n        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n    };\n    /**\n     * Low-level method for transitioning to a new state.\n     *\n     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to State name or state object.\n     * @param toParams A map of the parameters that will be sent to the state,\n     *      will populate $stateParams.\n     * @param options Transition options\n     *\n     * @returns A promise representing the state of the new transition. See [[go]]\n     */\n    StateService.prototype.transitionTo = function (to, toParams, options) {\n        var _this = this;\n        if (toParams === void 0) { toParams = {}; }\n        if (options === void 0) { options = {}; }\n        var router = this.router;\n        var globals = router.globals;\n        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n        var getCurrent = function () {\n            return globals.transition;\n        };\n        options = common_1.extend(options, { current: getCurrent });\n        var ref = this.target(to, toParams, options);\n        var currentPath = this.getCurrentPath();\n        if (!ref.exists())\n            return this._handleInvalidTargetState(currentPath, ref);\n        if (!ref.valid())\n            return common_1.silentRejection(ref.error());\n        /**\n         * Special handling for Ignored, Aborted, and Redirected transitions\n         *\n         * The semantics for the transition.run() promise and the StateService.transitionTo()\n         * promise differ. For instance, the run() promise may be rejected because it was\n         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n         */\n        var rejectedTransitionHandler = function (transition) { return function (error) {\n            if (error instanceof rejectFactory_1.Rejection) {\n                var isLatest = router.globals.lastStartedTransitionId === transition.$id;\n                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n                    isLatest && router.urlRouter.update();\n                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n                    return coreservices_1.services.$q.when(globals.current);\n                }\n                var detail = error.detail;\n                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n                    // by returning the promise for the new (redirect) `Transition.run()`.\n                    var redirect = transition.redirect(detail);\n                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n                }\n                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n                    isLatest && router.urlRouter.update();\n                    return coreservices_1.services.$q.reject(error);\n                }\n            }\n            var errorHandler = _this.defaultErrorHandler();\n            errorHandler(error);\n            return coreservices_1.services.$q.reject(error);\n        }; };\n        var transition = this.router.transitionService.create(currentPath, ref);\n        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n        // Return a promise for the transition, which also has the transition object on it.\n        return common_1.extend(transitionToPromise, { transition: transition });\n    };\n    ;\n    /**\n     * Checks if the current state *is* the provided state\n     *\n     * Similar to [[includes]] but only checks for the full state name.\n     * If params is supplied then it will be tested for strict equality against the current\n     * active params object, so all params must match with none missing and no extras.\n     *\n     * #### Example:\n     * ```js\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     * ```\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * ```html\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * ```\n     *\n     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns Returns true if it is the state.\n     */\n    StateService.prototype.is = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (this.$current !== state)\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Checks if the current state *includes* the provided state\n     *\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * #### Example when `$state.$current.name === 'contacts.details.item'`\n     * ```js\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     * ```\n     *\n     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n     * ```js\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * ```\n     *\n     * @param stateOrName A partial name, relative name, glob pattern,\n     *   or state object to be searched for within the current state name.\n     * @param params A param object, e.g. `{sectionId: section.id}`,\n     *   that you'd like to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    StateService.prototype.includes = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n        if (glob) {\n            if (!glob.matches(this.$current.name))\n                return false;\n            stateOrName = this.$current.name;\n        }\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (!predicates_1.isDefined(include[state.name]))\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Generates a URL for a state and parameters\n     *\n     * Returns the url for the given state populated with the given params.\n     *\n     * #### Example:\n     * ```js\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * ```\n     *\n     * @param stateOrName The state name or state object you'd like to generate a url from.\n     * @param params An object of parameter values to fill the state's required parameters.\n     * @param options Options object. The options are:\n     *\n     * @returns {string} compiled state url\n     */\n    StateService.prototype.href = function (stateOrName, params, options) {\n        var defaultHrefOpts = {\n            lossy: true,\n            inherit: true,\n            absolute: false,\n            relative: this.$current,\n        };\n        options = common_1.defaults(options, defaultHrefOpts);\n        params = params || {};\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return null;\n        if (options.inherit)\n            params = this.params.$inherit(params, this.$current, state);\n        var nav = (state && options.lossy) ? state.navigable : state;\n        if (!nav || nav.url === undefined || nav.url === null) {\n            return null;\n        }\n        return this.router.urlRouter.href(nav.url, params, {\n            absolute: options.absolute,\n        });\n    };\n    ;\n    /**\n     * Sets or gets the default [[transitionTo]] error handler.\n     *\n     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n     * This includes errors caused by resolves and transition hooks.\n     *\n     * Note:\n     * This handler does not receive certain Transition rejections.\n     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n     *\n     * The built-in default error handler logs the error to the console.\n     *\n     * You can provide your own custom handler.\n     *\n     * #### Example:\n     * ```js\n     * stateService.defaultErrorHandler(function() {\n     *   // Do not log transitionTo errors\n     * });\n     * ```\n     *\n     * @param handler a global error handler function\n     * @returns the current global error handler\n     */\n    StateService.prototype.defaultErrorHandler = function (handler) {\n        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n    };\n    StateService.prototype.get = function (stateOrName, base) {\n        var reg = this.router.stateRegistry;\n        if (arguments.length === 0)\n            return reg.get();\n        return reg.get(stateOrName, base || this.$current);\n    };\n    /**\n     * Lazy loads a state\n     *\n     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n     *\n     * @param stateOrName the state that should be lazy loaded\n     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n     * This noop transition is not actually run.\n     *\n     * @returns a promise to lazy load\n     */\n    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n        var state = this.get(stateOrName);\n        if (!state || !state.lazyLoad)\n            throw new Error(\"Can not lazy load \" + stateOrName);\n        var currentPath = this.getCurrentPath();\n        var target = pathFactory_1.PathUtils.makeTargetState(currentPath);\n        transition = transition || this.router.transitionService.create(currentPath, target);\n        return lazyLoad_1.lazyLoadState(transition, state);\n    };\n    return StateService;\n}());\nexports.StateService = StateService;\n//# sourceMappingURL=stateService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/state/stateService.js\n// module id = 43\n// module chunks = 0","\"use strict\";\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar interface_1 = require(\"./interface\");\nvar transitionHook_1 = require(\"./transitionHook\");\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nvar HookBuilder = (function () {\n    function HookBuilder(transition) {\n        this.transition = transition;\n    }\n    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n        var _this = this;\n        var $transitions = this.transition.router.transitionService;\n        return $transitions._pluginapi._getEvents(phase)\n            .map(function (type) { return _this.buildHooks(type); })\n            .reduce(common_1.unnestR, [])\n            .filter(common_1.identity);\n    };\n    /**\n     * Returns an array of newly built TransitionHook objects.\n     *\n     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n     * - For each of the [[PathNode]]s, creates a TransitionHook\n     *\n     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n     */\n    HookBuilder.prototype.buildHooks = function (hookType) {\n        var transition = this.transition;\n        var treeChanges = transition.treeChanges();\n        // Find all the matching registered hooks for a given hook type\n        var matchingHooks = this.getMatchingHooks(hookType, treeChanges);\n        if (!matchingHooks)\n            return [];\n        var baseHookOptions = {\n            transition: transition,\n            current: transition.options().current\n        };\n        var makeTransitionHooks = function (hook) {\n            // Fetch the Nodes that caused this hook to match.\n            var matches = hook.matches(treeChanges);\n            // Select the PathNode[] that will be used as TransitionHook context objects\n            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n            // Return an array of HookTuples\n            return matchingNodes.map(function (node) {\n                var _options = common_1.extend({\n                    bind: hook.bind,\n                    traceData: { hookType: hookType.name, context: node }\n                }, baseHookOptions);\n                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state.self : null;\n                var transitionHook = new transitionHook_1.TransitionHook(transition, state, hook, _options);\n                return { hook: hook, node: node, transitionHook: transitionHook };\n            });\n        };\n        return matchingHooks.map(makeTransitionHooks)\n            .reduce(common_1.unnestR, [])\n            .sort(tupleSort(hookType.reverseSort))\n            .map(function (tuple) { return tuple.transitionHook; });\n    };\n    /**\n     * Finds all RegisteredHooks from:\n     * - The Transition object instance hook registry\n     * - The TransitionService ($transitions) global hook registry\n     *\n     * which matched:\n     * - the eventType\n     * - the matchCriteria (to, from, exiting, retained, entering)\n     *\n     * @returns an array of matched [[RegisteredHook]]s\n     */\n    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n        // Instance and Global hook registries\n        var $transitions = this.transition.router.transitionService;\n        var registries = isCreate ? [$transitions] : [this.transition, $transitions];\n        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n    };\n    return HookBuilder;\n}());\nexports.HookBuilder = HookBuilder;\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort) {\n    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n    return function nodeDepthThenPriority(l, r) {\n        var factor = reverseDepthSort ? -1 : 1;\n        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n    };\n}\n//# sourceMappingURL=hookBuilder.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/transition/hookBuilder.js\n// module id = 44\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar transitionHook_1 = require(\"./transitionHook\");\n/**\n * This class defines a type of hook, such as `onBefore` or `onEnter`.\n * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n *\n * @interalapi\n */\nvar TransitionEventType = (function () {\n    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        this.name = name;\n        this.hookPhase = hookPhase;\n        this.hookOrder = hookOrder;\n        this.criteriaMatchPath = criteriaMatchPath;\n        this.reverseSort = reverseSort;\n        this.getResultHandler = getResultHandler;\n        this.getErrorHandler = getErrorHandler;\n        this.synchronous = synchronous;\n    }\n    return TransitionEventType;\n}());\nexports.TransitionEventType = TransitionEventType;\n//# sourceMappingURL=transitionEventType.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/transition/transitionEventType.js\n// module id = 45\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module url\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar param_1 = require(\"../params/param\");\nvar paramTypes_1 = require(\"../params/paramTypes\");\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\nvar UrlMatcherFactory = (function () {\n    function UrlMatcherFactory() {\n        var _this = this;\n        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n        /** @hidden */ this._isCaseInsensitive = false;\n        /** @hidden */ this._isStrictMode = true;\n        /** @hidden */ this._defaultSquashPolicy = false;\n        /** @hidden */\n        this._getConfig = function (config) {\n            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n        };\n        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n        this.paramFactory = {\n            /** Creates a new [[Param]] from a CONFIG block */\n            fromConfig: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n            },\n            /** Creates a new [[Param]] from a url PATH */\n            fromPath: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n            },\n            /** Creates a new [[Param]] from a url SEARCH */\n            fromSearch: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n            },\n        };\n        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n    }\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.strictMode = function (value) {\n        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n    };\n    /**\n     * Creates a [[UrlMatcher]] for the specified pattern.\n     *\n     * @param pattern  The URL pattern.\n     * @param config  The config object hash.\n     * @returns The UrlMatcher.\n     */\n    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n    };\n    /**\n     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n     *\n     * @param object  The object to perform the type check against.\n     * @returns `true` if the object matches the `UrlMatcher` interface, by\n     *          implementing all the same methods.\n     */\n    UrlMatcherFactory.prototype.isMatcher = function (object) {\n        // TODO: typeof?\n        if (!predicates_1.isObject(object))\n            return false;\n        var result = true;\n        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n            if (predicates_1.isFunction(val))\n                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n        });\n        return result;\n    };\n    ;\n    /**\n     * Creates and registers a custom [[ParamType]] object\n     *\n     * A [[ParamType]] can be used to generate URLs with typed parameters.\n     *\n     * @param name  The type name.\n     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n     * @param definitionFn A function that is injected before the app runtime starts.\n     *        The result of this function should be a [[ParamTypeDefinition]].\n     *        The result is merged into the existing `definition`.\n     *        See [[ParamType]] for information on the values accepted.\n     *\n     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n     *\n     * Note: Register custom types *before using them* in a state definition.\n     *\n     * See [[ParamTypeDefinition]] for examples\n     */\n    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n        var type = this.paramTypes.type(name, definition, definitionFn);\n        return !predicates_1.isDefined(definition) ? type : this;\n    };\n    ;\n    /** @hidden */\n    UrlMatcherFactory.prototype.$get = function () {\n        this.paramTypes.enqueue = false;\n        this.paramTypes._flushTypeQueue();\n        return this;\n    };\n    ;\n    /** @internalapi */\n    UrlMatcherFactory.prototype.dispose = function () {\n        this.paramTypes.dispose();\n    };\n    return UrlMatcherFactory;\n}());\nexports.UrlMatcherFactory = UrlMatcherFactory;\n//# sourceMappingURL=urlMatcherFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/url/urlMatcherFactory.js\n// module id = 46\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar predicates_1 = require(\"../common/predicates\");\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar hof_1 = require(\"../common/hof\");\nvar urlRule_1 = require(\"./urlRule\");\nvar targetState_1 = require(\"../state/targetState\");\n/** @hidden */\nfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n    if (baseHref === '/')\n        return url;\n    if (isHtml5)\n        return baseHref.slice(0, -1) + url;\n    if (absolute)\n        return baseHref.slice(1) + url;\n    return url;\n}\n/** @hidden */\nvar getMatcher = hof_1.prop(\"urlMatcher\");\n/**\n * Default rule priority sorting function.\n *\n * Sorts rules by:\n *\n * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n * - Registration order (for rule types other than STATE and URLMATCHER)\n *\n * @coreapi\n */\nvar defaultRuleSortFn;\ndefaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop(\"priority\"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop(\"type\"), function (type) { return ({ \"STATE\": 4, \"URLMATCHER\": 4, \"REGEXP\": 3, \"RAW\": 2, \"OTHER\": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop(\"$id\"), common_1.inArray([\"REGEXP\", \"RAW\", \"OTHER\"])));\n/**\n * Updates URL and responds to URL changes\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class updates the URL when the state changes.\n * It also responds to changes in the URL.\n */\nvar UrlRouter = (function () {\n    /** @hidden */\n    function UrlRouter(router) {\n        /** @hidden */ this._sortFn = defaultRuleSortFn;\n        /** @hidden */ this._rules = [];\n        /** @hidden */ this.interceptDeferred = false;\n        /** @hidden */ this._id = 0;\n        /** @hidden */ this._sorted = false;\n        this._router = router;\n        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n    }\n    /** @internalapi */\n    UrlRouter.prototype.dispose = function () {\n        this.listen(false);\n        this._rules = [];\n        delete this._otherwiseFn;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sort = function (compareFn) {\n        this._rules.sort(this._sortFn = compareFn || this._sortFn);\n        this._sorted = true;\n    };\n    UrlRouter.prototype.ensureSorted = function () {\n        this._sorted || this.sort();\n    };\n    /**\n     * Given a URL, check all rules and return the best [[MatchResult]]\n     * @param url\n     * @returns {MatchResult}\n     */\n    UrlRouter.prototype.match = function (url) {\n        var _this = this;\n        this.ensureSorted();\n        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n        var rules = this.rules();\n        if (this._otherwiseFn)\n            rules.push(this._otherwiseFn);\n        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n        var checkRule = function (rule) {\n            var match = rule.match(url, _this._router);\n            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n        };\n        // The rules are pre-sorted.\n        // - Find the first matching rule.\n        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n        // - Choose the rule with the highest match weight.\n        var best;\n        for (var i = 0; i < rules.length; i++) {\n            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n            if (best && this._sortFn(rules[i], best.rule) !== 0)\n                break;\n            var current = checkRule(rules[i]);\n            // Pick the best MatchResult\n            best = (!best || current && current.weight > best.weight) ? current : best;\n        }\n        return best;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sync = function (evt) {\n        if (evt && evt.defaultPrevented)\n            return;\n        var router = this._router, $url = router.urlService, $state = router.stateService;\n        var url = {\n            path: $url.path(), search: $url.search(), hash: $url.hash(),\n        };\n        var best = this.match(url);\n        var applyResult = hof_1.pattern([\n            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n        ]);\n        applyResult(best && best.rule.handler(best.match, url, router));\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.listen = function (enabled) {\n        var _this = this;\n        if (enabled === false) {\n            this._stopFn && this._stopFn();\n            delete this._stopFn;\n        }\n        else {\n            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n        }\n    };\n    /**\n     * Internal API.\n     * @internalapi\n     */\n    UrlRouter.prototype.update = function (read) {\n        var $url = this._router.locationService;\n        if (read) {\n            this.location = $url.path();\n            return;\n        }\n        if ($url.path() === this.location)\n            return;\n        $url.url(this.location, true);\n    };\n    /**\n     * Internal API.\n     *\n     * Pushes a new location to the browser history.\n     *\n     * @internalapi\n     * @param urlMatcher\n     * @param params\n     * @param options\n     */\n    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n        var replace = options && !!options.replace;\n        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n    };\n    /**\n     * Builds and returns a URL with interpolated parameters\n     *\n     * #### Example:\n     * ```js\n     * matcher = $umf.compile(\"/about/:person\");\n     * params = { person: \"bob\" };\n     * $bob = $urlRouter.href(matcher, params);\n     * // $bob == \"/about/bob\";\n     * ```\n     *\n     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n     * @param params An object of parameter values to fill the matcher's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n     */\n    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n        var url = urlMatcher.format(params);\n        if (url == null)\n            return null;\n        options = options || { absolute: false };\n        var cfg = this._router.urlService.config;\n        var isHtml5 = cfg.html5Mode();\n        if (!isHtml5 && url !== null) {\n            url = \"#\" + cfg.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n        if (!options.absolute || !url) {\n            return url;\n        }\n        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n    };\n    /**\n     * Manually adds a URL Rule.\n     *\n     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n     *\n     * A rule should have a `match` function which returns truthy if the rule matched.\n     * It should also have a `handler` function which is invoked if the rule is the best match.\n     *\n     * @return a function that deregisters the rule\n     */\n    UrlRouter.prototype.rule = function (rule) {\n        var _this = this;\n        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n            throw new Error(\"invalid rule\");\n        rule.$id = this._id++;\n        rule.priority = rule.priority || 0;\n        this._rules.push(rule);\n        this._sorted = false;\n        return function () { return _this.removeRule(rule); };\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.removeRule = function (rule) {\n        common_1.removeFrom(this._rules, rule);\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.rules = function () {\n        this.ensureSorted();\n        return this._rules.slice();\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.otherwise = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n        this._sorted = false;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.initial = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        var matchFn = function (urlParts, router) {\n            return router.globals.transitionHistory.size() === 0 && !!/^\\/?$/.exec(urlParts.path);\n        };\n        this.rule(this.urlRuleFactory.create(matchFn, handlerFn));\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.when = function (matcher, handler, options) {\n        var rule = this.urlRuleFactory.create(matcher, handler);\n        if (predicates_1.isDefined(options && options.priority))\n            rule.priority = options.priority;\n        this.rule(rule);\n        return rule;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.deferIntercept = function (defer) {\n        if (defer === undefined)\n            defer = true;\n        this.interceptDeferred = defer;\n    };\n    ;\n    return UrlRouter;\n}());\nexports.UrlRouter = UrlRouter;\nfunction getHandlerFn(handler) {\n    if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n        throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n    }\n    return predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n}\n//# sourceMappingURL=urlRouter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/url/urlRouter.js\n// module id = 47\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module url\n */ /** */\nvar urlMatcher_1 = require(\"./urlMatcher\");\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n * @internalapi\n */\nvar UrlRuleFactory = (function () {\n    function UrlRuleFactory(router) {\n        this.router = router;\n    }\n    UrlRuleFactory.prototype.compile = function (str) {\n        return this.router.urlMatcherFactory.compile(str);\n    };\n    UrlRuleFactory.prototype.create = function (what, handler) {\n        var _this = this;\n        var makeRule = hof_1.pattern([\n            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n            [predicates_1.isState, function (_what) { return _this.fromState(_what, _this.router); }],\n            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n        ]);\n        var rule = makeRule(what);\n        if (!rule)\n            throw new Error(\"invalid 'what' in when()\");\n        return rule;\n    };\n    /**\n     * A UrlRule which matches based on a UrlMatcher\n     *\n     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     *\n     * ## Handler as UrlMatcher\n     *\n     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n     * The url is replaced with the result.\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n        var _handler = handler;\n        if (predicates_1.isString(handler))\n            handler = this.router.urlMatcherFactory.compile(handler);\n        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n            _handler = function (match) { return handler.format(match); };\n        function match(url) {\n            var match = urlMatcher.exec(url.path, url.search, url.hash);\n            return urlMatcher.validates(match) && match;\n        }\n        // Prioritize URLs, lowest to highest:\n        // - Some optional URL parameters, but none matched\n        // - No optional parameters in URL\n        // - Some optional parameters, some matched\n        // - Some optional parameters, all matched\n        function matchPriority(params) {\n            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n            if (!optional.length)\n                return 0.000001;\n            var matched = optional.filter(function (param) { return params[param.id]; });\n            return matched.length / optional.length;\n        }\n        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    /**\n     * A UrlRule which matches a state by its url\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromState($state.get('foo'), router);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match);\n     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n     * ```\n     */\n    UrlRuleFactory.prototype.fromState = function (state, router) {\n        /**\n         * Handles match by transitioning to matched state\n         *\n         * First checks if the router should start a new transition.\n         * A new transition is not required if the current state's URL\n         * and the new URL are already identical\n         */\n        var handler = function (match) {\n            var $state = router.stateService;\n            var globals = router.globals;\n            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n            }\n        };\n        var details = { state: state, type: \"STATE\" };\n        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n    };\n    /**\n     * A UrlRule which matches based on a regular expression\n     *\n     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - regexp match array (from `regexp`)\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     *\n     * ## Handler as string\n     *\n     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n     * The string is first interpolated using `string.replace()` style pattern.\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n        if (regexp.global || regexp.sticky)\n            throw new Error(\"Rule RegExp must not be global or sticky\");\n        /**\n         * If handler is a string, the url will be replaced by the string.\n         * If the string has any String.replace() style variables in it (like `$2`),\n         * they will be replaced by the captures from [[match]]\n         */\n        var redirectUrlTo = function (match) {\n            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n                return match[what === '$' ? 0 : Number(what)];\n            });\n        };\n        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n        var match = function (url) {\n            return regexp.exec(url.path);\n        };\n        var details = { regexp: regexp, type: \"REGEXP\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    return UrlRuleFactory;\n}());\nUrlRuleFactory.isUrlRule = function (obj) {\n    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n};\nexports.UrlRuleFactory = UrlRuleFactory;\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nvar BaseUrlRule = (function () {\n    function BaseUrlRule(match, handler) {\n        var _this = this;\n        this.match = match;\n        this.type = \"RAW\";\n        this.matchPriority = function (match) { return 0 - _this.$id; };\n        this.handler = handler || common_1.identity;\n    }\n    return BaseUrlRule;\n}());\nexports.BaseUrlRule = BaseUrlRule;\n//# sourceMappingURL=urlRule.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/url/urlRule.js\n// module id = 48\n// module chunks = 0","\"use strict\";\n/**\n * @coreapi\n * @module url\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar coreservices_1 = require(\"../common/coreservices\");\nvar common_1 = require(\"../common/common\");\n/** @hidden */\nvar makeStub = function (keys) {\n    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n};\n/** @hidden */ var locationServicesFns = [\"url\", \"path\", \"search\", \"hash\", \"onChange\"];\n/** @hidden */ var locationConfigFns = [\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"];\n/** @hidden */ var umfFns = [\"type\", \"caseInsensitive\", \"strictMode\", \"defaultSquashPolicy\"];\n/** @hidden */ var rulesFns = [\"sort\", \"when\", \"initial\", \"otherwise\", \"rules\", \"rule\", \"removeRule\"];\n/** @hidden */ var syncFns = [\"deferIntercept\", \"listen\", \"sync\", \"match\"];\n/**\n * API for URL management\n */\nvar UrlService = (function () {\n    /** @hidden */\n    function UrlService(router, lateBind) {\n        if (lateBind === void 0) { lateBind = true; }\n        this.router = router;\n        this.rules = {};\n        this.config = {};\n        // proxy function calls from UrlService to the LocationService/LocationConfig\n        var locationServices = function () { return router.locationService; };\n        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n        var locationConfig = function () { return router.locationConfig; };\n        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n        var umf = function () { return router.urlMatcherFactory; };\n        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n        var urlRouter = function () { return router.urlRouter; };\n        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n    }\n    UrlService.prototype.url = function (newurl, replace, state) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.path = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.search = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.hash = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.onChange = function (callback) { return; };\n    ;\n    /**\n     * Returns the current URL parts\n     *\n     * This method returns the current URL components as a [[UrlParts]] object.\n     *\n     * @returns the current url parts\n     */\n    UrlService.prototype.parts = function () {\n        return { path: this.path(), search: this.search(), hash: this.hash() };\n    };\n    UrlService.prototype.dispose = function () { };\n    /** @inheritdoc */\n    UrlService.prototype.sync = function (evt) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.listen = function (enabled) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.deferIntercept = function (defer) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.match = function (urlParts) { return; };\n    return UrlService;\n}());\n/** @hidden */\nUrlService.locationServiceStub = makeStub(locationServicesFns);\n/** @hidden */\nUrlService.locationConfigStub = makeStub(locationConfigFns);\nexports.UrlService = UrlService;\n//# sourceMappingURL=urlService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/url/urlService.js\n// module id = 49\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar predicates_1 = require(\"../common/predicates\");\n/** A `LocationConfig` that delegates to the browser's `location` object */\nvar BrowserLocationConfig = (function () {\n    function BrowserLocationConfig(router, _isHtml5) {\n        if (_isHtml5 === void 0) { _isHtml5 = false; }\n        this._isHtml5 = _isHtml5;\n        this._baseHref = undefined;\n        this._hashPrefix = \"\";\n    }\n    BrowserLocationConfig.prototype.port = function () {\n        if (location.port) {\n            return Number(location.port);\n        }\n        return this.protocol() === 'https' ? 443 : 80;\n    };\n    BrowserLocationConfig.prototype.protocol = function () {\n        return location.protocol.replace(/:/g, '');\n    };\n    BrowserLocationConfig.prototype.host = function () {\n        return location.host;\n    };\n    BrowserLocationConfig.prototype.html5Mode = function () {\n        return this._isHtml5;\n    };\n    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n    };\n    ;\n    BrowserLocationConfig.prototype.baseHref = function (href) {\n        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();\n    };\n    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n        var baseTags = document.getElementsByTagName(\"base\");\n        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : \"\";\n    };\n    BrowserLocationConfig.prototype.dispose = function () { };\n    return BrowserLocationConfig;\n}());\nexports.BrowserLocationConfig = BrowserLocationConfig;\n//# sourceMappingURL=browserLocationConfig.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla/browserLocationConfig.js\n// module id = 50\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar utils_1 = require(\"./utils\");\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\nvar HashLocationService = (function (_super) {\n    __extends(HashLocationService, _super);\n    function HashLocationService(router) {\n        var _this = _super.call(this, router, false) || this;\n        window.addEventListener('hashchange', _this._listener, false);\n        return _this;\n    }\n    HashLocationService.prototype._get = function () {\n        return utils_1.trimHashVal(this._location.hash);\n    };\n    HashLocationService.prototype._set = function (state, title, url, replace) {\n        this._location.hash = url;\n    };\n    HashLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener('hashchange', this._listener);\n    };\n    return HashLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.HashLocationService = HashLocationService;\n//# sourceMappingURL=hashLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla/hashLocationService.js\n// module id = 51\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\n// globally available injectables\nvar globals = {};\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nexports.$injector = {\n    /** Gets an object from DI based on a string token */\n    get: function (name) { return globals[name]; },\n    /** Returns true if an object named `name` exists in global DI */\n    has: function (name) { return exports.$injector.get(name) != null; },\n    /**\n     * Injects a function\n     *\n     * @param fn the function to inject\n     * @param context the function's `this` binding\n     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n     */\n    invoke: function (fn, context, locals) {\n        var all = index_1.extend({}, globals, locals || {});\n        var params = exports.$injector.annotate(fn);\n        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n        if (index_1.isFunction(fn))\n            return fn.apply(context, args);\n        else\n            return fn.slice(-1)[0].apply(context, args);\n    },\n    /**\n     * Returns a function's dependencies\n     *\n     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n     * @return an array of `string`s\n     */\n    annotate: function (fn) {\n        if (!index_1.isInjectable(fn))\n            throw new Error(\"Not an injectable function: \" + fn);\n        if (fn && fn.$inject)\n            return fn.$inject;\n        if (index_1.isArray(fn))\n            return fn.slice(0, -1);\n        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n        return result || [];\n    }\n};\n//# sourceMappingURL=injector.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla/injector.js\n// module id = 52\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar predicates_1 = require(\"../common/predicates\");\nvar common_1 = require(\"../common/common\");\n/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\nvar MemoryLocationConfig = (function () {\n    function MemoryLocationConfig() {\n        var _this = this;\n        this._baseHref = '';\n        this._port = 80;\n        this._protocol = \"http\";\n        this._host = \"localhost\";\n        this._hashPrefix = \"\";\n        this.port = function () { return _this._port; };\n        this.protocol = function () { return _this._protocol; };\n        this.host = function () { return _this._host; };\n        this.baseHref = function () { return _this._baseHref; };\n        this.html5Mode = function () { return false; };\n        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n        this.dispose = common_1.noop;\n    }\n    return MemoryLocationConfig;\n}());\nexports.MemoryLocationConfig = MemoryLocationConfig;\n//# sourceMappingURL=memoryLocationConfig.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla/memoryLocationConfig.js\n// module id = 53\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/** A `LocationServices` that gets/sets the current location from an in-memory object */\nvar MemoryLocationService = (function (_super) {\n    __extends(MemoryLocationService, _super);\n    function MemoryLocationService(router) {\n        return _super.call(this, router, true) || this;\n    }\n    MemoryLocationService.prototype._get = function () {\n        return this._url;\n    };\n    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n        this._url = url;\n    };\n    return MemoryLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.MemoryLocationService = MemoryLocationService;\n//# sourceMappingURL=memoryLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla/memoryLocationService.js\n// module id = 54\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"./utils\");\nvar baseLocationService_1 = require(\"./baseLocationService\");\n/**\n * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n *\n * Uses `history.pushState` and `history.replaceState`\n */\nvar PushStateLocationService = (function (_super) {\n    __extends(PushStateLocationService, _super);\n    function PushStateLocationService(router) {\n        var _this = _super.call(this, router, true) || this;\n        _this._config = router.urlService.config;\n        window.addEventListener(\"popstate\", _this._listener, false);\n        return _this;\n    }\n    ;\n    PushStateLocationService.prototype._get = function () {\n        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n        search = utils_1.splitQuery(search)[1]; // strip ? if found\n        hash = utils_1.splitHash(hash)[1]; // strip # if found\n        return pathname + (search ? \"?\" + search : \"\") + (hash ? \"$\" + search : \"\");\n    };\n    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n        var _a = this, _config = _a._config, _history = _a._history;\n        var fullUrl = _config.baseHref() + url;\n        if (replace) {\n            _history.replaceState(state, title, fullUrl);\n        }\n        else {\n            _history.pushState(state, title, fullUrl);\n        }\n    };\n    PushStateLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        window.removeEventListener(\"popstate\", this._listener);\n    };\n    return PushStateLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.PushStateLocationService = PushStateLocationService;\n//# sourceMappingURL=pushStateLocationService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla/pushStateLocationService.js\n// module id = 55\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = require(\"../common/index\");\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\nexports.$q = {\n    /** Normalizes a value as a promise */\n    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n    /** Normalizes a value as a promise rejection */\n    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n    /** @returns a deferred object, which has `resolve` and `reject` functions */\n    defer: function () {\n        var deferred = {};\n        deferred.promise = new Promise(function (resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n    /** Like Promise.all(), but also supports object key/promise notation like $q */\n    all: function (promises) {\n        if (index_1.isArray(promises)) {\n            return Promise.all(promises);\n        }\n        if (index_1.isObject(promises)) {\n            // Convert promises map to promises array.\n            // When each promise resolves, map it to a tuple { key: key, val: val }\n            var chain = Object.keys(promises)\n                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n            // Then wait for all promises to resolve, and convert them back to an object\n            return exports.$q.all(chain).then(function (values) {\n                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n            });\n        }\n    }\n};\n//# sourceMappingURL=q.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla/q.js\n// module id = 56\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module view\n */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar hof_1 = require(\"../common/hof\");\nvar predicates_1 = require(\"../common/predicates\");\nvar trace_1 = require(\"../common/trace\");\n/**\n * The View service\n *\n * This service pairs existing `ui-view` components (which live in the DOM)\n * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n *\n * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n *   The views from exited states are deactivated via [[deactivateViewConfig]].\n *   (See: the [[registerActivateViews]] Transition Hook)\n *\n * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n *\n * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n * are configured with the matching [[ViewConfig]](s)\n *\n */\nvar ViewService = (function () {\n    function ViewService() {\n        var _this = this;\n        this._uiViews = [];\n        this._viewConfigs = [];\n        this._viewConfigFactories = {};\n        this._pluginapi = {\n            _rootViewContext: this._rootViewContext.bind(this),\n            _viewConfigFactory: this._viewConfigFactory.bind(this),\n            _registeredUIViews: function () { return _this._uiViews; },\n            _activeViewConfigs: function () { return _this._viewConfigs; },\n        };\n    }\n    ViewService.prototype._rootViewContext = function (context) {\n        return this._rootContext = context || this._rootContext;\n    };\n    ;\n    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n        this._viewConfigFactories[viewType] = factory;\n    };\n    ViewService.prototype.createViewConfig = function (path, decl) {\n        var cfgFactory = this._viewConfigFactories[decl.$type];\n        if (!cfgFactory)\n            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n        var cfgs = cfgFactory(path, decl);\n        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n    };\n    /**\n     * Deactivates a ViewConfig.\n     *\n     * This function deactivates a `ViewConfig`.\n     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n     *\n     * @param viewConfig The ViewConfig view to deregister.\n     */\n    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n        common_1.removeFrom(this._viewConfigs, viewConfig);\n    };\n    ViewService.prototype.activateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n        this._viewConfigs.push(viewConfig);\n    };\n    ViewService.prototype.sync = function () {\n        var _this = this;\n        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n        // Return a weighted depth value for a uiView.\n        // The depth is the nesting depth of ui-views (based on FQN; times 10,000)\n        // plus the depth of the state that is populating the uiView\n        function uiViewDepth(uiView) {\n            var stateDepth = function (context) {\n                return context && context.parent ? stateDepth(context.parent) + 1 : 1;\n            };\n            return (uiView.fqn.split(\".\").length * 10000) + stateDepth(uiView.creationContext);\n        }\n        // Return the ViewConfig's context's depth in the context tree.\n        function viewConfigDepth(config) {\n            var context = config.viewDecl.$context, count = 0;\n            while (++count && context.parent)\n                context = context.parent;\n            return count;\n        }\n        // Given a depth function, returns a compare function which can return either ascending or descending order\n        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n        var matchingConfigPair = function (uiView) {\n            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n            if (matchingConfigs.length > 1) {\n                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n                // Sort by depth and return the match from the deepest child\n                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n            }\n            return [uiView, matchingConfigs[0]];\n        };\n        var configureUIView = function (_a) {\n            var uiView = _a[0], viewConfig = _a[1];\n            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n            // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n            if (_this._uiViews.indexOf(uiView) !== -1)\n                uiView.configUpdated(viewConfig);\n        };\n        // Sort views by FQN and state depth. Process uiviews nearest the root first.\n        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);\n    };\n    ;\n    /**\n     * Registers a `ui-view` component\n     *\n     * When a `ui-view` component is created, it uses this method to register itself.\n     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n     *\n     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n     * and what the view's state context is.\n     *\n     * Note: There is no corresponding `deregisterUIView`.\n     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n     *\n     * @param uiView The metadata for a UIView\n     * @return a de-registration function used when the view is destroyed.\n     */\n    ViewService.prototype.registerUIView = function (uiView) {\n        trace_1.trace.traceViewServiceUIViewEvent(\"-> Registering\", uiView);\n        var uiViews = this._uiViews;\n        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n        if (uiViews.filter(fqnMatches).length)\n            trace_1.trace.traceViewServiceUIViewEvent(\"!!!! duplicate uiView named:\", uiView);\n        uiViews.push(uiView);\n        this.sync();\n        return function () {\n            var idx = uiViews.indexOf(uiView);\n            if (idx === -1) {\n                trace_1.trace.traceViewServiceUIViewEvent(\"Tried removing non-registered uiView\", uiView);\n                return;\n            }\n            trace_1.trace.traceViewServiceUIViewEvent(\"<- Deregistering\", uiView);\n            common_1.removeFrom(uiViews)(uiView);\n        };\n    };\n    ;\n    /**\n     * Returns the list of views currently available on the page, by fully-qualified name.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.available = function () {\n        return this._uiViews.map(hof_1.prop(\"fqn\"));\n    };\n    /**\n     * Returns the list of views on the page containing loaded content.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.active = function () {\n        return this._uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n    };\n    /**\n     * Normalizes a view's name from a state.views configuration block.\n     *\n     * This should be used by a framework implementation to calculate the values for\n     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n     *\n     * @param context the context object (state declaration) that the view belongs to\n     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n     *\n     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n     */\n    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n        if (rawViewName === void 0) { rawViewName = \"\"; }\n        // TODO: Validate incoming view name with a regexp to allow:\n        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n        var viewAtContext = rawViewName.split(\"@\");\n        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n        // Handle relative view-name sugar syntax.\n        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n        if (relativeViewNameSugar) {\n            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n        }\n        if (uiViewName.charAt(0) === '!') {\n            uiViewName = uiViewName.substr(1);\n            uiViewContextAnchor = \"\"; // target absolutely from root\n        }\n        // handle parent relative targeting \"^.^.^\"\n        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n        if (relativeMatch.exec(uiViewContextAnchor)) {\n            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n            uiViewContextAnchor = anchor.name;\n        }\n        else if (uiViewContextAnchor === '.') {\n            uiViewContextAnchor = context.name;\n        }\n        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n    };\n    return ViewService;\n}());\n/**\n * Given a ui-view and a ViewConfig, determines if they \"match\".\n *\n * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n *\n * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n *\n * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n *\n * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n * - the ui-view's name matches the ViewConfig's target name\n * - the ui-view's context matches the ViewConfig's anchor\n *\n * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n * - There exists a parent ui-view where:\n *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n *    - the parent ui-view's context matches the ViewConfig's anchor\n * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n *\n * Example:\n *\n * DOM:\n * <ui-view>                        <!-- created in the root context (name: \"\") -->\n *   <ui-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n *     <ui-view>                    <!-- created in the context named: \"A.B\"    -->\n *       <ui-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n *       </ui-view>\n *     </ui-view>\n *   </ui-view>\n * </ui-view>\n *\n * uiViews: [\n *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n * ]\n *\n * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n *\n * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n *\n * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n *   the tail of the ui-view's fqn \"default.bar\"\n *\n * @internalapi\n */\nViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n    if (uiView.$type !== viewConfig.viewDecl.$type)\n        return false;\n    // Split names apart from both viewConfig and uiView into segments\n    var vc = viewConfig.viewDecl;\n    var vcSegments = vc.$uiViewName.split(\".\");\n    var uivSegments = uiView.fqn.split(\".\");\n    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n        return false;\n    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n    var negOffset = (1 - vcSegments.length) || undefined;\n    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n}; };\nexports.ViewService = ViewService;\n//# sourceMappingURL=view.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/view/view.js\n// module id = 57\n// module chunks = 0","\"use strict\";\n/**\n * Main entry point for angular 1.x build\n * @module ng1\n */ /** */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./services\"));\n__export(require(\"./statebuilders/views\"));\n__export(require(\"./stateProvider\"));\n__export(require(\"./urlRouterProvider\"));\nrequire(\"./injectables\");\nrequire(\"./directives/stateDirectives\");\nrequire(\"./stateFilters\");\nrequire(\"./directives/viewDirective\");\nrequire(\"./viewScroll\");\nexports.default = \"ui.router\";\nvar core = require(\"@uirouter/core\");\nexports.core = core;\n__export(require(\"@uirouter/core\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/index.js\n// module id = 58\n// module chunks = 0","const $inject = ['$stateProvider', '$urlRouterProvider'];\nclass RouterHelperProvider {\n  constructor(...injects) {\n    RouterHelperProvider.$inject.forEach((item, index) => this[item] = injects[index]);\n    this.config = {\n      defaultRoute: '/',\n      docTitle: undefined,\n      resolveAlways: {}\n    };\n\n    this.configure = cfg => Object.assign(this.config, cfg);\n  }\n\n  $get($location, $rootScope, $state, logger) {\n    'ngInject';\n    let $stateProvider = this.$stateProvider;\n    let $urlRouterProvider = this.$urlRouterProvider;\n    let config = this.config;\n    let handlingStateChangeError = false;\n    let hasOtherwise = false;\n    let stateCounts = {\n      errors: 0,\n      changes: 0\n    };\n\n    _init();\n\n    return {\n      stateCounts: stateCounts,\n      configureStates: configureStates,\n      getStates: getStates\n    };\n\n    /* isparta ignore next  */\n    function _init() {\n      _handleRoutingErrors();\n      _updateDocTitle();\n    }\n\n    /* isparta ignore next  */\n    function _handleRoutingErrors() {\n      // Route cancellation:\n      // On routing error, go to the specific page.\n      $rootScope.$on('$stateChangeError', (event, toState, toParams, fromState, fromParams, error) => {\n        if (handlingStateChangeError) {\n          return;\n        }\n        stateCounts.errors++;\n        handlingStateChangeError = true;\n        let destination = (toState &&\n          (toState.title || toState.name || toState.loadedTemplateUrl)) ||\n          'unknown target';\n        let msg = `Error routing to ${destination}. ${error}`;\n        logger.error(msg, [toState]);\n        $location.path(config.defaultRoute);\n      });\n    }\n\n    /* isparta ignore next  */\n    function _updateDocTitle() {\n      $rootScope.$on('$stateChangeSuccess', (event, toState) => {\n        stateCounts.changes++;\n        handlingStateChangeError = false;\n        let title = config.docTitle + ' ' + (toState.title || '');\n        $rootScope.title = title; // data bind to <title>\n      });\n    }\n\n    function configureStates(states, otherwisePath) {\n      states.forEach(state => {\n        state.config.resolve =\n          Object.assign(state.config.resolve || {}, config.resolveAlways);\n        $stateProvider.state(state.state, state.config);\n      });\n      /* istanbul ignore if  */\n      if (otherwisePath && !hasOtherwise) {\n        hasOtherwise = true;\n        $urlRouterProvider.otherwise(otherwisePath);\n      }\n    }\n\n    function getStates() {\n      return $state.get();\n    }\n  }\n}\nRouterHelperProvider.$inject = $inject;\n\nexport default RouterHelperProvider;\n\n\n\n// WEBPACK FOOTER //\n// ./component/router-helper.js","module.exports = __WEBPACK_EXTERNAL_MODULE_60__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"sjLogger\",\"commonjs2\":\"sanji-logger-ui\",\"commonjs\":\"sanji-logger-ui\",\"amd\":\"sanji-logger-ui\"}\n// module id = 60\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Angular 1 Directives\n *\n * These are the directives included in UI-Router for Angular 1.\n * These directives are used in templates to create viewports and link/navigate to states.\n *\n * @ng1api\n * @preferred\n * @module directives\n */ /** for typedoc */\nvar angular_1 = require(\"../angular\");\nvar core_1 = require(\"@uirouter/core\");\n/** @hidden */\nfunction parseStateRef(ref) {\n    var paramsOnly = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n    if (paramsOnly)\n        ref = '(' + paramsOnly[1] + ')';\n    parsed = ref.replace(/\\n/g, \" \").match(/^\\s*([^(]*?)\\s*(\\((.*)\\))?\\s*$/);\n    if (!parsed || parsed.length !== 4)\n        throw new Error(\"Invalid state ref '\" + ref + \"'\");\n    return { state: parsed[1] || null, paramExpr: parsed[3] || null };\n}\n/** @hidden */\nfunction stateContext(el) {\n    var $uiView = el.parent().inheritedData('$uiView');\n    var path = core_1.parse('$cfg.path')($uiView);\n    return path ? core_1.tail(path).state.name : undefined;\n}\n/** @hidden */\nfunction processedDef($state, $element, def) {\n    var uiState = def.uiState || $state.current.name;\n    var uiStateOpts = core_1.extend(defaultOpts($element, $state), def.uiStateOpts || {});\n    var href = $state.href(uiState, def.uiStateParams, uiStateOpts);\n    return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };\n}\n/** @hidden */\nfunction getTypeInfo(el) {\n    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n    var isForm = el[0].nodeName === \"FORM\";\n    return {\n        attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n        isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n        clickable: !isForm\n    };\n}\n/** @hidden */\nfunction clickHook(el, $state, $timeout, type, getDef) {\n    return function (e) {\n        var button = e.which || e.button, target = getDef();\n        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n            var transition = $timeout(function () {\n                $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);\n            });\n            e.preventDefault();\n            // if the state has no URL, ignore one preventDefault from the <a> directive.\n            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;\n            e.preventDefault = function () {\n                if (ignorePreventDefaultCount-- <= 0)\n                    $timeout.cancel(transition);\n            };\n        }\n    };\n}\n/** @hidden */\nfunction defaultOpts(el, $state) {\n    return {\n        relative: stateContext(el) || $state.$current,\n        inherit: true,\n        source: \"sref\"\n    };\n}\n/** @hidden */\nfunction bindEvents(element, scope, hookFn, uiStateOpts) {\n    var events;\n    if (uiStateOpts) {\n        events = uiStateOpts.events;\n    }\n    if (!core_1.isArray(events)) {\n        events = ['click'];\n    }\n    var on = element.on ? 'on' : 'bind';\n    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n        var event_1 = events_1[_i];\n        element[on](event_1, hookFn);\n    }\n    scope.$on('$destroy', function () {\n        var off = element.off ? 'off' : 'unbind';\n        for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n            var event_2 = events_2[_i];\n            element[off](event_2, hookFn);\n        }\n    });\n}\n/**\n * `ui-sref`: A directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of the `ui-sref` is the name of the state to link to.\n *\n * #### Example:\n * This will activate the `home` state when the link is clicked.\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * ```\n *\n * ### Relative Links\n * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create a relative `ui-sref` which always targets the same destination.\n *\n * #### Example:\n * Both these links are relative to the parent state, even when a child state is currently active.\n * ```html\n * <a ui-sref=\".child1\">child 1 state</a>\n * <a ui-sref=\".child2\">child 2 state</a>\n * ```\n *\n * This link activates the parent state.\n * ```html\n * <a ui-sref=\"^\">Return</a>\n * ```\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * #### Example:\n * Assuming the `users` state has a url of `/users/`\n * ```html\n * <a ui-sref=\"users\" href=\"/users/\">Users</a>\n * ```\n *\n * ### Parameter Values\n * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.\n * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.\n * The content inside the parentheses is an expression, evaluated to the parameter values.\n *\n * #### Example:\n * This example renders a list of links to users.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"user in users\">\n *   <a ui-sref=\"users.detail({ userId: user.id })\">{{ user.displayName }}</a>\n * </li>\n * ```\n *\n * Note:\n * The parameter values expression is `$watch`ed for updates.\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n *\n * #### Example:\n * ```html\n * <a ui-sref=\"home\" ui-sref-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-sref-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-sref=\"contacts\" ui-sref-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Examples\n * If you have the following template:\n *\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * <a ui-sref=\"about\">About</a>\n * <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * ```\n *\n * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:\n *\n * ```html\n * <a href=\"#/home\" ui-sref=\"home\">Home</a>\n * <a href=\"#/about\" ui-sref=\"about\">About</a>\n * <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a href=\"#/home\" ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * ```\n *\n * ### Notes\n *\n * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-sref=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n *\n * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).\n * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.\n */\nvar uiSref;\nuiSref = ['$uiRouter', '$timeout',\n    function $StateRefDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var ref = parseStateRef(attrs.uiSref);\n                rawDef.uiState = ref.state;\n                rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                if (ref.paramExpr) {\n                    scope.$watch(ref.paramExpr, function (val) {\n                        rawDef.uiStateParams = core_1.extend({}, val);\n                        update();\n                    }, true);\n                    rawDef.uiStateParams = core_1.extend({}, scope.$eval(ref.paramExpr));\n                }\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            }\n        };\n    }];\n/**\n * `ui-state`: A fully dynamic directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.\n * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**\n *\n * #### Example:\n * Create a list of links.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Relative Links\n * If the expression evaluates to a relative path, it is processed like [[uiSref]].\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create relative `ui-state` which always targets the same destination.\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * ### Parameter Values\n * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.\n * Param values should be provided using the `ui-state-params` attribute.\n * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * This example renders a list of links with param values.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\" ui-state-params=\"link.params\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * ```html\n * <a ui-state=\"returnto.state\" ui-state-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-state-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-state=\"contacts\" ui-state-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Notes\n *\n * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.\n *   However, it might be simpler to use [[uiSref]] parameter-only links.\n *\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-state=\"\" ui-state-params=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n * ```\n */\nvar uiState;\nuiState = ['$uiRouter', '$timeout',\n    function $StateRefDynamicDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];\n                var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return (acc[attr] = core_1.noop, acc); }, {});\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                inputAttrs.forEach(function (field) {\n                    rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;\n                    attrs.$observe(field, function (expr) {\n                        watchDeregFns[field]();\n                        watchDeregFns[field] = scope.$watch(expr, function (newval) {\n                            rawDef[field] = newval;\n                            update();\n                        }, true);\n                    });\n                });\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            }\n        };\n    }];\n/**\n * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active\n *\n * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the\n * related directive's state is active (and remove them when it is inactive).\n *\n * The primary use-case is to highlight the active link in navigation menus,\n * distinguishing it from the inactive menu items.\n *\n * ### Linking to a `ui-sref` or `ui-state`\n * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.\n * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.\n *\n * ### Matching\n *\n * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.\n * This is a \"fuzzy match\" which uses [[StateService.includes]].\n *\n * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).\n * This is an \"exact match\" which uses [[StateService.is]].\n *\n * ### Parameter values\n * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.\n * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.\n *\n * #### Example:\n * ```html\n * <li ng-repeat=\"user in users\" ui-sref-active=\"active\">\n *   <a ui-sref=\"user.details({ userId: user.id })\">{{ user.lastName }}</a>\n * </li>\n * ```\n *\n * ### Examples\n *\n * Given the following template:\n * #### Example:\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * When the app state is `app.user` (or any child state),\n * and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n *\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * ### Glob mode\n *\n * It is possible to pass `ui-sref-active` an expression that evaluates to an object.\n * The objects keys represent active class names and values represent the respective state names/globs.\n * `ui-sref-active` will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * #### Example:\n * Given the following template, with \"admin\" being an abstract state:\n * ```html\n * <div ui-sref-active=\"{'active': 'admin.**'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * ```\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied to both the <div> and <a> elements.\n * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.\n *\n * ### Notes:\n *\n * - The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`\n */\nvar uiSrefActive;\nuiSrefActive = ['$state', '$stateParams', '$interpolate', '$uiRouter',\n    function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {\n        return {\n            restrict: \"A\",\n            controller: ['$scope', '$element', '$attrs',\n                function ($scope, $element, $attrs) {\n                    var states = [], activeEqClass, uiSrefActive;\n                    // There probably isn't much point in $observing this\n                    // uiSrefActive and uiSrefActiveEq share the same directive object with some\n                    // slight difference in logic routing\n                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n                    try {\n                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n                    }\n                    catch (e) {\n                        // Do nothing. uiSrefActive is not a valid expression.\n                        // Fall back to using $interpolate below\n                    }\n                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n                    if (core_1.isObject(uiSrefActive)) {\n                        core_1.forEach(uiSrefActive, function (stateOrName, activeClass) {\n                            if (core_1.isString(stateOrName)) {\n                                var ref = parseStateRef(stateOrName);\n                                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n                            }\n                        });\n                    }\n                    // Allow uiSref to communicate with uiSrefActive[Equals]\n                    this.$$addStateInfo = function (newState, newParams) {\n                        // we already got an explicit state provided by ui-sref-active, so we\n                        // shadow the one that comes from ui-sref\n                        if (core_1.isObject(uiSrefActive) && states.length > 0) {\n                            return;\n                        }\n                        var deregister = addState(newState, newParams, uiSrefActive);\n                        update();\n                        return deregister;\n                    };\n                    function updateAfterTransition(trans) {\n                        trans.promise.then(update, core_1.noop);\n                    }\n                    $scope.$on('$stateChangeSuccess', update);\n                    $scope.$on('$destroy', $uiRouter.transitionService.onStart({}, updateAfterTransition));\n                    if ($uiRouter.globals.transition) {\n                        updateAfterTransition($uiRouter.globals.transition);\n                    }\n                    function addState(stateName, stateParams, activeClass) {\n                        var state = $state.get(stateName, stateContext($element));\n                        var stateInfo = {\n                            state: state || { name: stateName },\n                            params: stateParams,\n                            activeClass: activeClass\n                        };\n                        states.push(stateInfo);\n                        return function removeState() {\n                            core_1.removeFrom(states)(stateInfo);\n                        };\n                    }\n                    // Update route state\n                    function update() {\n                        var splitClasses = function (str) {\n                            return str.split(/\\s/).filter(core_1.identity);\n                        };\n                        var getClasses = function (stateList) {\n                            return stateList.map(function (x) { return x.activeClass; }).map(splitClasses).reduce(core_1.unnestR, []);\n                        };\n                        var allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(core_1.uniqR, []);\n                        var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));\n                        var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;\n                        var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];\n                        var addClasses = fuzzyClasses.concat(exactClasses).reduce(core_1.uniqR, []);\n                        var removeClasses = allClasses.filter(function (cls) { return !core_1.inArray(addClasses, cls); });\n                        $scope.$evalAsync(function () {\n                            addClasses.forEach(function (className) { return $element.addClass(className); });\n                            removeClasses.forEach(function (className) { return $element.removeClass(className); });\n                        });\n                    }\n                    update();\n                }]\n        };\n    }];\nangular_1.ng.module('ui.router.state')\n    .directive('uiSref', uiSref)\n    .directive('uiSrefActive', uiSrefActive)\n    .directive('uiSrefActiveEq', uiSrefActive)\n    .directive('uiState', uiState);\n//# sourceMappingURL=stateDirectives.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/directives/stateDirectives.js\n// module id = 61\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @ng1api\n * @module directives\n */ /** for typedoc */\nvar angular_1 = require(\"../angular\");\nvar angular_2 = require(\"angular\");\nvar core_1 = require(\"@uirouter/core\");\nvar views_1 = require(\"../statebuilders/views\");\nvar services_1 = require(\"../services\");\nexports.uiView = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q',\n    function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {\n        function getRenderer(attrs, scope) {\n            return {\n                enter: function (element, target, cb) {\n                    if (angular_1.ng.version.minor > 2) {\n                        $animate.enter(element, null, target).then(cb);\n                    }\n                    else {\n                        $animate.enter(element, null, target, cb);\n                    }\n                },\n                leave: function (element, cb) {\n                    if (angular_1.ng.version.minor > 2) {\n                        $animate.leave(element).then(cb);\n                    }\n                    else {\n                        $animate.leave(element, cb);\n                    }\n                }\n            };\n        }\n        function configsEqual(config1, config2) {\n            return config1 === config2;\n        }\n        var rootData = {\n            $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },\n            $uiView: {}\n        };\n        var directive = {\n            count: 0,\n            restrict: 'ECA',\n            terminal: true,\n            priority: 400,\n            transclude: 'element',\n            compile: function (tElement, tAttrs, $transclude) {\n                return function (scope, $element, attrs) {\n                    var previousEl, currentEl, currentScope, unregister, onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(attrs, scope), viewConfig = undefined, inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';\n                    var activeUIView = {\n                        $type: 'ng1',\n                        id: directive.count++,\n                        name: name,\n                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + \".\" + name : name,\n                        config: null,\n                        configUpdated: configUpdatedCallback,\n                        get creationContext() {\n                            var fromParentTagConfig = core_1.parse('$cfg.viewDecl.$context')(inherited);\n                            // Allow <ui-view name=\"foo\"><ui-view name=\"bar\"></ui-view></ui-view>\n                            // See https://github.com/angular-ui/ui-router/issues/3355\n                            var fromParentTag = core_1.parse('$uiView.creationContext')(inherited);\n                            return fromParentTagConfig || fromParentTag;\n                        }\n                    };\n                    core_1.trace.traceUIViewEvent(\"Linking\", activeUIView);\n                    function configUpdatedCallback(config) {\n                        if (config && !(config instanceof views_1.Ng1ViewConfig))\n                            return;\n                        if (configsEqual(viewConfig, config))\n                            return;\n                        core_1.trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n                        viewConfig = config;\n                        updateView(config);\n                    }\n                    $element.data('$uiView', { $uiView: activeUIView });\n                    updateView();\n                    unregister = $view.registerUIView(activeUIView);\n                    scope.$on(\"$destroy\", function () {\n                        core_1.trace.traceUIViewEvent(\"Destroying/Unregistering\", activeUIView);\n                        unregister();\n                    });\n                    function cleanupLastView() {\n                        if (previousEl) {\n                            core_1.trace.traceUIViewEvent(\"Removing (previous) el\", previousEl.data('$uiView'));\n                            previousEl.remove();\n                            previousEl = null;\n                        }\n                        if (currentScope) {\n                            core_1.trace.traceUIViewEvent(\"Destroying scope\", activeUIView);\n                            currentScope.$destroy();\n                            currentScope = null;\n                        }\n                        if (currentEl) {\n                            var _viewData_1 = currentEl.data('$uiViewAnim');\n                            core_1.trace.traceUIViewEvent(\"Animate out\", _viewData_1);\n                            renderer.leave(currentEl, function () {\n                                _viewData_1.$$animLeave.resolve();\n                                previousEl = null;\n                            });\n                            previousEl = currentEl;\n                            currentEl = null;\n                        }\n                    }\n                    function updateView(config) {\n                        var newScope = scope.$new();\n                        var animEnter = $q.defer(), animLeave = $q.defer();\n                        var $uiViewData = {\n                            $cfg: config,\n                            $uiView: activeUIView,\n                        };\n                        var $uiViewAnim = {\n                            $animEnter: animEnter.promise,\n                            $animLeave: animLeave.promise,\n                            $$animLeave: animLeave\n                        };\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoading\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description\n                         *\n                         * Fired once the view **begins loading**, *before* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         * @param {string} viewName Name of the view.\n                         */\n                        newScope.$emit('$viewContentLoading', name);\n                        var cloned = $transclude(newScope, function (clone) {\n                            clone.data('$uiViewAnim', $uiViewAnim);\n                            clone.data('$uiView', $uiViewData);\n                            renderer.enter(clone, $element, function onUIViewEnter() {\n                                animEnter.resolve();\n                                if (currentScope)\n                                    currentScope.$emit('$viewContentAnimationEnded');\n                                if (core_1.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                                    $uiViewScroll(clone);\n                                }\n                            });\n                            cleanupLastView();\n                        });\n                        currentEl = cloned;\n                        currentScope = newScope;\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoaded\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description           *\n                         * Fired once the view is **loaded**, *after* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         */\n                        currentScope.$emit('$viewContentLoaded', config || viewConfig);\n                        currentScope.$eval(onloadExp);\n                    }\n                };\n            }\n        };\n        return directive;\n    }];\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];\n/** @hidden */\nfunction $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {\n    var getControllerAs = core_1.parse('viewDecl.controllerAs');\n    var getResolveAs = core_1.parse('viewDecl.resolveAs');\n    return {\n        restrict: 'ECA',\n        priority: -400,\n        compile: function (tElement) {\n            var initial = tElement.html();\n            tElement.empty();\n            return function (scope, $element) {\n                var data = $element.data('$uiView');\n                if (!data) {\n                    $element.html(initial);\n                    $compile($element.contents())(scope);\n                    return;\n                }\n                var cfg = data.$cfg || { viewDecl: {}, getTemplate: angular_2.noop };\n                var resolveCtx = cfg.path && new core_1.ResolveContext(cfg.path);\n                $element.html(cfg.getTemplate($element, resolveCtx) || initial);\n                core_1.trace.traceUIViewFill(data.$uiView, $element.html());\n                var link = $compile($element.contents());\n                var controller = cfg.controller;\n                var controllerAs = getControllerAs(cfg);\n                var resolveAs = getResolveAs(cfg);\n                var locals = resolveCtx && services_1.getLocals(resolveCtx);\n                scope[resolveAs] = locals;\n                if (controller) {\n                    var controllerInstance = $controller(controller, core_1.extend({}, locals, { $scope: scope, $element: $element }));\n                    if (controllerAs) {\n                        scope[controllerAs] = controllerInstance;\n                        scope[controllerAs][resolveAs] = locals;\n                    }\n                    // TODO: Use $view service as a central point for registering component-level hooks\n                    // Then, when a component is created, tell the $view service, so it can invoke hooks\n                    // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n                    // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n                    $element.data('$ngControllerController', controllerInstance);\n                    $element.children().data('$ngControllerController', controllerInstance);\n                    registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);\n                }\n                // Wait for the component to appear in the DOM\n                if (core_1.isString(cfg.viewDecl.component)) {\n                    var cmp_1 = cfg.viewDecl.component;\n                    var kebobName = core_1.kebobString(cmp_1);\n                    var tagRegexp_1 = new RegExp(\"^(x-|data-)?\" + kebobName + \"$\", \"i\");\n                    var getComponentController = function () {\n                        var directiveEl = [].slice.call($element[0].children)\n                            .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });\n                        return directiveEl && angular_1.ng.element(directiveEl).data(\"$\" + cmp_1 + \"Controller\");\n                    };\n                    var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {\n                        if (!ctrlInstance)\n                            return;\n                        registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);\n                        deregisterWatch_1();\n                    });\n                }\n                link(scope);\n            };\n        }\n    };\n}\n/** @hidden */\nvar hasComponentImpl = typeof angular_1.ng.module('ui.router')['component'] === 'function';\n/** @hidden incrementing id */\nvar _uiCanExitId = 0;\n/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\nfunction registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {\n    // Call $onInit() ASAP\n    if (core_1.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {\n        controllerInstance.$onInit();\n    }\n    var viewState = core_1.tail(cfg.path).state.self;\n    var hookOptions = { bind: controllerInstance };\n    // Add component-level hook for onParamsChange\n    if (core_1.isFunction(controllerInstance.uiOnParamsChanged)) {\n        var resolveContext = new core_1.ResolveContext(cfg.path);\n        var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;\n        // Fire callback on any successful transition\n        var paramsUpdated = function ($transition$) {\n            // Exit early if the $transition$ is the same as the view was created within.\n            // Exit early if the $transition$ will exit the state the view is for.\n            if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)\n                return;\n            var toParams = $transition$.params(\"to\");\n            var fromParams = $transition$.params(\"from\");\n            var toSchema = $transition$.treeChanges().to.map(function (node) { return node.paramSchema; }).reduce(core_1.unnestR, []);\n            var fromSchema = $transition$.treeChanges().from.map(function (node) { return node.paramSchema; }).reduce(core_1.unnestR, []);\n            // Find the to params that have different values than the from params\n            var changedToParams = toSchema.filter(function (param) {\n                var idx = fromSchema.indexOf(param);\n                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n            });\n            // Only trigger callback if a to param has changed or is new\n            if (changedToParams.length) {\n                var changedKeys_1 = changedToParams.map(function (x) { return x.id; });\n                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n                var newValues = core_1.filter(toParams, function (val, key) { return changedKeys_1.indexOf(key) !== -1; });\n                controllerInstance.uiOnParamsChanged(newValues, $transition$);\n            }\n        };\n        $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));\n    }\n    // Add component-level hook for uiCanExit\n    if (core_1.isFunction(controllerInstance.uiCanExit)) {\n        var id_1 = _uiCanExitId++;\n        var cacheProp_1 = '_uiCanExitIds';\n        // Returns true if a redirect transition already answered truthy\n        var prevTruthyAnswer_1 = function (trans) {\n            return !!trans && (trans[cacheProp_1] && trans[cacheProp_1][id_1] === true || prevTruthyAnswer_1(trans.redirectedFrom()));\n        };\n        // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n        var wrappedHook = function (trans) {\n            var promise, ids = trans[cacheProp_1] = trans[cacheProp_1] || {};\n            if (!prevTruthyAnswer_1(trans)) {\n                promise = $q.when(controllerInstance.uiCanExit(trans));\n                promise.then(function (val) { return ids[id_1] = (val !== false); });\n            }\n            return promise;\n        };\n        var criteria = { exiting: viewState.name };\n        $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));\n    }\n}\nangular_1.ng.module('ui.router.state').directive('uiView', exports.uiView);\nangular_1.ng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n//# sourceMappingURL=viewDirective.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/directives/viewDirective.js\n// module id = 62\n// module chunks = 0","\"use strict\";\n/**\n * # Angular 1 injectable services\n *\n * This is a list of the objects which can be injected using angular's injector.\n *\n * There are three different kind of injectable objects:\n *\n * ## **Provider** objects\n * #### injectable into a `.config()` block during configtime\n *\n * - [[$uiRouterProvider]]: The UI-Router instance\n * - [[$stateProvider]]: State registration\n * - [[$transitionsProvider]]: Transition hooks\n * - [[$urlServiceProvider]]: All URL related public APIs\n *\n * - [[$uiViewScrollProvider]]: Disable ui-router view scrolling\n * - [[$urlRouterProvider]]: (deprecated) Url matching rules\n * - [[$urlMatcherFactoryProvider]]: (deprecated) Url parsing config\n *\n * ## **Service** objects\n * #### injectable globally during runtime\n *\n * - [[$uiRouter]]: The UI-Router instance\n * - [[$trace]]: Enable transition trace/debug\n * - [[$transitions]]: Transition hooks\n * - [[$state]]: Imperative state related APIs\n * - [[$stateRegistry]]: State registration\n * - [[$urlService]]: All URL related public APIs\n * - [[$uiRouterGlobals]]: Global variables\n * - [[$uiViewScroll]]: Scroll an element into view\n *\n * - [[$stateParams]]: (deprecated) Global state param values\n * - [[$urlRouter]]: (deprecated) URL synchronization\n * - [[$urlMatcherFactory]]: (deprecated) URL parsing config\n *\n * ## **Per-Transition** objects\n *\n * - These kind of objects are injectable into:\n *   - Resolves ([[Ng1StateDeclaration.resolve]]),\n *   - Transition Hooks ([[TransitionService.onStart]], etc),\n *   - Routed Controllers ([[Ng1ViewDeclaration.controller]])\n *\n * #### Different instances are injected based on the [[Transition]]\n *\n * - [[$transition$]]: The current Transition object\n * - [[$stateParams]]: State param values for pending Transition (deprecated)\n * - Any resolve data defined using [[Ng1StateDeclaration.resolve]]\n *\n * @ng1api\n * @preferred\n * @module injectables\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The current (or pending) State Parameters\n *\n * An injectable global **Service Object** which holds the state parameters for the latest **SUCCESSFUL** transition.\n *\n * The values are not updated until *after* a `Transition` successfully completes.\n *\n * **Also:** an injectable **Per-Transition Object** object which holds the pending state parameters for the pending `Transition` currently running.\n *\n * ### Deprecation warning:\n *\n * The value injected for `$stateParams` is different depending on where it is injected.\n *\n * - When injected into an angular service, the object injected is the global **Service Object** with the parameter values for the latest successful `Transition`.\n * - When injected into transition hooks, resolves, or view controllers, the object is the **Per-Transition Object** with the parameter values for the running `Transition`.\n *\n * Because of these confusing details, this service is deprecated.\n *\n * ### Instead of using the global `$stateParams` service object,\n * inject [[$uiRouterGlobals]] and use [[UIRouterGlobals.params]]\n *\n * ```js\n * MyService.$inject = ['$uiRouterGlobals'];\n * function MyService($uiRouterGlobals) {\n *   return {\n *     paramValues: function () {\n *       return $uiRouterGlobals.params;\n *     }\n *   }\n * }\n * ```\n *\n * ### Instead of using the per-transition `$stateParams` object,\n * inject the current `Transition` (as [[$transition$]]) and use [[Transition.params]]\n *\n * ```js\n * MyController.$inject = ['$transition$'];\n * function MyController($transition$) {\n *   var username = $transition$.params().username;\n *   // .. do something with username\n * }\n * ```\n *\n * ---\n *\n * This object can be injected into other services.\n *\n * #### Deprecated Example:\n * ```js\n * SomeService.$inject = ['$http', '$stateParams'];\n * function SomeService($http, $stateParams) {\n *   return {\n *     getUser: function() {\n *       return $http.get('/api/users/' + $stateParams.username);\n *     }\n *   }\n * };\n * angular.service('SomeService', SomeService);\n * ```\n * @deprecated\n */\nvar $stateParams;\n/**\n * Global UI-Router variables\n *\n * The router global state as a **Service Object** (injectable during runtime).\n *\n * This object contains globals such as the current state and current parameter values.\n */\nvar $uiRouterGlobals;\n/**\n * The UI-Router instance\n *\n * The [[UIRouter]] singleton (the router instance) as a **Service Object** (injectable during runtime).\n *\n * This object is the UI-Router singleton instance, created by angular dependency injection during application bootstrap.\n * It has references to the other UI-Router services\n *\n * #### Note: This object is also exposed as [[$uiRouterProvider]] for injection during angular config time.\n */\nvar $uiRouter;\n/**\n * The UI-Router instance\n *\n * The [[UIRouter]] singleton (the router instance) as a **Provider Object** (injectable during config phase).\n *\n * This object is the UI-Router singleton instance, created by angular dependency injection during application bootstrap.\n * It has references to the other UI-Router services\n *\n * #### Note: This object is also exposed as [[$uiRouter]] for injection during runtime.\n */\nvar $uiRouterProvider;\n/**\n * Transition debug/tracing\n *\n * The [[Trace]] singleton as a **Service Object** (injectable during runtime).\n *\n * Enables or disables Transition tracing which can help to debug issues.\n */\nvar $trace;\n/**\n * The Transition Service\n *\n * The [[TransitionService]] singleton as a **Service Object** (injectable during runtime).\n *\n * This angular service exposes the [[TransitionService]] singleton, which is primarily\n * used to register global transition hooks.\n *\n * #### Note: This object is also exposed as [[$transitionsProvider]] for injection during the config phase.\n */\nvar $transitions;\n/**\n * The Transition Service\n *\n * The [[TransitionService]] singleton as a **Provider Object** (injectable during config phase)\n *\n * This angular service exposes the [[TransitionService]] singleton, which is primarily\n * used to register global transition hooks.\n *\n * #### Note: This object is also exposed as [[$transitions]] for injection during runtime.\n */\nvar $transitionsProvider;\n/**\n * The current [[Transition]] object\n *\n * The current [[Transition]] object as a **Per-Transition Object** (injectable into Resolve, Hooks, Controllers)\n *\n * This object returns information about the current transition, including:\n *\n * - To/from states\n * - To/from parameters\n * - Transition options\n * - States being entered, exited, and retained\n * - Resolve data\n * - A Promise for the transition\n * - Any transition failure information\n * - An injector for both Service and Per-Transition Objects\n */\nvar $transition$;\n/**\n * The State Service\n *\n * The [[StateService]] singleton as a **Service Object** (injectable during runtime).\n *\n * This service used to manage and query information on registered states.\n * It exposes state related APIs including:\n *\n * - Start a [[Transition]]\n * - Imperatively lazy load states\n * - Check if a state is currently active\n * - Look up states by name\n * - Build URLs for a state+parameters\n * - Configure the global Transition error handler\n *\n * This angular service exposes the [[StateService]] singleton.\n */\nvar $state;\n/**\n * The State Registry\n *\n * The [[StateRegistry]] singleton as a **Service Object** (injectable during runtime).\n *\n * This service is used to register/deregister states.\n * It has state registration related APIs including:\n *\n * - Register/deregister states\n * - Listen for state registration/deregistration\n * - Get states by name\n * - Add state decorators (to customize the state creation process)\n *\n * #### Note: This object is also exposed as [[$stateRegistryProvider]] for injection during the config phase.\n */\nvar $stateRegistry;\n/**\n * The State Registry\n *\n * The [[StateRegistry]] singleton as a **Provider Object** (injectable during config time).\n *\n * This service is used to register/deregister states.\n * It has state registration related APIs including:\n *\n * - Register/deregister states\n * - Listen for state registration/deregistration\n * - Get states by name\n * - Add state decorators (to customize the state creation process)\n *\n * #### Note: This object is also exposed as [[$stateRegistry]] for injection during runtime.\n */\nvar $stateRegistryProvider;\n/**\n * The View Scroll provider\n *\n * The [[UIViewScrollProvider]] as a **Provider Object** (injectable during config time).\n *\n * This angular service exposes the [[UIViewScrollProvider]] singleton and is\n * used to disable UI-Router's scroll behavior.\n */\nvar $uiViewScrollProvider;\n/**\n * The View Scroll function\n *\n * The View Scroll function as a **Service Object** (injectable during runtime).\n *\n * This is a function that scrolls an element into view.\n * The element is scrolled after a `$timeout` so the DOM has time to refresh.\n *\n * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n * this can be enabled by calling [[UIViewScrollProvider.useAnchorScroll]].\n *\n * Note: this function is used by the [[directives.uiView]] when the `autoscroll` expression evaluates to true.\n */\nvar $uiViewScroll;\n/**\n * The StateProvider\n *\n * An angular1-only [[StateProvider]] as a **Provider Object** (injectable during config time).\n *\n * This angular service exposes the [[StateProvider]] singleton.\n *\n * The `StateProvider` is primarily used to register states or add custom state decorators.\n *\n * ##### Note: This provider is a ng1 vestige.\n * It is a passthrough to [[$stateRegistry]] and [[$state]].\n */\nvar $stateProvider;\n/**\n * The URL Service Provider\n *\n * The [[UrlService]] singleton as a **Provider Object** (injectable during the angular config phase).\n *\n * A service used to configure and interact with the URL.\n * It has URL related APIs including:\n *\n * - register custom Parameter types `UrlService.config.type` ([[UrlConfigApi.type]])\n * - add URL rules: `UrlService.rules.when` ([[UrlRulesApi.when]])\n * - configure behavior when no url matches: `UrlService.rules.otherwise` ([[UrlRulesApi.otherwise]])\n * - delay initial URL synchronization [[UrlService.deferIntercept]].\n * - get or set the current url: [[UrlService.url]]\n *\n * ##### Note: This service can also be injected during runtime as [[$urlService]].\n */\nvar $urlServiceProvider;\n/**\n * The URL Service\n *\n * The [[UrlService]] singleton as a **Service Object** (injectable during runtime).\n *\n * Note: This service can also be injected during the config phase as [[$urlServiceProvider]].\n *\n * Used to configure the URL.\n * It has URL related APIs including:\n *\n * - register custom Parameter types `UrlService.config.type` ([[UrlConfigApi.type]])\n * - add URL rules: `UrlService.rules.when` ([[UrlRulesApi.when]])\n * - configure behavior when no url matches: `UrlService.rules.otherwise` ([[UrlRulesApi.otherwise]])\n * - delay initial URL synchronization [[UrlService.deferIntercept]].\n * - get or set the current url: [[UrlService.url]]\n *\n * ##### Note: This service can also be injected during the config phase as [[$urlServiceProvider]].\n */\nvar $urlService;\n/**\n * The URL Router Provider\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlServiceProvider]] instead.\n *\n * The [[UrlRouter]] singleton as a **Provider Object** (injectable during config time).\n *\n * #### Note: This object is also exposed as [[$urlRouter]] for injection during runtime.\n *\n * @deprecated\n */\nvar $urlRouterProvider;\n/**\n * The Url Router\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.\n *\n * The [[UrlRouter]] singleton as a **Service Object** (injectable during runtime).\n *\n * #### Note: This object is also exposed as [[$urlRouterProvider]] for injection during angular config time.\n *\n * @deprecated\n */\nvar $urlRouter;\n/**\n * The URL Matcher Factory\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.\n *\n * The [[UrlMatcherFactory]] singleton as a **Service Object** (injectable during runtime).\n *\n * This service is used to set url mapping options, define custom parameter types, and create [[UrlMatcher]] objects.\n *\n * #### Note: This object is also exposed as [[$urlMatcherFactoryProvider]] for injection during angular config time.\n *\n * @deprecated\n */\nvar $urlMatcherFactory;\n/**\n * The URL Matcher Factory\n *\n * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.\n *\n * The [[UrlMatcherFactory]] singleton as a **Provider Object** (injectable during config time).\n *\n * This service is used to set url mapping options, define custom parameter types, and create [[UrlMatcher]] objects.\n *\n * #### Note: This object is also exposed as [[$urlMatcherFactory]] for injection during runtime.\n *\n * @deprecated\n */\nvar $urlMatcherFactoryProvider;\n//# sourceMappingURL=injectables.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/injectables.js\n// module id = 63\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@uirouter/core\");\n/**\n * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service\n */\nvar Ng1LocationServices = (function () {\n    function Ng1LocationServices($locationProvider) {\n        // .onChange() registry\n        this._urlListeners = [];\n        this.$locationProvider = $locationProvider;\n        var _lp = core_1.val($locationProvider);\n        core_1.createProxyFunctions(_lp, this, _lp, ['hashPrefix']);\n    }\n    Ng1LocationServices.prototype.dispose = function () { };\n    Ng1LocationServices.prototype.onChange = function (callback) {\n        var _this = this;\n        this._urlListeners.push(callback);\n        return function () { return core_1.removeFrom(_this._urlListeners)(callback); };\n    };\n    Ng1LocationServices.prototype.html5Mode = function () {\n        var html5Mode = this.$locationProvider.html5Mode();\n        html5Mode = core_1.isObject(html5Mode) ? html5Mode.enabled : html5Mode;\n        return html5Mode && this.$sniffer.history;\n    };\n    Ng1LocationServices.prototype.url = function (newUrl, replace, state) {\n        if (replace === void 0) { replace = false; }\n        if (newUrl)\n            this.$location.url(newUrl);\n        if (replace)\n            this.$location.replace();\n        if (state)\n            this.$location.state(state);\n        return this.$location.url();\n    };\n    Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser) {\n        var _this = this;\n        this.$location = $location;\n        this.$sniffer = $sniffer;\n        // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange\n        $rootScope.$on(\"$locationChangeSuccess\", function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });\n        var _loc = core_1.val($location);\n        var _browser = core_1.val($browser);\n        // Bind these LocationService functions to $location\n        core_1.createProxyFunctions(_loc, this, _loc, [\"replace\", \"path\", \"search\", \"hash\"]);\n        // Bind these LocationConfig functions to $location\n        core_1.createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);\n        // Bind these LocationConfig functions to $browser\n        core_1.createProxyFunctions(_browser, this, _browser, ['baseHref']);\n    };\n    /**\n     * Applys ng1-specific path parameter encoding\n     *\n     * The Angular 1 `$location` service is a bit weird.\n     * It doesn't allow slashes to be encoded/decoded bi-directionally.\n     *\n     * See the writeup at https://github.com/angular-ui/ui-router/issues/2598\n     *\n     * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F\n     *\n     * @param router\n     */\n    Ng1LocationServices.monkeyPatchPathParameterType = function (router) {\n        var pathType = router.urlMatcherFactory.type('path');\n        pathType.encode = function (val) {\n            return val != null ? val.toString().replace(/(~|\\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : val;\n        };\n        pathType.decode = function (val) {\n            return val != null ? val.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : val;\n        };\n    };\n    return Ng1LocationServices;\n}());\nexports.Ng1LocationServices = Ng1LocationServices;\n//# sourceMappingURL=locationServices.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/locationServices.js\n// module id = 64\n// module chunks = 0","\"use strict\";\n/** @module ng1 */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar angular_1 = require(\"./angular\");\n/**\n * `isState` Filter: truthy if the current state is the parameter\n *\n * Translates to [[StateService.is]] `$state.is(\"stateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'stateName' | isState\">show if state is 'stateName'</div>\n * ```\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n    var isFilter = function (state, params, options) {\n        return $state.is(state, params, options);\n    };\n    isFilter.$stateful = true;\n    return isFilter;\n}\nexports.$IsStateFilter = $IsStateFilter;\n/**\n * `includedByState` Filter: truthy if the current state includes the parameter\n *\n * Translates to [[StateService.includes]]` $state.is(\"fullOrPartialStateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'fullOrPartialStateName' | includedByState\">show if state includes 'fullOrPartialStateName'</div>\n * ```\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n    var includesFilter = function (state, params, options) {\n        return $state.includes(state, params, options);\n    };\n    includesFilter.$stateful = true;\n    return includesFilter;\n}\nexports.$IncludedByStateFilter = $IncludedByStateFilter;\nangular_1.ng.module('ui.router.state')\n    .filter('isState', $IsStateFilter)\n    .filter('includedByState', $IncludedByStateFilter);\n//# sourceMappingURL=stateFilters.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/stateFilters.js\n// module id = 65\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module ng1 */ /** */\nvar core_1 = require(\"@uirouter/core\");\nvar services_1 = require(\"../services\");\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,\n * `onRetain` callback hooks on a [[Ng1StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * ensures that those hooks are injectable for @uirouter/angularjs (ng1).\n */\nexports.getStateHookBuilder = function (hookName) {\n    return function stateHookBuilder(state, parentFn) {\n        var hook = state[hookName];\n        var pathname = hookName === 'onExit' ? 'from' : 'to';\n        function decoratedNg1Hook(trans, state) {\n            var resolveContext = new core_1.ResolveContext(trans.treeChanges(pathname));\n            var locals = core_1.extend(services_1.getLocals(resolveContext), { $state$: state, $transition$: trans });\n            return core_1.services.$injector.invoke(hook, this, locals);\n        }\n        return hook ? decoratedNg1Hook : undefined;\n    };\n};\n//# sourceMappingURL=onEnterExitRetain.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/statebuilders/onEnterExitRetain.js\n// module id = 66\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module view */\n/** for typedoc */\nvar angular_1 = require(\"./angular\");\nvar core_1 = require(\"@uirouter/core\");\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\nvar TemplateFactory = (function () {\n    function TemplateFactory() {\n        var _this = this;\n        /** @hidden */ this._useHttp = angular_1.ng.version.minor < 3;\n        /** @hidden */ this.$get = ['$http', '$templateCache', '$injector', function ($http, $templateCache, $injector) {\n                _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n                _this.$http = $http;\n                _this.$templateCache = $templateCache;\n                return _this;\n            }];\n    }\n    /** @hidden */\n    TemplateFactory.prototype.useHttpService = function (value) {\n        this._useHttp = value;\n    };\n    ;\n    /**\n     * Creates a template from a configuration object.\n     *\n     * @param config Configuration object for which to load a template.\n     * The following properties are search in the specified order, and the first one\n     * that is defined is used to create the template:\n     *\n     * @param params  Parameters to pass to the template function.\n     * @param context The resolve context associated with the template's view\n     *\n     * @return {string|object}  The template html as a string, or a promise for\n     * that string,or `null` if no template is configured.\n     */\n    TemplateFactory.prototype.fromConfig = function (config, params, context) {\n        var defaultTemplate = \"<ui-view></ui-view>\";\n        var asTemplate = function (result) { return core_1.services.$q.when(result).then(function (str) { return ({ template: str }); }); };\n        var asComponent = function (result) { return core_1.services.$q.when(result).then(function (str) { return ({ component: str }); }); };\n        return (core_1.isDefined(config.template) ? asTemplate(this.fromString(config.template, params)) :\n            core_1.isDefined(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) :\n                core_1.isDefined(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) :\n                    core_1.isDefined(config.component) ? asComponent(config.component) :\n                        core_1.isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) :\n                            asTemplate(defaultTemplate));\n    };\n    ;\n    /**\n     * Creates a template from a string or a function returning a string.\n     *\n     * @param template html template as a string or function that returns an html template as a string.\n     * @param params Parameters to pass to the template function.\n     *\n     * @return {string|object} The template html as a string, or a promise for that\n     * string.\n     */\n    TemplateFactory.prototype.fromString = function (template, params) {\n        return core_1.isFunction(template) ? template(params) : template;\n    };\n    ;\n    /**\n     * Loads a template from the a URL via `$http` and `$templateCache`.\n     *\n     * @param {string|Function} url url of the template to load, or a function\n     * that returns a url.\n     * @param {Object} params Parameters to pass to the url function.\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromUrl = function (url, params) {\n        if (core_1.isFunction(url))\n            url = url(params);\n        if (url == null)\n            return null;\n        if (this._useHttp) {\n            return this.$http.get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })\n                .then(function (response) {\n                return response.data;\n            });\n        }\n        return this.$templateRequest(url);\n    };\n    ;\n    /**\n     * Creates a template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromProvider = function (provider, params, context) {\n        var deps = core_1.services.$injector.annotate(provider);\n        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;\n        var resolvable = new core_1.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    ;\n    /**\n     * Creates a component's template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {\n        var deps = core_1.services.$injector.annotate(provider);\n        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;\n        var resolvable = new core_1.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    ;\n    /**\n     * Creates a template from a component's name\n     *\n     * This implements route-to-component.\n     * It works by retrieving the component (directive) metadata from the injector.\n     * It analyses the component's bindings, then constructs a template that instantiates the component.\n     * The template wires input and output bindings to resolves or from the parent component.\n     *\n     * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n     * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n     * @param component {string} Component's name in camel case.\n     * @param bindings An object defining the component's bindings: {foo: '<'}\n     * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {\n        bindings = bindings || {};\n        // Bind once prefix\n        var prefix = angular_1.ng.version.minor >= 3 ? \"::\" : \"\";\n        // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n        var kebob = function (camelCase) {\n            var kebobed = core_1.kebobString(camelCase);\n            return /^(x|data)-/.exec(kebobed) ? \"x-\" + kebobed : kebobed;\n        };\n        var attributeTpl = function (input) {\n            var name = input.name, type = input.type;\n            var attrName = kebob(name);\n            // If the ui-view has an attribute which matches a binding on the routed component\n            // then pass that attribute through to the routed component template.\n            // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n            if (uiView.attr(attrName) && !bindings[name])\n                return attrName + \"='\" + uiView.attr(attrName) + \"'\";\n            var resolveName = bindings[name] || name;\n            // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n            // some-attr=\"{{ ::$resolve.someResolveName }}\"\n            if (type === '@')\n                return attrName + \"='{{\" + prefix + \"$resolve.\" + resolveName + \"}}'\";\n            // Wire \"&\" callbacks to resolves that return a callback function\n            // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n            // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n            if (type === '&') {\n                var res = context.getResolvable(resolveName);\n                var fn = res && res.data;\n                var args = fn && core_1.services.$injector.annotate(fn) || [];\n                // account for array style injection, i.e., ['foo', function(foo) {}]\n                var arrayIdxStr = core_1.isArray(fn) ? \"[\" + (fn.length - 1) + \"]\" : '';\n                return attrName + \"='$resolve.\" + resolveName + arrayIdxStr + \"(\" + args.join(\",\") + \")'\";\n            }\n            // some-attr=\"::$resolve.someResolveName\"\n            return attrName + \"='\" + prefix + \"$resolve.\" + resolveName + \"'\";\n        };\n        var attrs = getComponentBindings(component).map(attributeTpl).join(\" \");\n        var kebobName = kebob(component);\n        return \"<\" + kebobName + \" \" + attrs + \"></\" + kebobName + \">\";\n    };\n    ;\n    return TemplateFactory;\n}());\nexports.TemplateFactory = TemplateFactory;\n// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\nfunction getComponentBindings(name) {\n    var cmpDefs = core_1.services.$injector.get(name + \"Directive\"); // could be multiple\n    if (!cmpDefs || !cmpDefs.length)\n        throw new Error(\"Unable to find component named '\" + name + \"'\");\n    return cmpDefs.map(getBindings).reduce(core_1.unnestR, []);\n}\n// Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\nvar getBindings = function (def) {\n    if (core_1.isObject(def.bindToController))\n        return scopeBindings(def.bindToController);\n    return scopeBindings(def.scope);\n};\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\nvar scopeBindings = function (bindingsObj) { return Object.keys(bindingsObj || {})\n    .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })\n    .filter(function (tuple) { return core_1.isDefined(tuple) && core_1.isArray(tuple[1]); })\n    .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); }); };\n//# sourceMappingURL=templateFactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/templateFactory.js\n// module id = 67\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module ng1 */ /** */\nvar angular_1 = require(\"./angular\");\n/** @hidden */\nfunction $ViewScrollProvider() {\n    var useAnchorScroll = false;\n    this.useAnchorScroll = function () {\n        useAnchorScroll = true;\n    };\n    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n            if (useAnchorScroll) {\n                return $anchorScroll;\n            }\n            return function ($element) {\n                return $timeout(function () {\n                    $element[0].scrollIntoView();\n                }, 0, false);\n            };\n        }];\n}\nangular_1.ng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n//# sourceMappingURL=viewScroll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/angularjs/lib/viewScroll.js\n// module id = 68\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** */\nvar transition_1 = require(\"../transition/transition\");\nvar router_1 = require(\"../router\");\nfunction addCoreResolvables(trans) {\n    trans.addResolvable({ token: router_1.UIRouter, deps: [], resolveFn: function () { return trans.router; }, data: trans.router }, \"\");\n    trans.addResolvable({ token: transition_1.Transition, deps: [], resolveFn: function () { return trans; }, data: trans }, \"\");\n    trans.addResolvable({ token: '$transition$', deps: [], resolveFn: function () { return trans; }, data: trans }, \"\");\n    trans.addResolvable({ token: '$stateParams', deps: [], resolveFn: function () { return trans.params(); }, data: trans.params() }, \"\");\n    trans.entering().forEach(function (state) {\n        trans.addResolvable({ token: '$state$', deps: [], resolveFn: function () { return state; }, data: state }, state);\n    });\n}\nexports.registerAddCoreResolvables = function (transitionService) {\n    return transitionService.onCreate({}, addCoreResolvables);\n};\n//# sourceMappingURL=coreResolvables.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/hooks/coreResolvables.js\n// module id = 69\n// module chunks = 0","\"use strict\";\n/** @module hooks */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar trace_1 = require(\"../common/trace\");\nvar rejectFactory_1 = require(\"../transition/rejectFactory\");\n/**\n * A [[TransitionHookFn]] that skips a transition if it should be ignored\n *\n * This hook is invoked at the end of the onBefore phase.\n *\n * If the transition should be ignored (because no parameter or states changed)\n * then the transition is ignored and not processed.\n */\nfunction ignoredHook(trans) {\n    var ignoredReason = trans._ignoredReason();\n    if (!ignoredReason)\n        return;\n    trace_1.trace.traceTransitionIgnored(trans);\n    var pending = trans.router.globals.transition;\n    // The user clicked a link going back to the *current state* ('A')\n    // However, there is also a pending transition in flight (to 'B')\n    // Abort the transition to 'B' because the user now wants to be back at 'A'.\n    if (ignoredReason === 'SameAsCurrent' && pending) {\n        pending.abort();\n    }\n    return rejectFactory_1.Rejection.ignored().toPromise();\n}\nexports.registerIgnoredTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, ignoredHook, { priority: -9999 });\n};\n//# sourceMappingURL=ignoredTransition.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/hooks/ignoredTransition.js\n// module id = 70\n// module chunks = 0","\"use strict\";\n/** @module hooks */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A [[TransitionHookFn]] that rejects the Transition if it is invalid\n *\n * This hook is invoked at the end of the onBefore phase.\n * If the transition is invalid (for example, param values do not validate)\n * then the transition is rejected.\n */\nfunction invalidTransitionHook(trans) {\n    if (!trans.valid()) {\n        throw new Error(trans.error());\n    }\n}\nexports.registerInvalidTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });\n};\n//# sourceMappingURL=invalidTransition.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/hooks/invalidTransition.js\n// module id = 71\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A factory which creates an onEnter, onExit or onRetain transition hook function\n *\n * The returned function invokes the (for instance) state.onEnter hook when the\n * state is being entered.\n *\n * @hidden\n */\nfunction makeEnterExitRetainHook(hookName) {\n    return function (transition, state) {\n        var _state = state.$$state();\n        var hookFn = _state[hookName];\n        return hookFn(transition, state);\n    };\n}\n/**\n * The [[TransitionStateHookFn]] for onExit\n *\n * When the state is being exited, the state's .onExit function is invoked.\n *\n * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n *\n * See: [[IHookRegistry.onExit]]\n */\nvar onExitHook = makeEnterExitRetainHook('onExit');\nexports.registerOnExitHook = function (transitionService) {\n    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onRetain\n *\n * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n *\n * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n *\n * See: [[IHookRegistry.onRetain]]\n */\nvar onRetainHook = makeEnterExitRetainHook('onRetain');\nexports.registerOnRetainHook = function (transitionService) {\n    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onEnter\n *\n * When the state is being entered, the state's .onEnter function is invoked.\n *\n * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n *\n * See: [[IHookRegistry.onEnter]]\n */\nvar onEnterHook = makeEnterExitRetainHook('onEnter');\nexports.registerOnEnterHook = function (transitionService) {\n    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n};\n//# sourceMappingURL=onEnterExitRetain.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/hooks/onEnterExitRetain.js\n// module id = 72\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** */\nvar predicates_1 = require(\"../common/predicates\");\nvar coreservices_1 = require(\"../common/coreservices\");\nvar targetState_1 = require(\"../state/targetState\");\n/**\n * A [[TransitionHookFn]] that redirects to a different state or params\n *\n * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n *\n * See [[StateDeclaration.redirectTo]]\n */\nvar redirectToHook = function (trans) {\n    var redirect = trans.to().redirectTo;\n    if (!redirect)\n        return;\n    var $state = trans.router.stateService;\n    function handleResult(result) {\n        if (!result)\n            return;\n        if (result instanceof targetState_1.TargetState)\n            return result;\n        if (predicates_1.isString(result))\n            return $state.target(result, trans.params(), trans.options());\n        if (result['state'] || result['params'])\n            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n    }\n    if (predicates_1.isFunction(redirect)) {\n        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n    }\n    return handleResult(redirect);\n};\nexports.registerRedirectToHook = function (transitionService) {\n    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n};\n//# sourceMappingURL=redirectTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/hooks/redirectTo.js\n// module id = 73\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */\n/** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar resolveContext_1 = require(\"../resolve/resolveContext\");\nvar hof_1 = require(\"../common/hof\");\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath);`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar eagerResolvePath = function (trans) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .resolvePath(\"EAGER\", trans)\n        .then(common_1.noop);\n};\nexports.registerEagerResolvePath = function (transitionService) {\n    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar lazyResolveState = function (trans, state) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .subContext(state.$$state())\n        .resolvePath(\"LAZY\", trans)\n        .then(common_1.noop);\n};\nexports.registerLazyResolveState = function (transitionService) {\n    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n};\n//# sourceMappingURL=resolve.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/hooks/resolve.js\n// module id = 74\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = require(\"../common/common\");\n/**\n * A [[TransitionHookFn]] which updates global UI-Router state\n *\n * Registered using `transitionService.onBefore({}, updateGlobalState);`\n *\n * Before a [[Transition]] starts, updates the global value of \"the current transition\" ([[Globals.transition]]).\n * After a successful [[Transition]], updates the global values of \"the current state\"\n * ([[Globals.current]] and [[Globals.$current]]) and \"the current param values\" ([[Globals.params]]).\n *\n * See also the deprecated properties:\n * [[StateService.transition]], [[StateService.current]], [[StateService.params]]\n */\nvar updateGlobalState = function (trans) {\n    var globals = trans.router.globals;\n    var transitionSuccessful = function () {\n        globals.successfulTransitions.enqueue(trans);\n        globals.$current = trans.$to();\n        globals.current = globals.$current.self;\n        common_1.copy(trans.params(), globals.params);\n    };\n    var clearCurrentTransition = function () {\n        // Do not clear globals.transition if a different transition has started in the meantime\n        if (globals.transition === trans)\n            globals.transition = null;\n    };\n    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });\n    trans.promise.then(clearCurrentTransition, clearCurrentTransition);\n};\nexports.registerUpdateGlobalState = function (transitionService) {\n    return transitionService.onCreate({}, updateGlobalState);\n};\n//# sourceMappingURL=updateGlobals.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/hooks/updateGlobals.js\n// module id = 75\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nvar updateUrl = function (transition) {\n    var options = transition.options();\n    var $state = transition.router.stateService;\n    var $urlRouter = transition.router.urlRouter;\n    // Dont update the url in these situations:\n    // The transition was triggered by a URL sync (options.source === 'url')\n    // The user doesn't want the url to update (options.location === false)\n    // The destination state, and all parents have no navigable url\n    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n        var urlOptions = { replace: options.location === 'replace' };\n        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n    }\n    $urlRouter.update(true);\n};\nexports.registerUpdateUrl = function (transitionService) {\n    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n};\n//# sourceMappingURL=url.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/hooks/url.js\n// module id = 76\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** for typedoc */\nvar common_1 = require(\"../common/common\");\nvar coreservices_1 = require(\"../common/coreservices\");\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nvar loadEnteringViews = function (transition) {\n    var $q = coreservices_1.services.$q;\n    var enteringViews = transition.views(\"entering\");\n    if (!enteringViews.length)\n        return;\n    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n};\nexports.registerLoadEnteringViews = function (transitionService) {\n    return transitionService.onFinish({}, loadEnteringViews);\n};\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nvar activateViews = function (transition) {\n    var enteringViews = transition.views(\"entering\");\n    var exitingViews = transition.views(\"exiting\");\n    if (!enteringViews.length && !exitingViews.length)\n        return;\n    var $view = transition.router.viewService;\n    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n    $view.sync();\n};\nexports.registerActivateViews = function (transitionService) {\n    return transitionService.onSuccess({}, activateViews);\n};\n//# sourceMappingURL=views.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/hooks/views.js\n// module id = 77\n// module chunks = 0","\"use strict\";\n/**\n * # Core classes and interfaces\n *\n * The classes and interfaces that are core to ui-router and do not belong\n * to a more specific subsystem (such as resolve).\n *\n * @coreapi\n * @preferred\n * @module core\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @internalapi */\nvar UIRouterPluginBase = (function () {\n    function UIRouterPluginBase() {\n    }\n    UIRouterPluginBase.prototype.dispose = function (router) { };\n    return UIRouterPluginBase;\n}());\nexports.UIRouterPluginBase = UIRouterPluginBase;\n//# sourceMappingURL=interface.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/interface.js\n// module id = 78\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./param\"));\n__export(require(\"./paramTypes\"));\n__export(require(\"./stateParams\"));\n__export(require(\"./paramType\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/params/index.js\n// module id = 79\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module path */ /** for typedoc */\n__export(require(\"./pathNode\"));\n__export(require(\"./pathFactory\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/path/index.js\n// module id = 80\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module resolve */ /** for typedoc */\n__export(require(\"./interface\"));\n__export(require(\"./resolvable\"));\n__export(require(\"./resolveContext\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/resolve/index.js\n// module id = 81\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./stateBuilder\"));\n__export(require(\"./stateObject\"));\n__export(require(\"./stateMatcher\"));\n__export(require(\"./stateQueueManager\"));\n__export(require(\"./stateRegistry\"));\n__export(require(\"./stateService\"));\n__export(require(\"./targetState\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/state/index.js\n// module id = 82\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # Transition subsystem\n *\n * This module contains APIs related to a Transition.\n *\n * See:\n * - [[TransitionService]]\n * - [[Transition]]\n * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n *\n * @coreapi\n * @preferred\n * @module transition\n */ /** for typedoc */\n__export(require(\"./interface\"));\n__export(require(\"./hookBuilder\"));\n__export(require(\"./hookRegistry\"));\n__export(require(\"./rejectFactory\"));\n__export(require(\"./transition\"));\n__export(require(\"./transitionHook\"));\n__export(require(\"./transitionEventType\"));\n__export(require(\"./transitionService\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/transition/index.js\n// module id = 83\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./urlMatcher\"));\n__export(require(\"./urlMatcherFactory\"));\n__export(require(\"./urlRouter\"));\n__export(require(\"./urlRule\"));\n__export(require(\"./urlService\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/url/index.js\n// module id = 84\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\n__export(require(\"./vanilla/index\"));\n//# sourceMappingURL=vanilla.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla.js\n// module id = 85\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./q\"));\n__export(require(\"./injector\"));\n__export(require(\"./baseLocationService\"));\n__export(require(\"./hashLocationService\"));\n__export(require(\"./memoryLocationService\"));\n__export(require(\"./pushStateLocationService\"));\n__export(require(\"./memoryLocationConfig\"));\n__export(require(\"./browserLocationConfig\"));\n__export(require(\"./utils\"));\n__export(require(\"./plugins\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla/index.js\n// module id = 86\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar browserLocationConfig_1 = require(\"./browserLocationConfig\");\nvar hashLocationService_1 = require(\"./hashLocationService\");\nvar utils_1 = require(\"./utils\");\nvar pushStateLocationService_1 = require(\"./pushStateLocationService\");\nvar memoryLocationService_1 = require(\"./memoryLocationService\");\nvar memoryLocationConfig_1 = require(\"./memoryLocationConfig\");\nvar injector_1 = require(\"./injector\");\nvar q_1 = require(\"./q\");\nvar coreservices_1 = require(\"../common/coreservices\");\nfunction servicesPlugin(router) {\n    coreservices_1.services.$injector = injector_1.$injector;\n    coreservices_1.services.$q = q_1.$q;\n    return { name: \"vanilla.services\", $q: q_1.$q, $injector: injector_1.$injector, dispose: function () { return null; } };\n}\nexports.servicesPlugin = servicesPlugin;\n/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\nexports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\nexports.pushStateLocationPlugin = utils_1.locationPluginFactory(\"vanilla.pushStateLocation\", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\nexports.memoryLocationPlugin = utils_1.locationPluginFactory(\"vanilla.memoryLocation\", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n//# sourceMappingURL=plugins.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/vanilla/plugins.js\n// module id = 87\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./view\"));\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@uirouter/core/lib/view/index.js\n// module id = 88\n// module chunks = 0","import angular from 'angular';\nimport uiRouter from '@uirouter/angularjs';\nimport { sjLogger } from 'sanji-logger-ui';\n\nimport RouterHelperProvider from './router-helper';\n\nconst sjRouter = angular.module('sanji.router', [uiRouter, sjLogger]).provider('routerHelper', RouterHelperProvider)\n  .name;\nexport { sjRouter };\n\n\n\n// WEBPACK FOOTER //\n// ./component/index.js"],"sourceRoot":""}